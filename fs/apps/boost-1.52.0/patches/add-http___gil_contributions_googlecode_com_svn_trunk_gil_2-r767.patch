Index: boost-1.52.0/src/boost/gil/extension/io_new/bmp_all.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/bmp_all.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,25 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_ALL_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_ALL_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date   2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "bmp_read.hpp"
+#include "bmp_write.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_ALL_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/bmp_io_old.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/bmp_io_old.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,181 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_IO_OLD_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_IO_OLD_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "bmp_all.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup BMP_IO
+/// \brief Returns the width and height of the BMP file at the specified location.
+/// Throws std::ios_base::failure if the location does not correspond to a valid BMP file
+template< typename String >
+inline
+point2< std::ptrdiff_t > bmp_read_dimensions( const String& filename )
+{
+    typedef typename get_reader_backend< String
+                                       , bmp_tag
+                                       >::type backend_t;
+
+    backend_t backend = read_image_info( filename
+                                       , bmp_tag()
+                                       );
+
+    return point2< std::ptrdiff_t >( backend._info._width
+                                   , backend._info._height
+                                   );
+}
+
+
+/// \ingroup BMP_IO
+/// \brief Loads the image specified by the given bmp image file name into the given view.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the BMP library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid BMP file, or if its color space or channel depth are not
+/// compatible with the ones specified by View, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline
+void bmp_read_view( const String& filename
+                  , const View&   view
+                  )
+{
+    read_view( filename
+             , view
+             , bmp_tag()
+             );
+}
+
+/// \ingroup BMP_IO
+/// \brief Allocates a new image whose dimensions are determined by the given bmp image file, and loads the pixels into it.
+/// Triggers a compile assert if the image color space or channel depth are not supported by the BMP library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid BMP file, or if its color space or channel depth are not
+/// compatible with the ones specified by Image
+template< typename String
+        , typename Image
+        >
+inline
+void bmp_read_image( const String& filename
+                   , Image&        img
+                   )
+{
+    read_image( filename
+              , img
+              , bmp_tag()
+              );
+}
+
+/// \ingroup BMP_IO
+/// \brief Loads and color-converts the image specified by the given bmp image file name into the given view.
+/// Throws std::ios_base::failure if the file is not a valid BMP file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        , typename CC
+        >
+inline
+void bmp_read_and_convert_view( const String& filename
+                              , const View&   view
+                              , CC            cc
+                              )
+{
+    read_and_convert_view( filename
+                         , view
+                         , cc
+                         , bmp_tag()
+                         );
+}
+
+/// \ingroup BMP_IO
+/// \brief Loads and color-converts the image specified by the given bmp image file name into the given view.
+/// Throws std::ios_base::failure if the file is not a valid BMP file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline
+void bmp_read_and_convert_view( const String& filename
+                              , const View&   view
+                              )
+{
+    read_and_convert_view( filename
+                         , view
+                         , bmp_tag()
+                         );
+}
+
+/// \ingroup BMP_IO
+/// \brief Allocates a new image whose dimensions are determined by the given bmp image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid BMP file
+template< typename String
+        , typename Image
+        , typename CC
+        >
+inline
+void bmp_read_and_convert_image( const String& filename
+                               , Image&        img
+                               , CC            cc
+                               )
+{
+    read_and_convert_image( filename
+                          , img
+                          , cc
+                          , bmp_tag()
+                          );
+}
+
+/// \ingroup BMP_IO
+/// \brief Allocates a new image whose dimensions are determined by the given bmp image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid BMP file
+template< typename String
+        , typename Image
+        >
+inline
+void bmp_read_and_convert_image( const String filename
+                               , Image&       img
+                               )
+{
+    read_and_convert_image( filename
+                          , img
+                          , bmp_tag()
+                          );
+}
+
+
+/// \ingroup BMP_IO
+/// \brief Saves the view to a bmp file specified by the given bmp image file name.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the BMP library or by the I/O extension.
+/// Throws std::ios_base::failure if it fails to create the file.
+template< typename String
+        , typename View
+        >
+inline
+void bmp_write_view( const String& filename
+                   , const View&   view
+                   )
+{
+    write_view( filename
+              , view
+              , bmp_tag()
+              );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_IO_OLD_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/bmp_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/bmp_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,43 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_READ_HPP
+
+#define BOOST_GIL_EXTENSION_IO_BMP_READ_ENABLED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "bmp_tags.hpp"
+#include "formats/bmp/supported_types.hpp"
+#include "formats/bmp/read.hpp"
+#include "formats/bmp/scanline_read.hpp"
+
+#include "detail/get_reader.hpp"
+#include "detail/make_backend.hpp"
+#include "detail/make_reader.hpp"
+#include "detail/make_dynamic_image_reader.hpp"
+#include "detail/make_scanline_reader.hpp"
+
+#include "detail/read_image.hpp"
+#include "detail/read_view.hpp"
+#include "detail/read_image_info.hpp"
+#include "detail/read_and_convert_image.hpp"
+#include "detail/read_and_convert_view.hpp"
+
+#include "detail/image_read_iterator.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/bmp_tags.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/bmp_tags.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,164 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_TAGS_HPP 
+#define BOOST_GIL_EXTENSION_IO_BMP_TAGS_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief 
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "detail/base.hpp"
+
+namespace boost { namespace gil {
+
+/// Defines bmp tag.
+struct bmp_tag : format_tag {};
+
+    /// See http://en.wikipedia.org/wiki/BMP_file_format#BMP_File_Header for reference.
+
+/// Defines type for offset value.
+struct bmp_offset : property_base< uint32_t > {};
+
+/// Defines type for header sizes.
+struct bmp_header_size : property_base< uint32_t >
+{
+    static const type _size            = 14; /// Constant size for bmp file header size.
+    static const type _win32_info_size = 40; /// Constant size for win32 bmp info header size.
+    static const type _os2_info_size   = 12; /// Constant size for os2 bmp info header size.
+};
+
+/// Defines type for image width property.
+struct bmp_image_width : property_base< int32_t > {};
+
+/// Defines type for image height property.
+struct bmp_image_height : property_base< int32_t > {};
+
+/// Defines type for bits per pixels property.
+struct bmp_bits_per_pixel : property_base< uint16_t > {};
+
+/// Defines type for compression property.
+struct bmp_compression : property_base< uint32_t >
+{
+    static const type _rgb      = 0; /// RGB without compression
+    static const type _rle8     = 1; /// 8 bit index with RLE compression
+    static const type _rle4     = 2; /// 4 bit index with RLE compression
+    static const type _bitfield = 3; /// 16 or 32 bit fields without compression
+};
+
+/// Defines type for image size property.
+struct bmp_image_size : property_base< uint32_t > {};
+
+/// Defines type for horizontal resolution property.
+struct bmp_horizontal_resolution : property_base< int32_t > {};
+
+/// Defines type for vertical resolution property.
+struct bmp_vertical_resolution : property_base< int32_t > {};
+
+/// Defines type for number of colors property.
+struct bmp_num_colors : property_base< uint32_t > {};
+
+/// Defines type for important number of colors property.
+struct bmp_num_important_colors : property_base< uint32_t > {};
+
+static const uint32_t bmp_signature = 0x4D42; /// Constant signature for bmp file format.
+
+/// Read information for bmp images.
+///
+/// The structure is returned when using read_image_info.
+template<>
+struct image_read_info< bmp_tag >
+{
+    /// Default contructor.
+    image_read_info< bmp_tag >()
+    : _valid( false )
+    {}
+
+    /// The offset, i.e. starting address, of the byte where the bitmap data can be found.
+    bmp_offset::type _offset;
+
+    /// The size of this header:
+    /// - 40 bytes for Windows V3 header
+    /// - 12 bytes for OS/2 V1 header
+    bmp_header_size::type _header_size;
+
+    /// The bitmap width in pixels ( signed integer ).
+    bmp_image_width::type  _width;
+
+    /// The bitmap height in pixels ( signed integer ).
+    bmp_image_height::type _height;
+
+    /// The number of bits per pixel, which is the color depth of the image.
+    /// Typical values are 1, 4, 8, 16, 24 and 32.
+    bmp_bits_per_pixel::type _bits_per_pixel;
+
+    /// The compression method being used. See above for a list of possible values.
+    bmp_compression::type _compression;
+
+    /// The image size. This is the size of the raw bitmap data (see below), 
+    /// and should not be confused with the file size.
+    bmp_image_size::type _image_size;
+
+    /// The horizontal resolution of the image. (pixel per meter, signed integer)
+    bmp_horizontal_resolution::type _horizontal_resolution;
+
+    /// The vertical resolution of the image. (pixel per meter, signed integer)
+    bmp_vertical_resolution::type   _vertical_resolution;
+
+    /// The number of colors in the color palette, or 0 to default to 2^n - 1.
+    bmp_num_colors::type            _num_colors;
+
+    /// The number of important colors used, or 0 when every color is important; 
+    /// generally ignored.
+    bmp_num_important_colors::type  _num_important_colors;
+
+    /// Used internaly to identify is the header has been read.
+    bool _valid;
+};
+
+/// Read settings for bmp images.
+///
+/// The structure can be used for all read_xxx functions, except read_image_info.
+template<>
+struct image_read_settings< bmp_tag > : public image_read_settings_base
+{
+    /// Default constructor
+    image_read_settings()
+    : image_read_settings_base()
+    {}
+
+    /// Constructor
+    /// \param top_left Top left coordinate for reading partial image.
+    /// \param dim      Dimensions for reading partial image.
+    image_read_settings( const point_t& top_left
+                       , const point_t& dim
+                       )
+    : image_read_settings_base( top_left
+                              , dim
+                              )
+    {}
+};
+
+/// Write information for bmp images.
+///
+/// The structure can be used for write_view() function.
+template<>
+struct image_write_info< bmp_tag >
+{
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_TAGS_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/bmp_write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/bmp_write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "bmp_tags.hpp"
+#include "formats/bmp/supported_types.hpp"
+#include "formats/bmp/write.hpp"
+
+#include "detail/make_writer.hpp"
+#include "detail/make_dynamic_image_writer.hpp"
+
+#include "detail/write_view.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/base.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/base.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,125 @@
+/*
+    Copyright 2007-2008 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_BASE_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_BASE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <ostream>
+#include <istream>
+#include <vector>
+
+#include <boost/array.hpp>
+#include <boost/bind.hpp>
+#include <boost/type_traits/is_base_of.hpp>
+
+#include <boost/gil/utilities.hpp>
+#include <boost/gil/color_convert.hpp>
+#include <boost/gil/bit_aligned_pixel_reference.hpp>
+#include <boost/gil/bit_aligned_pixel_iterator.hpp>
+
+#include <boost/gil/extension/toolbox/gil_extensions.hpp>
+
+#include "typedefs.hpp"
+#include "io_error.hpp"
+
+namespace boost { namespace gil {
+
+struct format_tag {};
+
+template< typename Property > 
+struct property_base
+{
+    typedef Property type;
+};
+
+template<typename FormatTag> struct is_format_tag : is_base_and_derived< format_tag
+                                                                       , FormatTag
+                                                                       > {};
+
+struct image_read_settings_base
+{
+protected:
+
+    image_read_settings_base()
+    : _top_left( 0, 0 )
+    , _dim     ( 0, 0 )
+    {}
+
+    image_read_settings_base( const point_t& top_left
+                            , const point_t& dim
+                            )
+    : _top_left( top_left )
+    , _dim     ( dim      )
+    {}
+
+
+public:
+
+    void set( const point_t& top_left
+            , const point_t& dim
+            )
+    {
+        _top_left = top_left;
+        _dim      = dim;
+    }
+
+public:
+
+    point_t _top_left;
+    point_t _dim;
+};
+
+/**
+ * Boolean meta function, mpl::true_ if the pixel type \a PixelType is supported 
+ * by the image format identified with \a FormatTag.
+ * \todo the name is_supported is to generic, pick something more IO realted.
+ */
+// Depending on image type the parameter Pixel can be a reference type 
+// for bit_aligned images or a pixel for byte images.
+template< typename Pixel, typename FormatTag > struct is_read_supported {};
+template< typename Pixel, typename FormatTag > struct is_write_supported {};
+
+
+namespace detail {
+
+template< typename Property > 
+struct property_base
+{
+    typedef Property type;
+};
+
+} // namespace detail
+
+struct read_support_true  { BOOST_STATIC_CONSTANT( bool, is_supported = true  ); };
+struct read_support_false { BOOST_STATIC_CONSTANT( bool, is_supported = false ); };
+struct write_support_true { BOOST_STATIC_CONSTANT( bool, is_supported = true  ); };
+struct write_support_false{ BOOST_STATIC_CONSTANT( bool, is_supported = false ); };
+
+class no_log {};
+
+template< typename Device, typename FormatTag > struct reader_backend;
+template< typename Device, typename FormatTag > struct writer_backend;
+
+template< typename FormatTag > struct image_read_info;
+template< typename FormatTag > struct image_read_settings;
+template< typename FormatTag, typename Log = no_log > struct image_write_info;
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_BASE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/bit_operations.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/bit_operations.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,245 @@
+/*
+    Copyright 2007-2008 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_BIT_OPERATIONS_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_BIT_OPERATIONS_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date   2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/bind.hpp>
+
+namespace boost { namespace gil { namespace detail {
+
+// 1110 1100 -> 0011 0111
+template< typename Buffer
+        , typename IsBitAligned
+        >
+struct mirror_bits
+{
+   mirror_bits( bool ) {}
+
+   void operator() ( Buffer& ) {}
+
+
+    void operator() ( byte_t* , std::size_t )
+    {
+    }
+};
+
+
+// The functor will generate a lookup table since the
+// mirror operation is quite costly.
+template< typename Buffer >
+struct mirror_bits< Buffer
+                  , mpl::true_
+                  >
+{
+   mirror_bits( bool apply_operation = true )
+   : _apply_operation( apply_operation )
+   {
+        if( _apply_operation == true )
+        {
+            byte_t i = 0;
+            do
+            {
+                _lookup[i] = mirror( i );
+            }
+            while( i++ != 255 );
+        }
+   }
+
+   void operator() ( Buffer& buf )
+   {
+        if( _apply_operation == true )
+        {
+            for_each( buf.begin()
+                    , buf.end()
+                    , boost::bind( &mirror_bits< Buffer
+                                               , mpl::true_
+                                               >::lookup
+                                 , *this
+                                 , _1
+                                 )
+                    );
+        }
+   }
+
+    void operator() ( byte_t* dst, std::size_t size )
+    {
+        for( std::size_t i = 0; i < size; ++i )
+        {
+            lookup(*dst);
+            ++dst;
+        }
+    }
+
+private:
+
+    void lookup( byte_t& c )
+    {
+        c = _lookup[ c ];
+    }
+
+    static byte_t mirror( byte_t c )
+    {
+        byte_t result = 0;
+        for( int i = 0; i < 8; ++i )
+        {
+            result = result << 1;
+            result |= ( c & 1 );
+            c = c >> 1;
+        }
+
+        return result;
+    }
+ 
+private:
+
+    bool _apply_operation;
+
+    array< byte_t, 256 > _lookup;
+};
+
+
+// 0011 1111 -> 1100 0000
+template< typename Buffer
+        , typename IsBitAligned
+        >
+struct negate_bits
+{
+    void operator() ( Buffer& ) {}
+};
+
+template< typename Buffer >
+struct negate_bits< Buffer, mpl::true_ >
+{
+    void operator() ( Buffer& buf )
+    {
+        for_each( buf.begin()
+                , buf.end()
+                , negate_bits< Buffer, mpl::true_ >::negate
+                );
+    }
+
+    void operator() ( byte_t* dst, std::size_t size )
+    {
+        for( std::size_t i = 0; i < size; ++i )
+        {
+            negate(*dst);
+            ++dst;
+        }
+    }
+
+private:
+
+    static void negate( byte_t& b )
+    {
+        b = ~b;
+    }
+};
+
+
+// 11101100 -> 11001110
+template< typename Buffer
+        , typename IsBitAligned
+        >
+struct swap_half_bytes
+{
+    void operator() ( Buffer& ) {}
+};
+
+template< typename Buffer >
+struct swap_half_bytes< Buffer
+                      , mpl::true_
+                      >
+{
+    void operator() ( Buffer& buf )
+    {
+        for_each( buf.begin()
+                , buf.end()
+                , swap_half_bytes< Buffer, mpl::true_ >::swap
+                );
+    }
+
+    void operator() ( byte_t* dst, std::size_t size )
+    {
+        for( std::size_t i = 0; i < size; ++i )
+        {
+            swap(*dst);
+            ++dst;
+        }
+    }
+
+
+private:
+
+    static void swap( byte_t& c )
+    {
+        c = (( c << 4 ) & 0xF0 ) | (( c >> 4 ) & 0x0F );
+    }
+};
+
+template< typename Buffer >
+struct do_nothing
+{
+   do_nothing() {}
+
+   void operator() ( Buffer& ) {}
+};
+
+/// Count consecutive zeros on the right
+template< typename T >
+inline
+unsigned int trailing_zeros( T x )
+throw()
+{
+    unsigned int n = 0;
+
+    x = ~x & (x - 1);
+
+    while( x )
+    {
+        n = n + 1;
+        x = x >> 1;
+    }
+
+    return n;
+}
+
+/// Counts ones in a bit-set
+template< typename T >
+inline
+unsigned int count_ones( T x )
+throw()
+{
+    unsigned int n = 0;
+
+    while( x )
+    {
+	    // clear the least significant bit set
+	    x &= x - 1;
+	    ++n;
+    }
+
+    return n;
+}
+
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_BIT_OPERATIONS_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/conversion_policies.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/conversion_policies.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,107 @@
+/*
+    Copyright 2007-2008 Andreas Pokorny, Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_CONVERSION_POLICIES_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_CONVERSION_POLICIES_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Andreas Pokorny, Christian Henning \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <algorithm>
+#include <iterator>
+#include <boost/gil/image_view_factory.hpp>
+
+namespace boost{namespace gil{ namespace detail {
+
+struct read_and_no_convert 
+{
+public:
+    typedef void* color_converter_type;
+
+    template< typename InIterator
+            , typename OutIterator
+            >
+    void read( const InIterator& /* begin */
+             , const InIterator& /* end   */
+             , OutIterator       /* out   */
+             , typename disable_if< typename pixels_are_compatible< typename std::iterator_traits<InIterator>::value_type
+                                                                  , typename std::iterator_traits<OutIterator>::value_type
+                                                                  >::type 
+                                  >::type* /* ptr */ = 0
+             )
+    {
+        io_error( "Data cannot be copied because the pixels are incompatible." );
+    }
+
+    template< typename InIterator
+            , typename OutIterator
+            >
+    void read( const InIterator& begin
+             , const InIterator& end
+             , OutIterator       out
+             , typename enable_if< typename pixels_are_compatible< typename std::iterator_traits<InIterator>::value_type
+                                                                 , typename std::iterator_traits<OutIterator>::value_type
+                                                                 >::type 
+                                 >::type* /* ptr */ = 0
+             )
+    {
+        std::copy( begin
+                 , end
+                 , out
+                 );
+    }
+
+};
+
+template<typename CC>
+struct read_and_convert
+{
+public:
+    typedef CC color_converter_type;
+    CC _cc;
+
+    read_and_convert()
+    {}
+
+    read_and_convert( const color_converter_type& cc )
+    : _cc( cc )
+    {}
+
+    template< typename InIterator
+            , typename OutIterator
+            >
+    void read( const InIterator& begin
+             , const InIterator& end
+             , OutIterator       out
+             )
+    {
+        typedef color_convert_deref_fn< typename std::iterator_traits<InIterator>::reference
+                                      , typename std::iterator_traits<OutIterator>::value_type //reference?
+                                      , CC
+                                      > deref_t;
+
+        std::transform( begin
+                      , end
+                      , out
+                      , deref_t( _cc )
+                      );
+    }
+};
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_CONVERSION_POLICIES_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/dynamic_io_new.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/dynamic_io_new.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,115 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+
+    See http://opensource.adobe.com/gil for most recent version including documentation.
+*/
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_TOOLBOX_DYNAMIC_IMAGES_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_TOOLBOX_DYNAMIC_IMAGES_HPP_INCLUDED
+
+/// \file
+/// \brief  Generic io functions for dealing with dynamic images
+//
+/// \author Hailin Jin and Lubomir Bourdev \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated May 30, 2006
+
+#include <boost/mpl/at.hpp>
+#include <boost/mpl/size.hpp>
+#include <boost/gil/gil_config.hpp>
+#include <boost/gil/extension/io_new/detail/io_error.hpp>
+#include <boost/gil/extension/dynamic_image/dynamic_image_all.hpp>
+
+namespace boost { namespace gil {
+
+// need this for various meta functions.
+struct any_image_pixel_t       {};
+struct any_image_channel_t     {};
+struct any_image_color_space_t {};
+
+namespace detail {
+
+template <long N>
+struct construct_matched_t {
+    template <typename Images,typename Pred>
+    static bool apply(any_image<Images>& im,Pred pred) {
+        if (pred.template apply<typename mpl::at_c<Images,N-1>::type>()) {
+            typename mpl::at_c<Images,N-1>::type x;
+            im.move_in(x);
+            return true;
+        } else return construct_matched_t<N-1>::apply(im,pred);
+    }
+};
+template <>
+struct construct_matched_t<0> {
+    template <typename Images,typename Pred>
+    static bool apply(any_image<Images>&,Pred) {return false;}
+};
+
+// A function object that can be passed to apply_operation.
+// Given a predicate IsSupported taking a view type and returning an MPL boolean,
+// calls the apply method of OpClass with the view if the given view IsSupported, or throws an exception otherwise
+template <typename IsSupported, typename OpClass>
+class dynamic_io_fnobj {
+    OpClass* _op;
+
+    template <typename View>
+    void apply(const View& view,mpl::true_ ) {_op->apply(view);}
+
+    template <typename View, typename Info >
+    void apply( const View& view
+              , const Info& info
+              , const mpl::true_
+              )
+    {
+        _op->apply( view, info );
+    }
+
+    template <typename View>
+    void apply(const View& /* view */ ,mpl::false_) {io_error("dynamic_io: unsupported view type for the given file format");}
+
+    template <typename View, typename Info >
+    void apply( const View& /* view */
+              , const Info& /* info */
+              , const mpl::false_
+              )
+    {
+        io_error( "dynamic_io: unsupported view type for the given file format" );
+    }
+
+public:
+    dynamic_io_fnobj(OpClass* op) : _op(op) {}
+
+    typedef void result_type;
+
+    template <typename View>
+    void operator()(const View& view) {apply(view,typename IsSupported::template apply<View>::type());}
+
+    template< typename View, typename Info >
+    void operator()(const View& view, const Info& info )
+    {
+        apply( view
+             , info
+             , typename IsSupported::template apply< View >::type()
+             );
+    }
+
+};
+
+} // namespace detail
+
+/// \brief Within the any_image, constructs an image with the given dimensions
+///        and a type that satisfies the given predicate
+template <typename Images,typename Pred>
+inline bool construct_matched(any_image<Images>& im,Pred pred) {
+    return detail::construct_matched_t<mpl::size<Images>::value>::apply(im,pred);
+}
+
+} }  // namespace boost::gil
+
+#endif // BOOST_GIL_EXTENSION_TOOLBOX_DYNAMIC_IMAGES_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/get_read_device.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/get_read_device.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,72 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_GET_READER_DEVICE_HPP
+#define BOOST_GIL_EXTENSION_IO_GET_READER_DEVICE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/mpl/and.hpp>
+#include <boost/utility/enable_if.hpp>
+
+#include "io_device.hpp"
+#include "path_spec.hpp"
+
+namespace boost { namespace gil {
+
+template< typename T
+        , typename FormatTag
+        , class Enable = void
+        >
+struct get_read_device
+{};
+
+template< typename Device
+        , typename FormatTag
+        >
+struct get_read_device< Device
+                      , FormatTag
+                      , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                                        , Device
+                                                                                        >
+                                                     , is_format_tag< FormatTag >
+                                                     >
+                                          >::type
+                 >
+{
+    typedef typename detail::is_adaptable_input_device< FormatTag
+                                                      , Device
+                                                      >::device_type type;
+};
+
+template< typename String
+        , typename FormatTag
+        >
+struct get_read_device< String
+                      , FormatTag
+                      , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                     , is_format_tag< FormatTag >
+                                                     >
+                                          >::type
+                      >
+{
+    typedef detail::file_stream_device< FormatTag > type;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_GET_READER_DEVICE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/get_reader.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/get_reader.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,205 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_GET_READER_HPP
+#define BOOST_GIL_EXTENSION_IO_GET_READER_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "get_read_device.hpp"
+
+namespace boost { namespace gil {
+
+/// \brief Helper metafunction to generate image reader type.
+template< typename T
+        , typename FormatTag
+        , typename ConversionPolicy
+        , class Enable = void
+        >
+struct get_reader
+{};
+
+template< typename String
+        , typename FormatTag
+        , typename ConversionPolicy
+        >
+struct get_reader< String
+                 , FormatTag
+                 , ConversionPolicy
+                 , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                , is_format_tag< FormatTag >
+                                                >
+                                     >::type
+                 >
+{
+    typedef typename get_read_device< String
+                                    , FormatTag
+                                    >::type device_t;
+
+    typedef reader< device_t
+                  , FormatTag
+                  , ConversionPolicy
+                  > type;
+};
+
+template< typename Device
+        , typename FormatTag
+        , typename ConversionPolicy
+        >
+struct get_reader< Device
+                 , FormatTag
+                 , ConversionPolicy
+                 , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                                   , Device
+                                                                                   >
+                                                , is_format_tag< FormatTag >
+                                                >
+                                     >::type
+                 >
+{
+    typedef typename get_read_device< Device
+                                    , FormatTag
+                                    >::type device_t;
+
+    typedef reader< device_t
+                  , FormatTag
+                  , ConversionPolicy
+                  > type;
+};
+
+
+/// \brief Helper metafunction to generate dynamic image reader type.
+template< typename T
+        , typename FormatTag
+        , class Enable = void
+        >
+struct get_dynamic_image_reader
+{};
+
+template< typename String
+        , typename FormatTag
+        >
+struct get_dynamic_image_reader< String
+                               , FormatTag
+                               , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                              , is_format_tag< FormatTag >
+                                                              >
+                                                   >::type
+                               >
+{
+    typedef typename get_read_device< String
+                                    , FormatTag
+                                    >::type device_t;
+
+    typedef dynamic_image_reader< device_t
+                                , FormatTag
+                                > type;
+};
+
+template< typename Device
+        , typename FormatTag
+        >
+struct get_dynamic_image_reader< Device
+                               , FormatTag
+                               , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                                                 , Device
+                                                                                                 >
+                                                              , is_format_tag< FormatTag >
+                                                              >
+                                                   >::type
+                               >
+{
+    typedef typename get_read_device< Device
+                                    , FormatTag
+                                    >::type device_t;
+
+    typedef dynamic_image_reader< device_t
+                                , FormatTag
+                                > type;
+};
+
+
+/////////////////////////////////////////////////////////////
+
+/// \brief Helper metafunction to generate image backend type.
+template< typename T
+        , typename FormatTag
+        , class Enable = void
+        >
+struct get_reader_backend
+{};
+
+template< typename String
+        , typename FormatTag
+        >
+struct get_reader_backend< String
+                         , FormatTag
+                         , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                        , is_format_tag< FormatTag >
+                                                        >
+                                             >::type
+                         >
+{
+    typedef typename get_read_device< String
+                                    , FormatTag
+                                    >::type device_t;
+
+    typedef reader_backend< device_t
+                          , FormatTag
+                          > type;
+};
+
+template< typename Device
+        , typename FormatTag
+        >
+struct get_reader_backend< Device
+                         , FormatTag
+                         , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                                           , Device
+                                                                                           >
+                                                        , is_format_tag< FormatTag >
+                                                        >
+                                             >::type
+                         >
+{
+    typedef typename get_read_device< Device
+                                    , FormatTag
+                                    >::type device_t;
+
+    typedef reader_backend< device_t
+                          , FormatTag
+                          > type;
+};
+
+/// \brief Helper metafunction to generate image scanline_reader type.
+template< typename T
+        , typename FormatTag
+        >
+struct get_scanline_reader
+{
+    typedef typename get_read_device< T
+                                    , FormatTag
+                                    >::type device_t;
+
+    typedef scanline_reader< device_t
+                           , FormatTag
+                           > type;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_GET_READER_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/get_write_device.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/get_write_device.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,73 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_GET_WRITE_DEVICE_HPP
+#define BOOST_GIL_EXTENSION_IO_GET_WRITE_DEVICE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/mpl/and.hpp>
+#include <boost/utility/enable_if.hpp>
+#include <boost/gil/extension/io_new/detail/path_spec.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+
+namespace boost { namespace gil {
+
+template< typename T
+        , typename FormatTag
+        , class Enable = void
+        >
+struct get_write_device
+{};
+
+
+template< typename Device
+        , typename FormatTag
+        >
+struct get_write_device< Device
+                       , FormatTag
+                       , typename enable_if< mpl::and_< detail::is_adaptable_output_device< FormatTag
+                                                                                          , Device
+                                                                                          >
+                                                      , is_format_tag< FormatTag >
+                                                      >
+                                           >::type
+                       >
+{
+    typedef typename detail::is_adaptable_output_device< FormatTag
+                                                       , Device
+                                                       >::device_type type;
+};
+
+
+template< typename String
+        , typename FormatTag
+        >
+struct get_write_device< String
+                       , FormatTag
+                       , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                      , is_format_tag< FormatTag >
+                                                      >
+                                           >::type
+                       >
+{
+    typedef detail::file_stream_device< FormatTag > type;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_GET_WRITE_DEVICE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/get_writer.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/get_writer.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,132 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_GET_WRITER_HPP
+#define BOOST_GIL_EXTENSION_IO_GET_WRITER_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "get_write_device.hpp"
+
+namespace boost { namespace gil {
+
+/// \brief Helper metafunction to generate writer type.
+template< typename T
+        , typename FormatTag
+        , class Enable = void
+        >
+struct get_writer
+{};
+
+
+template< typename String
+        , typename FormatTag
+        >
+struct get_writer< String
+                 , FormatTag
+                 , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                , is_format_tag< FormatTag >
+                                                >
+                                     >::type
+                 >
+{
+    typedef typename get_write_device< String
+                                     , FormatTag
+                                     >::type device_t;
+
+    typedef writer< device_t
+                  , FormatTag
+                  > type;
+};
+
+template< typename Device
+        , typename FormatTag
+        >
+struct get_writer< Device
+                 , FormatTag
+                 , typename enable_if< mpl::and_< detail::is_adaptable_output_device< FormatTag
+                                                                                    , Device
+                                                                                    >
+                                                , is_format_tag< FormatTag >
+                                                >
+                                     >::type
+                 >
+{
+    typedef typename get_write_device< Device
+                                     , FormatTag
+                                     >::type device_t;
+
+    typedef writer< device_t
+                  , FormatTag
+                  > type;
+};
+
+
+/// \brief Helper metafunction to generate dynamic image writer type.
+template< typename T
+        , typename FormatTag
+        , class Enable = void
+        >
+struct get_dynamic_image_writer
+{};
+
+template< typename String
+        , typename FormatTag
+        >
+struct get_dynamic_image_writer< String
+                               , FormatTag
+                               , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                              , is_format_tag< FormatTag >
+                                                              >
+                                                   >::type
+                               >
+{
+    typedef typename get_write_device< String
+                                     , FormatTag
+                                     >::type device_t;
+
+    typedef dynamic_image_writer< device_t
+                                , FormatTag
+                                > type;
+};
+
+template< typename Device
+        , typename FormatTag
+        >
+struct get_dynamic_image_writer< Device
+                               , FormatTag
+                               , typename enable_if< mpl::and_< detail::is_write_device< FormatTag
+                                                                                       , Device
+                                                                                       >
+                                                              , is_format_tag< FormatTag >
+                                                              >
+                                                   >::type
+                               >
+{
+    typedef typename get_write_device< Device
+                                     , FormatTag
+                                     >::type device_t;
+
+    typedef dynamic_image_writer< device_t
+                                , FormatTag
+                                > type;
+};
+
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_GET_WRITER_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/image_read_iterator.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/image_read_iterator.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,235 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_IMAGE_READ_ITERATOR_HPP
+#define BOOST_GIL_EXTENSION_IO_IMAGE_READ_ITERATOR_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+
+namespace boost { namespace gil {
+
+/// Input iterator to read images.
+template< typename Reader >
+class scanline_read_iterator
+{
+public:
+
+    typedef typename Reader::backend_t backend_t;
+
+    typedef std::input_iterator_tag iterator_category;
+    typedef byte_t* value_type;
+    typedef value_type const* pointer;
+    typedef value_type const& reference;
+    
+    /// todo
+    //typedef ptrdiff_t difference_type;
+
+public:
+
+    /// Default Constructor, usually used to create an end iterator.
+    scanline_read_iterator()
+    : _pos( -1 )
+    , _reader( NULL )
+    , _buffer( NULL )
+    {}
+
+    /// Constructor with preallocated image. Reading starts at first scanline of source image.
+    scanline_read_iterator( Reader& reader
+                          , byte_t* buffer
+                          )
+    : _pos( 0 )
+    , _reader( &reader )
+    , _buffer( buffer  )
+    {
+        init();
+    }
+
+    /// Constructor with preallocated image. Reading starts at first scanline of source image.
+    scanline_read_iterator( Reader& reader )
+    : _pos( 0 )
+    , _reader( &reader )
+    , _buffer( NULL )
+    {
+        init();
+    }
+
+    /// Constructor with preallocated image. Reading starts at pos scanline of source image.
+    scanline_read_iterator( std::size_t pos
+                          , Reader&     reader
+                          , byte_t*     buffer
+                          )
+    : _pos( pos )
+    , _reader( &reader )
+    , _buffer( buffer  )
+    {
+        init();
+
+        if( _pos >= _reader->_info._height )
+        {
+            throw std::runtime_error( "Trying to read past image." );
+        }
+
+        if( pos > 0 && _buffer == NULL )
+        {
+            throw std::runtime_error( "Cannot proceed without initializing read buffer." );
+        }
+
+        for( std::size_t i = 0; i < pos; ++i )
+        {
+            _skip();
+        }
+    }
+
+    //
+    // Destructor
+    //
+    ~scanline_read_iterator()
+    {
+        if( _reader )
+        {
+            _reader->clean_up();
+        }
+    }
+
+    /// Set reader. Do clean up before if necessary.
+    void set_reader( Reader& reader )
+    {
+        if( _reader )
+        {
+            _reader->clean_up();
+
+            _pos = 0;
+        }
+
+        _reader = &reader;
+
+        init();
+    }
+
+    /// Set reader. Do clean up before if necessary.
+    void set_buffer( byte_t* buffer )
+    {
+        _buffer = buffer;
+    }
+
+
+    /// Dereference Operator
+    reference operator*()
+    {
+        if( _reader && _buffer )
+        {
+            _reader->read( _buffer, _pos );
+
+            increase_pos();
+
+            return _buffer;
+        }
+
+        throw std::runtime_error( "Reader cannot be null for this operation." );
+    }
+
+    /// Pointer-To-Memper Operator.
+    pointer operator->() const
+    {
+        return &(operator*());
+    }
+
+    /// Pre-Increment Operator
+    scanline_read_iterator< Reader >& operator++()
+    {
+        if( _buffer == NULL )
+        {
+            throw std::runtime_error( "Cannot proceed without initializing read buffer." );
+        }
+
+        _skip();
+
+        return (*this);
+    }
+
+    /// Compare passed iterator to this.
+    bool equal( const scanline_read_iterator< Reader >& rhs ) const
+    {
+        return (_reader == rhs._reader) && ( _buffer == rhs._buffer );
+    }
+
+    bool operator ==( const scanline_read_iterator< Reader >& rhs ) const
+    {
+        return _pos == rhs._pos;
+    }
+
+    bool operator !=( const scanline_read_iterator< Reader >& rhs ) const
+    {
+        return _pos != rhs._pos;
+    }
+
+    /// Return backend.
+    const backend_t& backend()
+    {
+        if( _reader )
+        {
+            return *_reader;
+        }
+
+        throw std::runtime_error( "Reader cannot be null for this operation." );
+    }
+
+private:
+
+    void init()
+    {
+        // this needs to be done by the scanline_reader. Otherwise the user wont know the scanline length.
+        //if( _reader )
+        //{
+        //    _reader->initialize();
+        //}
+    }
+
+    void _skip()
+    {
+        if( _reader )
+        {
+            _reader->skip( _buffer, _pos );
+
+            increase_pos();
+        }
+    }
+
+    void increase_pos()
+    {
+        if( _pos < static_cast< int >( this->_reader->_info._height ) - 1 )
+        {
+            ++_pos;
+        }
+        else
+        {
+            _pos = -1;
+        }
+    }
+
+private:
+
+    mutable int _pos;
+
+    Reader* _reader;
+    byte_t* _buffer;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_IMAGE_READ_ITERATOR_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/io.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/io.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,106 @@
+/*
+    Copyright 2007-2008 Christian Henning, Andreas Pokorny
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_IO_HPP
+#define BOOST_GIL_EXTENSION_IO_IO_HPP 
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+/*! 
+ * \page iobackend Adding a new io backend
+ * \section Overview of backend requirements
+ * To add support for a new IO backend the following is required:
+ *  - a format tag, to identify the image format, derived from boost::gil::format_tag
+ *  - boolean meta function is_supported<PixelType,FormatTag> must be implemented for 
+ *    the new format tag
+ *  - explicit specialisation of image_read_info<FormatTag> must be provided, containing
+ *    runtime information available before/at reading the image
+ *  - explicit specialisation of image_write_info<FormatTag> must be provided, containing 
+ *    runtime encoding parameters for writing an image 
+ *  - An image reader must be specialized:
+ *    \code
+ *      template<typename IODevice, typename ConversionPolicy>
+ *      struct boost::gil::reader<IODevice,FormatTag,ConversionPolicy>
+ *      {
+ *        reader( IODevice & device )
+ *        reader( IODevice & device, typename ConversionPolicy::color_converter_type const& cc )
+ *        image_read_info<FormatTag> get_info(); 
+ *        template<typename Image>
+ *        void read_image( Image &, point_t const& top_left );
+ *        template<typename View>
+ *        void read_view( View &, point_t const& top_left );
+ *      };
+ *    \endcode
+ *  - An image writer must be specialized:
+ *    \code
+ *      \template <typename IODevice>
+ *      struct boost::gil::writer<IODevice,FormatTag>
+ *      {
+ *        writer( IODevice & device )
+ *        template<typename View>
+ *        void apply( View const&, point_t const& top_left );
+ *        template<typename View>
+ *        void apply( View const&, point_t const& top_left, image_write_info<FormatTag> const& );
+ *      };
+ *    \endcode
+ *
+ * Or instead of the items above implement overloads of read_view, read_and_convert_view, read_image, 
+ * read_and_convert_image, write_view and read_image_info.
+ *
+ * \section ConversionPolicy Interface of the ConversionPolicy 
+ * There are two different conversion policies in use, when reading images:
+ * read_and_convert<ColorConverter> and read_and_no_convert. ColorConverter 
+ * can be a user defined color converter. 
+ *  
+ * \code 
+ * struct ConversionPolicy
+ * {
+ *    template<typename InputIterator,typename OutputIterator>
+ *    void read( InputIterator in_begin, InputIterator in_end, 
+ *          OutputIterator out_end );
+ * };
+ * \endcode
+ *
+ * Methods like read_view and read_image are supposed to bail out with an 
+ * exception instead of converting the image 
+ *
+ * \section IODevice Concept of IO Device
+ * A Device is simply an object used to read and write data to and from a stream. 
+ * The IODevice was added as a template paramter to be able to replace the file_name
+ * access functionality. This is only an interim solution, as soon as boost provides
+ * a good IO library, interfaces/constraints provided by that library could be used.
+ *
+ * \code
+ *  concept IODevice
+ *  {
+ *      void IODevice::read( unsigned char* data, int count );
+ *      void IODevice::write( unsigned char* data, int count );
+ *      void IODevice::seek(long count, int whence);
+ *      void IODevice::flush();
+ *  };
+ * \endcode
+ *
+ * For the time being a boolean meta function must be specialized:
+ * \code 
+ * namespace boost{namespace gil{namespace detail{
+ *  template<typename Device> 
+ *  struct detail::is_input_device; 
+ * }}}
+ * \endcode
+ * 
+ */
+
+#endif // BOOST_GIL_EXTENSION_IO_IO_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/io_device.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/io_device.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,736 @@
+/*
+    Copyright 2007-2012 Andreas Pokorny, Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_IO_DEVICE_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_IO_DEVICE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Andreas Pokorny, Christian Henning \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <cstdio>
+
+#include <boost/shared_ptr.hpp>
+
+#include <boost/utility/enable_if.hpp>
+#include "base.hpp"
+
+namespace boost { namespace gil { namespace detail {
+
+template < typename T > struct buff_item
+{
+    static const unsigned int size = sizeof( T );
+};
+
+template <> struct buff_item< void >
+{
+    static const unsigned int size = 1;
+};
+
+
+/*!
+ * Implements the IODevice concept c.f. to \ref IODevice required by Image libraries like
+ * libjpeg and libpng.
+ *
+ * \todo switch to a sane interface as soon as there is
+ * something good in boost. I.E. the IOChains library
+ * would fit very well here.
+ *
+ * This implementation is based on FILE*.
+ */
+template< typename FormatTag >
+class file_stream_device
+{
+public:
+
+   typedef FormatTag format_tag_t;
+
+public:
+
+    /// Used to overload the constructor.
+    struct read_tag {};
+    struct write_tag {};
+
+    ///
+    /// Constructor
+    ///
+    file_stream_device( const std::string& file_name
+                      , read_tag   = read_tag()
+                      )
+    {
+        FILE* file = NULL;
+
+        io_error_if( ( file = fopen( file_name.c_str(), "rb" )) == NULL
+                   , "file_stream_device: failed to open file"
+                   );
+
+        _file = file_ptr_t( file
+                          , file_deleter
+                          );
+    }
+
+    ///
+    /// Constructor
+    ///
+    file_stream_device( const char* file_name
+                      , read_tag   = read_tag()
+                      )
+    {
+        FILE* file = NULL;
+
+        io_error_if( ( file = fopen( file_name, "rb" )) == NULL
+                   , "file_stream_device: failed to open file"
+                   );
+
+        _file = file_ptr_t( file
+                          , file_deleter
+                          );
+    }
+
+    ///
+    /// Constructor
+    ///
+    file_stream_device( const std::string& file_name
+                      , write_tag
+                      )
+    {
+        FILE* file = NULL;
+
+        io_error_if( ( file = fopen( file_name.c_str(), "wb" )) == NULL
+                   , "file_stream_device: failed to open file"
+                   );
+
+        _file = file_ptr_t( file
+                          , file_deleter
+                          );
+    }
+
+    ///
+    /// Constructor
+    ///
+    file_stream_device( const char* file_name
+                      , write_tag
+                      )
+    {
+        FILE* file = NULL;
+
+        io_error_if( ( file = fopen( file_name, "wb" )) == NULL
+                   , "file_stream_device: failed to open file"
+                   );
+
+        _file = file_ptr_t( file
+                          , file_deleter
+                          );
+    }
+
+    ///
+    /// Constructor
+    ///
+    file_stream_device( FILE* file )
+    : _file( file
+           , file_deleter
+           )
+    {}
+
+    FILE*       get()       { return _file.get(); }
+    const FILE* get() const { return _file.get(); }
+
+    int getc_unchecked()
+    {
+        return std::getc( get() );
+    }
+
+    char getc()
+    {
+        int ch;
+
+        if(( ch = std::getc( get() )) == EOF )
+            io_error( "file_stream_device: unexpected EOF" );
+
+        return ( char ) ch;
+    }
+
+    std::size_t read( byte_t*     data
+                    , std::size_t count
+                    )
+    {
+        std::size_t num_elements = fread( data
+                                        , 1
+                                        , static_cast<int>( count )
+                                        , get()
+                                        );
+
+        if(ferror( get() ))
+        {
+            assert( false );
+        }
+
+        //libjpeg sometimes reads blocks in 4096 bytes even when the file is smaller than that.
+        //assert( num_elements == count );
+        assert( num_elements > 0 );
+
+        return num_elements;
+    }
+
+    /// Reads array
+    template< typename T
+            , int      N
+            >
+    size_t read( T (&buf)[N] )
+    {
+	    return read( buf, N );
+    }
+
+    /// Reads byte
+    uint8_t read_uint8() throw()
+    {
+        byte_t m[1];
+
+        read( m );
+        return m[0];
+    }
+
+    /// Reads 16 bit little endian integer
+    uint16_t read_uint16() throw()
+    {
+        byte_t m[2];
+
+        read( m );
+        return (m[1] << 8) | m[0];
+    }
+
+    /// Reads 32 bit little endian integer
+    uint32_t read_uint32() throw()
+    {
+        byte_t m[4];
+
+        read( m );
+        return (m[3] << 24) | (m[2] << 16) | (m[1] << 8) | m[0];
+    }
+
+    /// Writes number of elements from a buffer
+    template < typename T >
+    size_t write( const T*    buf
+                , std::size_t count
+                )
+    throw()
+    {
+        std::size_t num_elements = fwrite( buf
+                                         , buff_item<T>::size
+                                         , count
+                                         , get()
+                                         );
+
+        assert( num_elements == count );
+
+        return num_elements;
+    }
+
+    /// Writes array
+    template < typename T
+             , size_t   N
+             >
+    size_t write( const T (&buf)[N] ) throw()
+    {
+        return write( buf, N );
+    }
+
+    /// Writes byte
+    void write_uint8( uint8_t x ) throw()
+    {
+	    byte_t m[1] = { x };
+	    write(m);
+    }
+
+    /// Writes 16 bit little endian integer
+    void write_uint16( uint16_t x ) throw()
+    {
+	    byte_t m[2];
+
+	    m[0] = byte_t( x >> 0 );
+	    m[1] = byte_t( x >> 8 );
+
+	    write( m );
+    }
+
+    /// Writes 32 bit little endian integer
+    void write_uint32( uint32_t x ) throw()
+    {
+	    byte_t m[4];
+
+	    m[0] = byte_t( x >>  0 );
+	    m[1] = byte_t( x >>  8 );
+	    m[2] = byte_t( x >> 16 );
+	    m[3] = byte_t( x >> 24 );
+
+	    write( m );
+    }
+
+    void seek( long count, int whence = SEEK_SET )
+    {
+        io_error_if( fseek( get()
+                          , count
+                          , whence
+                          ) != 0
+                   , "file read error"
+                   );
+    }
+
+    long int tell()
+    {
+        long int pos = ftell( get() );
+
+        io_error_if( pos == -1L
+                   , "file read error"
+                   );
+
+        return pos;
+    } 
+
+    void flush()
+    {
+        fflush( get() );
+    }
+
+    /// Prints formatted ASCII text
+    void print_line( const std::string& line )
+    {
+        std::size_t num_elements = fwrite( line.c_str()
+                                         , sizeof( char )
+                                         , line.size()
+                                         , get()
+                                         );
+
+        assert( num_elements == line.size() );
+    }
+
+    int error()
+    {
+        return ferror( get() );
+    }
+
+private:
+
+    static void file_deleter( FILE* file )
+    {
+        if( file )
+        {
+            fclose( file );
+        }
+    }    
+
+private:
+
+    typedef boost::shared_ptr< FILE > file_ptr_t;
+    file_ptr_t _file;
+};
+
+
+/**
+ * Input stream device
+ */
+template< typename FormatTag >
+class istream_device
+{
+public:
+   istream_device( std::istream& in )
+   : _in( in ) {}
+
+    int getc_unchecked()
+    {
+        return _in.get();
+    }
+
+    char getc()
+    {
+        int ch;
+
+        if(( ch = _in.get() ) == EOF )
+            io_error( "file_stream_device: unexpected EOF" );
+
+        return ( char ) ch;
+    }
+
+    std::size_t read( byte_t*     data
+                    , std::size_t count )
+    {
+        std::streamsize cr = 0;
+
+        do
+        {
+            _in.peek();
+            std::streamsize c = _in.readsome( reinterpret_cast< char* >( data )
+                                            , static_cast< std::streamsize >( count ));
+
+            count -= static_cast< std::size_t >( c );
+            data += c;
+            cr += c;
+
+        } while( count && _in );
+
+        return static_cast< std::size_t >( cr );
+    }
+
+    /// Reads array
+    template< typename T
+            , int      N
+            >
+    size_t read( T (&buf)[N] )
+    {
+	    return read( buf, N );
+    }
+
+    /// Reads byte
+    uint8_t read_uint8() throw()
+    {
+        byte_t m[1];
+
+        read( m );
+        return m[0];
+    }
+
+    /// Reads 16 bit little endian integer
+    uint16_t read_uint16() throw()
+    {
+        byte_t m[2];
+
+        read( m );
+        return (m[1] << 8) | m[0];
+    }
+
+    /// Reads 32 bit little endian integer
+    uint32_t read_uint32() throw()
+    {
+        byte_t m[4];
+
+        read( m );
+        return (m[3] << 24) | (m[2] << 16) | (m[1] << 8) | m[0];
+    }
+
+    void seek( long count, int whence = SEEK_SET )
+    {
+        _in.seekg( count
+                 , whence == SEEK_SET ? std::ios::beg
+                                      :( whence == SEEK_CUR ? std::ios::cur
+                                                            : std::ios::end )
+                 );
+    }
+
+    void write( const byte_t* data
+              , std::size_t   count )
+    {
+        io_error( "Bad io error." );
+    }
+
+    void flush() {}
+
+private:
+
+    std::istream& _in;
+};
+
+/**
+ * Output stream device
+ */
+template< typename FormatTag >
+class ostream_device
+{
+public:
+    ostream_device( std::ostream & out )
+        : _out( out )
+    {
+    }
+
+    size_t read( byte_t*     data
+               , std::size_t count )
+    {
+        io_error( "Bad io error." );
+
+        return 0;
+    }
+
+    void seek( long count, int whence )
+    {
+        _out.seekp( count
+                  , whence == SEEK_SET
+                    ? std::ios::beg
+                    : ( whence == SEEK_CUR
+                        ?std::ios::cur
+                        :std::ios::end )
+                  );
+    }
+
+    void write( const byte_t* data
+              , std::size_t   count )
+    {
+        _out.write( reinterpret_cast<char const*>( data )
+                 , static_cast<std::streamsize>( count )
+                 );
+    }
+
+    /// Writes array
+    template < typename T
+             , size_t   N
+             >
+    void write( const T (&buf)[N] ) throw()
+    {
+        write( buf, N );
+    }
+
+    /// Writes byte
+    void write_uint8( uint8_t x ) throw()
+    {
+	    byte_t m[1] = { x };
+	    write(m);
+    }
+
+    /// Writes 16 bit little endian integer
+    void write_uint16( uint16_t x ) throw()
+    {
+	    byte_t m[2];
+
+	    m[0] = byte_t( x >> 0 );
+	    m[1] = byte_t( x >> 8 );
+
+	    write( m );
+    }
+
+    /// Writes 32 bit little endian integer
+    void write_uint32( uint32_t x ) throw()
+    {
+	    byte_t m[4];
+
+	    m[0] = byte_t( x >>  0 );
+	    m[1] = byte_t( x >>  8 );
+	    m[2] = byte_t( x >> 16 );
+	    m[3] = byte_t( x >> 24 );
+
+	    write( m );
+    }
+
+    void flush()
+    {
+        _out << std::flush;
+    }
+
+    /// Prints formatted ASCII text
+    void print_line( const std::string& line )
+    {
+        _out << line;
+    }
+
+
+
+private:
+
+    std::ostream& _out;
+};
+
+
+/**
+ * Metafunction to detect input devices.
+ * Should be replaced by an external facility in the future.
+ */
+template< typename IODevice  > struct is_input_device : mpl::false_{};
+template< typename FormatTag > struct is_input_device< file_stream_device< FormatTag > > : mpl::true_{};
+template< typename FormatTag > struct is_input_device<     istream_device< FormatTag > > : mpl::true_{};
+
+template< typename FormatTag
+        , typename T
+        , typename D = void
+        >
+struct is_adaptable_input_device : mpl::false_{};
+
+template< typename FormatTag
+        , typename T
+        >
+struct is_adaptable_input_device< FormatTag
+                                , T
+                                , typename enable_if< mpl::or_< is_base_and_derived< std::istream, T >
+                                                              , is_same            < std::istream, T >
+                                                              >
+                                                    >::type
+                                > : mpl::true_
+{
+    typedef istream_device< FormatTag > device_type;
+};
+
+template< typename FormatTag >
+struct is_adaptable_input_device< FormatTag
+                                , FILE*
+                                , void
+                                >
+    : mpl::true_
+{
+    typedef file_stream_device< FormatTag > device_type;
+};
+
+///
+/// Metafunction to decide if a given type is an acceptable read device type.
+///
+template< typename FormatTag
+        , typename T
+        , typename D = void
+        >
+struct is_read_device : mpl::false_
+{};
+
+template< typename FormatTag
+        , typename T
+        >
+struct is_read_device< FormatTag
+                     , T
+                     , typename enable_if< mpl::or_< is_input_device< FormatTag >
+                                                   , is_adaptable_input_device< FormatTag
+                                                                              , T
+                                                                              >
+                                                   >
+                                         >::type
+                     > : mpl::true_
+{};
+
+
+/**
+ * Metafunction to detect output devices.
+ * Should be replaced by an external facility in the future.
+ */
+template<typename IODevice> struct is_output_device : mpl::false_{};
+
+template< typename FormatTag > struct is_output_device< file_stream_device< FormatTag > > : mpl::true_{};
+template< typename FormatTag > struct is_output_device< ostream_device    < FormatTag > > : mpl::true_{};
+
+template< typename FormatTag
+        , typename IODevice
+        , typename D = void
+        >
+struct is_adaptable_output_device : mpl::false_ {};
+
+template< typename FormatTag
+        , typename T
+        > struct is_adaptable_output_device< FormatTag
+                                           , T
+                                           , typename enable_if< mpl::or_< is_base_and_derived< std::ostream, T >
+                                                                         , is_same            < std::ostream, T >
+                                                                         >
+                                           >::type
+        > : mpl::true_
+{
+    typedef ostream_device< FormatTag > device_type;
+};
+
+template<typename FormatTag> struct is_adaptable_output_device<FormatTag,FILE*,void>
+  : mpl::true_
+{
+    typedef file_stream_device< FormatTag > device_type;
+};
+
+
+///
+/// Metafunction to decide if a given type is an acceptable read device type.
+///
+template< typename FormatTag
+        , typename T
+        , typename D = void
+        >
+struct is_write_device : mpl::false_
+{};
+
+template< typename FormatTag
+        , typename T
+        >
+struct is_write_device< FormatTag
+                      , T
+                      , typename enable_if< mpl::or_< is_output_device< FormatTag >
+                                                    , is_adaptable_output_device< FormatTag
+                                                                                , T
+                                                                                >
+                                                    >
+                                          >::type
+                      > : mpl::true_
+{};
+
+} // namespace detail
+
+template< typename Device, typename FormatTag > class scanline_reader;
+template< typename Device, typename FormatTag, typename ConversionPolicy > class reader;
+
+template< typename Device, typename FormatTag, typename Log = no_log > class writer;
+
+template< typename Device, typename FormatTag > class dynamic_image_reader;
+template< typename Device, typename FormatTag, typename Log = no_log > class dynamic_image_writer;
+
+
+namespace detail {
+
+template< typename T >
+struct is_reader : mpl::false_
+{};
+
+template< typename Device
+        , typename FormatTag
+        , typename ConversionPolicy
+        >
+struct is_reader< reader< Device
+                        , FormatTag
+                        , ConversionPolicy
+                        >
+                > : mpl::true_
+{};
+
+template< typename T >
+struct is_dynamic_image_reader : mpl::false_
+{};
+
+template< typename Device
+        , typename FormatTag
+        >
+struct is_dynamic_image_reader< dynamic_image_reader< Device
+                                                    , FormatTag
+                                                    >
+                              > : mpl::true_
+{};
+
+template< typename T >
+struct is_writer : mpl::false_
+{};
+
+template< typename Device
+        , typename FormatTag
+        >
+struct is_writer< writer< Device
+                        , FormatTag
+                        >
+                > : mpl::true_
+{};
+
+template< typename T >
+struct is_dynamic_image_writer : mpl::false_
+{};
+
+template< typename Device
+        , typename FormatTag
+        >
+struct is_dynamic_image_writer< dynamic_image_writer< Device
+                                                    , FormatTag
+                                                    >
+                > : mpl::true_
+{};
+
+} // namespace detail
+
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_IO_DEVICE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/io_error.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/io_error.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,40 @@
+/*
+    Copyright 2007-2008 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_IO_ERROR_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_IO_ERROR_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date   2010 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost { namespace gil {
+
+inline 
+void io_error( const char* descr )
+{
+   throw std::ios_base::failure( descr );
+}
+
+inline 
+void io_error_if( bool expr, const char* descr )
+{
+   if( expr ) 
+      io_error( descr );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_IO_ERROR_HPP
\ No newline at end of file
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/make_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/make_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,163 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_MAKE_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_MAKE_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/utility/enable_if.hpp>
+
+#include "get_reader.hpp"
+
+namespace boost { namespace gil {
+
+template< typename String
+        , typename FormatTag
+        >
+inline
+typename get_reader_backend< String
+                           , FormatTag
+                           >::type
+make_reader_backend( const String&                           file_name
+                   , const image_read_settings< FormatTag >& settings
+                   , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                  , is_format_tag< FormatTag >
+                                                           >
+                                       >::type* /* ptr */ = 0
+                   )
+{
+    typedef typename get_read_device< String
+                                    , FormatTag
+                                    >::type device_t;
+
+    device_t device( detail::convert_to_native_string( file_name )
+                   , typename detail::file_stream_device< FormatTag >::read_tag()
+                   );
+
+    return reader_backend< device_t, FormatTag >( device, settings );
+}
+
+template< typename FormatTag >
+inline
+typename get_reader_backend< std::wstring
+                           , FormatTag
+                           >::type
+make_reader_backend( const std::wstring&                     file_name
+                   , const image_read_settings< FormatTag >& settings
+                   )
+{
+    typedef typename get_read_device< std::wstring
+                                    , FormatTag
+                                    >::type device_t;
+                   
+    const char* str = detail::convert_to_native_string( file_name );
+
+    device_t device( str
+                   , typename detail::file_stream_device< FormatTag >::read_tag()
+                   );
+
+    delete[] str;
+
+    return reader_backend< device_t, FormatTag >( device, settings );
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+template< typename FormatTag >
+inline
+typename get_reader_backend< std::wstring
+                           , FormatTag
+                           >::type
+make_reader_backend( const filesystem::path&                 path
+                   , const image_read_settings< FormatTag >& settings
+                   )
+{
+    return make_reader_backend( path.wstring()
+                              , settings
+                              );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+template< typename Device
+        , typename FormatTag
+        >
+inline
+typename get_reader_backend< Device
+                           , FormatTag
+                           >::type
+make_reader_backend( Device&                                 io_dev
+                   , const image_read_settings< FormatTag >& settings
+                   , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                                     , Device
+                                                                                     >
+                                                  , is_format_tag< FormatTag >
+                                                  >
+                                       >::type* /* ptr */ = 0
+                   )
+{
+    typedef typename get_read_device< Device
+                                    , FormatTag
+                                    >::type device_t;
+
+    device_t device( io_dev );
+
+    return reader_backend< device_t, FormatTag >( device, settings );
+}
+
+
+
+template< typename String
+        , typename FormatTag
+        >
+inline
+typename get_reader_backend< String
+                           , FormatTag
+                           >::type
+make_reader_backend( const String&    file_name
+                   , const FormatTag&
+                   , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                  , is_format_tag< FormatTag >
+                                                           >
+                                       >::type* /* ptr */ = 0
+                   )
+{
+    return make_reader_backend( file_name, image_read_settings< FormatTag >() );
+}
+
+template< typename Device
+        , typename FormatTag
+        >
+inline
+typename get_reader_backend< Device
+                           , FormatTag
+                           >::type
+make_reader_backend( Device&          io_dev
+                   , const FormatTag& tag
+                   , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                                     , Device
+                                                                                     >
+                                                  , is_format_tag< FormatTag >
+                                                  >
+                                       >::type* /* ptr */ = 0
+                   )
+{
+    return make_reader_backend( io_dev, image_read_settings< FormatTag >() );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_MAKE_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/make_dynamic_image_reader.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/make_dynamic_image_reader.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,203 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_MAKE_DYNAMIC_IMAGE_READER_HPP
+#define BOOST_GIL_EXTENSION_IO_MAKE_DYNAMIC_IMAGE_READER_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/utility/enable_if.hpp>
+
+#include "get_reader.hpp"
+
+namespace boost { namespace gil {
+
+template< typename String
+        , typename FormatTag
+        >
+inline
+typename get_dynamic_image_reader< String
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_reader( const String&    file_name
+                         , const image_read_settings< FormatTag >& settings
+                         , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                        , is_format_tag< FormatTag >
+                                                                 >
+                                             >::type* /* ptr */ = 0
+                         )
+{
+    typename get_read_device< String
+                   , FormatTag
+                   >::type device( detail::convert_to_native_string( file_name )
+                                 , typename detail::file_stream_device< FormatTag >::read_tag()
+                                 );
+
+    return typename get_dynamic_image_reader< String
+                                            , FormatTag
+                                            >::type( device
+                                                   , settings
+                                                   );
+}
+
+template< typename FormatTag >
+inline
+typename get_dynamic_image_reader< std::wstring
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_reader( const std::wstring& file_name
+                         , const image_read_settings< FormatTag >& settings
+                         )
+{
+    const char* str = detail::convert_to_native_string( file_name );
+
+    typename get_read_device< std::wstring
+                   , FormatTag
+                   >::type device( str
+                                 , typename detail::file_stream_device< FormatTag >::read_tag()
+                                 );
+
+    delete[] str;
+
+    return typename get_dynamic_image_reader< std::wstring
+                                            , FormatTag
+                                            >::type( device
+                                                   , settings
+                                                   );
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+template< typename FormatTag >
+inline
+typename get_dynamic_image_reader< std::wstring
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_reader( const filesystem::path&                 path
+                         , const image_read_settings< FormatTag >& settings
+                         )
+{
+    return make_dynamic_image_reader( path.wstring()
+                                    , settings
+                                    );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+template< typename Device
+        , typename FormatTag
+        >
+inline
+typename get_dynamic_image_reader< Device
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_reader( Device&          file
+                         , const image_read_settings< FormatTag >& settings
+                         , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                                           , Device
+                                                                                           >
+                                                        , is_format_tag< FormatTag >
+                                                        >
+                                             >::type* /* ptr */ = 0
+                         )
+{
+    typename get_read_device< Device
+                   , FormatTag
+                   >::type device( file );
+
+    return typename get_dynamic_image_reader< Device
+                                            , FormatTag
+                                            >::type( device
+                                                   , settings
+                                                   );
+}
+
+// without image_read_settings
+
+template< typename String
+        , typename FormatTag
+        >
+inline
+typename get_dynamic_image_reader< String
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_reader( const String&    file_name
+                         , const FormatTag&
+                         , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                        , is_format_tag< FormatTag >
+                                                                 >
+                                             >::type* /* ptr */ = 0
+                         )
+{
+    return make_dynamic_image_reader( file_name
+                                    , image_read_settings< FormatTag >()
+                                    );
+}
+
+template< typename FormatTag >
+inline
+typename get_dynamic_image_reader< std::wstring
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_reader( const std::wstring& file_name
+                         , const FormatTag&
+                         )
+{
+    return make_dynamic_image_reader( file_name
+                                    , image_read_settings< FormatTag >()
+                                    );
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+template< typename FormatTag >
+inline
+typename get_dynamic_image_reader< std::wstring
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_reader( const filesystem::path& path
+                         , const FormatTag&
+                         )
+{
+    return make_dynamic_image_reader( path.wstring()
+                                    , image_read_settings< FormatTag >()
+                                    );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+template< typename Device
+        , typename FormatTag
+        >
+inline
+typename get_dynamic_image_reader< Device
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_reader( Device&          file
+                         , const FormatTag&
+                         , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                                           , Device
+                                                                                           >
+                                                        , is_format_tag< FormatTag >
+                                                        >
+                                             >::type* /* ptr */ = 0
+                         )
+{
+    return make_dynamic_image_reader( file
+                                    , image_read_settings< FormatTag >()
+                                    );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_MAKE_DYNAMIC_IMAGE_READER_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/make_dynamic_image_writer.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/make_dynamic_image_writer.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,202 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_MAKE_DYNAMIC_IMAGE_WRITER_HPP
+#define BOOST_GIL_EXTENSION_IO_MAKE_DYNAMIC_IMAGE_WRITER_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/utility/enable_if.hpp>
+
+#include "get_writer.hpp"
+
+namespace boost { namespace gil {
+
+template< typename String
+        , typename FormatTag
+        >
+inline
+typename get_dynamic_image_writer< String
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_writer( const String&                        file_name
+                         , const image_write_info< FormatTag >& info
+                         , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                        , is_format_tag< FormatTag >
+                                                        >
+                                             >::type* /* ptr */ = 0
+                         )
+{
+    typename get_write_device< String
+                    , FormatTag
+                    >::type device( detail::convert_to_native_string( file_name )
+                                  , typename detail::file_stream_device< FormatTag >::write_tag()
+                                  );
+
+    return typename get_dynamic_image_writer< String
+                                            , FormatTag
+                                            >::type( device
+                                                   , info
+                                                   );
+}
+
+template< typename FormatTag >
+inline
+typename get_dynamic_image_writer< std::wstring
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_writer( const std::wstring&                  file_name
+                         , const image_write_info< FormatTag >& info
+                         )
+{
+    const char* str = detail::convert_to_native_string( file_name );
+
+    typename get_write_device< std::wstring
+                    , FormatTag
+                    >::type device( str
+                                  , typename detail::file_stream_device< FormatTag >::write_tag()
+                                  );
+
+    delete[] str;
+
+    return typename get_dynamic_image_writer< std::wstring
+                                            , FormatTag
+                                            >::type( device
+                                                   , info
+                                                   );
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+template< typename FormatTag >
+inline
+typename get_dynamic_image_writer< std::wstring
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_writer( const filesystem::path&              path
+                         , const image_write_info< FormatTag >& info
+                         )
+{
+    return make_dynamic_image_writer( path.wstring()
+                                    , info
+                                    );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+
+template< typename Device
+        , typename FormatTag
+        >
+inline
+typename get_dynamic_image_writer< Device
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_writer( Device&                              file
+                         , const image_write_info< FormatTag >& info
+                         , typename enable_if< mpl::and_< typename detail::is_adaptable_output_device< FormatTag, Device >::type
+                                                        , is_format_tag< FormatTag >
+                                                        >
+                                             >::type* /* ptr */ = 0
+                         )
+{
+    typename get_write_device< Device
+                    , FormatTag
+                    >::type device( file );
+
+    return typename get_dynamic_image_writer< Device
+                                            , FormatTag
+                                            >::type( device
+                                                   , info
+                                                   );
+}
+
+
+// no image_write_info
+
+template< typename String
+        , typename FormatTag
+        >
+inline
+typename get_dynamic_image_writer< String
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_writer( const String&    file_name
+                         , const FormatTag&
+                         , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                        , is_format_tag< FormatTag >
+                                                        >
+                                             >::type* /* ptr */ = 0
+                         )
+{
+    return make_dynamic_image_writer( file_name
+                                    , image_write_info< FormatTag >()
+                                    );
+}
+
+template< typename FormatTag >
+inline
+typename get_dynamic_image_writer< std::wstring
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_writer( const std::wstring& file_name
+                         , const FormatTag&
+                         )
+{
+    return make_dynamic_image_writer( file_name
+                                    , image_write_info< FormatTag >()
+                                    );
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+template< typename FormatTag >
+inline
+typename get_dynamic_image_writer< std::wstring
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_writer( const filesystem::path& path
+                         , const FormatTag&        tag
+                         )
+{
+    return make_dynamic_image_writer( path.wstring()
+                                    , image_write_info< FormatTag >()
+                                    );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+
+template< typename Device
+        , typename FormatTag
+        >
+inline
+typename get_dynamic_image_writer< Device
+                                 , FormatTag
+                                 >::type
+make_dynamic_image_writer( Device&          file
+                         , const FormatTag&
+                         , typename enable_if< mpl::and_< typename detail::is_adaptable_output_device< FormatTag, Device >::type
+                                                        , is_format_tag< FormatTag >
+                                                        >
+                                             >::type* /* ptr */ = 0
+                         )
+{
+    return make_dynamic_image_writer( file
+                                    , image_write_info< FormatTag >()
+                                    );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_MAKE_DYNAMIC_IMAGE_WRITER_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/make_reader.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/make_reader.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,239 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_MAKE_READER_HPP
+#define BOOST_GIL_EXTENSION_IO_MAKE_READER_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/utility/enable_if.hpp>
+
+#include "get_reader.hpp"
+
+namespace boost { namespace gil {
+
+template< typename String
+        , typename FormatTag
+        , typename ConversionPolicy
+        >
+inline
+typename get_reader< String
+                   , FormatTag
+                   , ConversionPolicy
+                   >::type
+make_reader( const String&    file_name
+           , const image_read_settings< FormatTag >& settings
+           , const ConversionPolicy&
+           , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                          , is_format_tag< FormatTag >
+                                                   >
+                               >::type* /* ptr */ = 0
+           )
+{
+    typename get_read_device< String
+                            , FormatTag
+                            >::type device( detail::convert_to_native_string( file_name )
+                                          , typename detail::file_stream_device< FormatTag >::read_tag()
+                                          );
+
+    return typename get_reader< String
+                              , FormatTag
+                              , ConversionPolicy
+                              >::type( device
+                                     , settings
+                                     );
+}
+
+template< typename FormatTag
+        , typename ConversionPolicy
+        >
+inline
+typename get_reader< std::wstring
+                   , FormatTag
+                   , ConversionPolicy
+                   >::type
+make_reader( const std::wstring& file_name
+           , const image_read_settings< FormatTag >& settings
+           , const ConversionPolicy&
+           )
+{
+    const char* str = detail::convert_to_native_string( file_name );
+
+    typename get_read_device< std::wstring
+                            , FormatTag
+                            >::type device( str
+                                          , typename detail::file_stream_device< FormatTag >::read_tag()
+                                          );
+
+    delete[] str;
+
+    return typename get_reader< std::wstring
+                              , FormatTag
+                              , ConversionPolicy
+                              >::type( device
+                                     , settings
+                                     );
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+template< typename FormatTag
+        , typename ConversionPolicy
+        >
+inline
+typename get_reader< std::wstring
+                   , FormatTag
+                   , ConversionPolicy
+                   >::type
+make_reader( const filesystem::path&                 path
+           , const image_read_settings< FormatTag >& settings
+           , const ConversionPolicy&                 cc
+           )
+{
+    return make_reader( path.wstring()
+                      , settings
+                      , cc
+                      );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+template< typename Device
+        , typename FormatTag
+        , typename ConversionPolicy
+        >
+inline
+typename get_reader< Device
+                   , FormatTag
+                   , ConversionPolicy
+                   >::type
+make_reader( Device&                                 file
+           , const image_read_settings< FormatTag >& settings
+           , const ConversionPolicy&
+           , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                             , Device
+                                                                             >
+                                          , is_format_tag< FormatTag >
+                                          >
+                               >::type* /* ptr */ = 0
+           )
+{
+    typename get_read_device< Device
+                            , FormatTag
+                            >::type device( file );
+
+    return typename get_reader< Device
+                              , FormatTag
+                              , ConversionPolicy
+                              >::type( device
+                                     , settings
+                                     );
+}
+
+// no image_read_settings
+
+template< typename String
+        , typename FormatTag
+        , typename ConversionPolicy
+        >
+inline
+typename get_reader< String
+                   , FormatTag
+                   , ConversionPolicy
+                   >::type
+make_reader( const String&    file_name
+           , const FormatTag&
+           , const ConversionPolicy& cc
+           , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                          , is_format_tag< FormatTag >
+                                                   >
+                               >::type* /* ptr */ = 0
+           )
+{
+    return make_reader( file_name
+                      , image_read_settings< FormatTag >()
+                      , cc
+                      );
+}
+
+template< typename FormatTag
+        , typename ConversionPolicy
+        >
+inline
+typename get_reader< std::wstring
+                   , FormatTag
+                   , ConversionPolicy
+                   >::type
+make_reader( const std::wstring&     file_name
+           , const FormatTag&
+           , const ConversionPolicy& cc
+           )
+{
+    return make_reader( file_name
+                      , image_read_settings< FormatTag >()
+                      , cc
+                      );
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+template< typename FormatTag
+        , typename ConversionPolicy
+        >
+inline
+typename get_reader< std::wstring
+                   , FormatTag
+                   , ConversionPolicy
+                   >::type
+make_reader( const filesystem::path& path
+           , const FormatTag&
+           , const ConversionPolicy& cc
+           )
+{
+    return make_reader( path.wstring()
+                      , image_read_settings< FormatTag >()
+                      , cc
+                      );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+template< typename Device
+        , typename FormatTag
+        , typename ConversionPolicy
+        >
+inline
+typename get_reader< Device
+                   , FormatTag
+                   , ConversionPolicy
+                   >::type
+make_reader( Device&                 file
+           , const FormatTag&
+           , const ConversionPolicy& cc
+           , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                             , Device
+                                                                             >
+                                          , is_format_tag< FormatTag >
+                                          >
+                               >::type* /* ptr */ = 0
+           )
+{
+    return make_reader( file
+                      , image_read_settings< FormatTag >()
+                      , cc
+                      );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_MAKE_READER_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/make_scanline_reader.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/make_scanline_reader.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,121 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_MAKE_SCANLINE_READER_HPP
+#define BOOST_GIL_EXTENSION_IO_MAKE_SCANLINE_READER_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/utility/enable_if.hpp>
+
+#include "get_reader.hpp"
+
+namespace boost { namespace gil {
+
+template< typename String
+        , typename FormatTag
+        >
+inline
+typename get_scanline_reader< String
+                            , FormatTag
+                            >::type
+make_scanline_reader( const String&    file_name
+                    , const FormatTag&
+                    , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                                   , is_format_tag< FormatTag >
+                                                   >
+                                        >::type* /* ptr */ = 0
+           )
+{
+    typename get_read_device< String
+                            , FormatTag
+                            >::type device( detail::convert_to_native_string( file_name )
+                                          , typename detail::file_stream_device< FormatTag >::read_tag()
+                                          );
+
+    return typename get_scanline_reader< String
+                                       , FormatTag
+                                       >::type( device
+                                              , image_read_settings<FormatTag>()
+                                              );
+}
+
+template< typename FormatTag >
+inline
+typename get_scanline_reader< std::wstring
+                            , FormatTag
+                            >::type
+make_scanline_reader( const std::wstring& file_name
+                    , const FormatTag&
+                    )
+{
+    const char* str = detail::convert_to_native_string( file_name );
+
+    typename get_read_device< std::wstring
+                            , FormatTag
+                            >::type device( str
+                                          , typename detail::file_stream_device< FormatTag >::read_tag()
+                                          );
+
+    delete[] str;
+
+    return typename get_scanline_reader< std::wstring
+                                       , FormatTag
+                                       >::type( device
+                                              , image_read_settings< FormatTag >()
+                                              );
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+template< typename FormatTag >
+inline
+typename get_scanline_reader< std::wstring
+                            , FormatTag
+                            >::type
+make_scanline_reader( const filesystem::path& path
+                    , const FormatTag&
+                    )
+{
+    return make_scanline_reader( path.wstring()
+                               , image_read_settings< FormatTag >()
+                               );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+template< typename Device
+        , typename FormatTag
+        >
+inline
+typename get_scanline_reader< Device
+                            , FormatTag
+                            >::type
+make_scanline_reader( Device&          io_dev
+                    , const FormatTag&
+                    , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                                      , Device
+                                                                                      >
+                                                   , is_format_tag< FormatTag >
+                                                   >
+                                        >::type* /* ptr */ = 0
+                    )
+{
+    return make_scanline_reader( io_dev, image_read_settings< FormatTag >() );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_MAKE_SCANLINE_READER_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/make_writer.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/make_writer.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,202 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_MAKE_WRITER_HPP
+#define BOOST_GIL_EXTENSION_IO_MAKE_WRITER_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/utility/enable_if.hpp>
+
+#include "get_writer.hpp"
+
+namespace boost { namespace gil {
+
+template< typename String
+        , typename FormatTag
+        >
+inline
+typename get_writer< String
+                   , FormatTag
+                   >::type
+make_writer( const String&                        file_name
+           , const image_write_info< FormatTag >& info
+           , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                          , is_format_tag< FormatTag >
+                                          >
+                               >::type* /* ptr */ = 0
+           )
+{
+    typename get_write_device< String
+                    , FormatTag
+                    >::type device( detail::convert_to_native_string( file_name )
+                                  , typename detail::file_stream_device< FormatTag >::write_tag()
+                                  );
+
+    return typename get_writer< String
+                              , FormatTag
+                              >::type( device
+                                     , info
+                                     );
+}
+
+template< typename FormatTag >
+inline
+typename get_writer< std::wstring
+                   , FormatTag
+                   >::type
+make_writer( const std::wstring&                  file_name
+           , const image_write_info< FormatTag >& info
+           )
+{
+    const char* str = detail::convert_to_native_string( file_name );
+
+    typename get_write_device< std::wstring
+                    , FormatTag
+                    >::type device( str
+                                  , typename detail::file_stream_device< FormatTag >::write_tag()
+                                  );
+
+    delete[] str;
+
+    return get_writer< std::wstring
+                     , FormatTag
+                     >::type( device
+                            , info
+                            );
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+template< typename FormatTag >
+inline
+typename get_writer< std::wstring
+                   , FormatTag
+                   >::type
+make_writer( const filesystem::path&              path
+           , const image_write_info< FormatTag >& info
+           )
+{
+    return make_writer( path.wstring()
+                      , info
+                      );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+
+template< typename Device
+        , typename FormatTag
+        >
+inline
+typename get_writer< Device
+                   , FormatTag
+                   >::type
+make_writer( Device&                              file
+           , const image_write_info< FormatTag >& info
+           , typename enable_if< mpl::and_< typename detail::is_adaptable_output_device< FormatTag, Device >::type
+                                          , is_format_tag< FormatTag >
+                                          >
+                               >::type* /* ptr */ = 0
+           )
+{
+    typename get_write_device< Device
+                    , FormatTag
+                    >::type device( file );
+
+    return get_writer< Device
+                     , FormatTag
+                     >::type( device
+                            , info
+                            );
+}
+
+
+// no image_write_info
+
+template< typename String
+        , typename FormatTag
+        >
+inline
+typename get_writer< String
+                   , FormatTag
+                   >::type
+make_writer( const String&    file_name
+           , const FormatTag&
+           , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                          , is_format_tag< FormatTag >
+                                          >
+                               >::type* /* ptr */ = 0
+           )
+{
+    return make_writer( file_name
+                      , image_write_info< FormatTag >()
+                      );
+}
+
+template< typename FormatTag >
+inline
+typename get_writer< std::wstring
+                   , FormatTag
+                   >::type
+make_writer( const std::wstring& file_name
+           , const FormatTag&
+           )
+{
+    return make_writer( file_name
+                      , image_write_info< FormatTag >()
+                      );
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+template< typename FormatTag >
+inline
+typename get_writer< std::wstring
+                   , FormatTag
+                   >::type
+make_writer( const filesystem::path& path
+           , const FormatTag&        tag
+           )
+{
+    return make_writer( path.wstring()
+                      , tag
+                      );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+
+template< typename Device
+        , typename FormatTag
+        >
+inline
+typename get_writer< Device
+                   , FormatTag
+                   >::type
+make_writer( Device&          file
+           , const FormatTag&
+           , typename enable_if< mpl::and_< typename detail::is_adaptable_output_device< FormatTag, Device >::type
+                                          , is_format_tag< FormatTag >
+                                          >
+                               >::type* /* ptr */ = 0
+           )
+{
+    return make_writer( file
+                      , image_write_info< FormatTag >()
+                      );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_MAKE_WRITER_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/path_spec.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/path_spec.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,143 @@
+/*
+    Copyright 2007-2008 Andreas Pokorny, Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_PATH_SPEC_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_PATH_SPEC_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Andreas Pokorny, Christian Henning \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#if !defined(__APPLE__)
+#include <malloc.h>
+#endif
+
+#include <cstdlib>
+#include <string>
+
+#include <boost/mpl/bool_fwd.hpp>
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+#define BOOST_FILESYSTEM_VERSION 3
+#include <boost/filesystem/path.hpp>
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+namespace boost { namespace gil { namespace detail {
+
+template<typename P> struct is_supported_path_spec              : mpl::false_ {};
+template<> struct is_supported_path_spec< std::string >         : mpl::true_ {};
+template<> struct is_supported_path_spec< const std::string >   : mpl::true_ {};
+template<> struct is_supported_path_spec< std::wstring >        : mpl::true_ {};
+template<> struct is_supported_path_spec< const std::wstring >  : mpl::true_ {};
+template<> struct is_supported_path_spec< const char* >         : mpl::true_ {};
+template<> struct is_supported_path_spec< char* >               : mpl::true_ {};
+template<> struct is_supported_path_spec< const wchar_t* >      : mpl::true_ {};
+template<> struct is_supported_path_spec< wchar_t* >            : mpl::true_ {};
+
+template<int i> struct is_supported_path_spec<const char [i]>       : mpl::true_ {};
+template<int i> struct is_supported_path_spec<char [i]>             : mpl::true_ {};
+template<int i> struct is_supported_path_spec<const wchar_t [i]>    : mpl::true_ {};
+template<int i> struct is_supported_path_spec<wchar_t [i]>          : mpl::true_ {};
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+template<> struct is_supported_path_spec< filesystem::path > : mpl::true_ {};
+template<> struct is_supported_path_spec< const filesystem::path > : mpl::true_ {};
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+
+///
+/// convert_to_string
+///
+
+inline std::string convert_to_string( std::string const& obj)
+{
+   return obj;
+}
+
+inline std::string convert_to_string( std::wstring const& s )
+{
+	std::size_t len = wcslen( s.c_str() );
+	char* c = reinterpret_cast<char*>( alloca( len ));
+	wcstombs( c, s.c_str(), len );
+
+    return std::string( c, c + len );
+}
+
+inline std::string convert_to_string( const char* str )
+{
+    return std::string( str );
+}
+
+inline std::string convert_to_string( char* str )
+{
+    return std::string( str );
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+inline std::string convert_to_string( const filesystem::path& path )
+{
+    return convert_to_string( path.string() );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+///
+/// convert_to_native_string
+///
+
+inline const char* convert_to_native_string( char* str )
+{
+    return str;
+}
+
+inline const char* convert_to_native_string( const char* str )
+{
+    return str;
+}
+
+inline const char* convert_to_native_string( const std::string& str )
+{
+   return str.c_str();
+}
+
+inline const char* convert_to_native_string( const wchar_t* str )
+{
+    std::size_t len = wcslen( str ) + 1;
+    char* c = new char[len];
+    wcstombs( c, str, len );
+
+    return c;
+}
+
+inline const char* convert_to_native_string( const std::wstring& str )
+{
+    std::size_t len = wcslen( str.c_str() ) + 1;
+    char* c = new char[len];
+    wcstombs( c, str.c_str(), len );
+
+    return c;
+}
+
+#ifdef BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+inline const char* convert_to_native_string( const filesystem::path& path )
+{
+    ///@todo this leaks
+    return convert_to_native_string( path.wstring() );
+}
+#endif // BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_PATH_SPEC_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/read_and_convert_image.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/read_and_convert_image.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,355 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_READ_AND_CONVERT_IMAGE_HPP
+#define BOOST_GIL_EXTENSION_IO_READ_AND_CONVERT_IMAGE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/type_traits/is_base_and_derived.hpp>
+#include <boost/mpl/and.hpp>
+#include <boost/utility/enable_if.hpp>
+
+#include "base.hpp"
+#include "io_device.hpp"
+#include "path_spec.hpp"
+#include "conversion_policies.hpp"
+
+namespace boost{ namespace gil {
+
+/// \ingroup IO
+
+/// \brief Reads and color-converts an image. Image memory is allocated.
+/// \param reader    An image reader.
+/// \param img       The image in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \param cc        Color converter function object.
+/// \throw std::ios_base::failure
+template< typename Reader
+        , typename Image
+        >
+inline
+void read_and_convert_image( Reader&                                 reader
+                           , Image&                                  img
+                           , typename enable_if< mpl::and_< detail::is_reader< Reader >
+                                                          , is_format_tag< typename Reader::format_tag_t >
+                                                          >
+                           >::type* /* ptr */ = 0
+                           )
+{
+    reader.init_image( img
+                     , reader._settings
+                     );
+
+    reader.apply( view( img ));
+}
+
+/// \brief Reads and color-converts an image. Image memory is allocated.
+/// \param device    Must satisfy is_input_device metafunction.
+/// \param img       The image in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \param cc        Color converter function object.
+/// \throw std::ios_base::failure
+template< typename Device
+        , typename Image
+        , typename ColorConverter
+        , typename FormatTag
+        >
+inline
+void read_and_convert_image( Device&                                 device
+                           , Image&                                  img
+                           , const image_read_settings< FormatTag >& settings
+                           , const ColorConverter&                   cc
+                           , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                                  , Device
+                                                                                  >
+                                                          , is_format_tag< FormatTag >
+                                                          >
+                                                >::type* /* ptr */ = 0
+                           )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_convert< ColorConverter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( device
+                                 , settings
+                                 , detail::read_and_convert< ColorConverter >( cc )
+                                 );
+
+    read_and_convert_image( reader
+                          , img
+                          );
+}
+
+/// \brief Reads and color-converts an image. Image memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param img       The image in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \param cc        Color converter function object.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename Image
+         , typename ColorConverter
+         , typename FormatTag
+         >
+inline
+void read_and_convert_image( const String&                           file_name
+                           , Image&                                  img
+                           , const image_read_settings< FormatTag >& settings
+                           , const ColorConverter&                   cc
+                           , typename enable_if< mpl::and_< is_format_tag< FormatTag >
+                                                          , detail::is_supported_path_spec< String >
+                                                          >
+                                               >::type* /* ptr */ = 0
+                           )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_convert< ColorConverter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , settings
+                                 , detail::read_and_convert< ColorConverter >( cc )
+                                 );
+
+    read_and_convert_image( reader
+                          , img
+                          );
+}
+
+/// \brief Reads and color-converts an image. Image memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param img       The image in which the data is read into.
+/// \param cc        Color converter function object.
+/// \param tag       Defines the image format. Must satisfy is_format_tag metafunction.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename Image
+         , typename ColorConverter
+         , typename FormatTag
+         >
+inline
+void read_and_convert_image( const String&         file_name
+                           , Image&                img
+                           , const ColorConverter& cc
+                           , const FormatTag&      tag
+                           , typename enable_if< mpl::and_< is_format_tag< FormatTag >
+                                                          , detail::is_supported_path_spec< String >
+                                                          >
+                                               >::type* /* ptr */ = 0
+                           )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_convert< ColorConverter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , tag
+                                 , detail::read_and_convert< ColorConverter >( cc )
+                                 );
+
+    read_and_convert_image( reader
+                          , img
+                          );
+}
+
+/// \brief Reads and color-converts an image. Image memory is allocated.
+/// \param device Must satisfy is_input_device metafunction or is_adaptable_input_device.
+/// \param img    The image in which the data is read into.
+/// \param cc     Color converter function object.
+/// \param tag    Defines the image format. Must satisfy is_format_tag metafunction.
+/// \throw std::ios_base::failure
+template < typename Device
+         , typename Image
+         , typename ColorConverter
+         , typename FormatTag
+         >
+inline
+void read_and_convert_image( Device&               device
+                           , Image&                img
+                           , const ColorConverter& cc
+                           , const FormatTag&      tag
+                           , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                                  , Device
+                                                                                  >
+                                                          , is_format_tag< FormatTag >
+                                                          >
+                                               >::type* /* ptr */ = 0
+                           )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_convert< ColorConverter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( device
+                                 , tag
+                                 , detail::read_and_convert< ColorConverter >( cc )
+                                 );
+
+    read_and_convert_image( reader
+                          , img
+                          );
+}
+
+/// \brief Reads and color-converts an image. Image memory is allocated. Default color converter is used.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param img       The image in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename Image
+         , typename FormatTag
+         >
+inline
+void read_and_convert_image( const String&                           file_name
+                           , Image&                                  img
+                           , const image_read_settings< FormatTag >& settings
+                           , typename enable_if< mpl::and_< is_format_tag< FormatTag >
+                                                          , detail::is_supported_path_spec< String >
+                                                          >
+                                               >::type* /* ptr */ = 0
+                           )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_convert< default_color_converter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , settings
+                                 , detail::read_and_convert< default_color_converter >()
+                                 );
+
+    read_and_convert_image( reader
+                          , img
+                          );
+}
+
+/// \brief Reads and color-converts an image. Image memory is allocated. Default color converter is used.
+/// \param device    It's a device. Must satisfy is_input_device metafunction or is_adaptable_input_device.
+/// \param img       The image in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \throw std::ios_base::failure
+template < typename Device
+         , typename Image
+         , typename FormatTag
+         >
+inline
+void read_and_convert_image( Device&                                 device
+                           , Image&                                  img
+                           , const image_read_settings< FormatTag >& settings
+                           , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                                  , Device
+                                                                                  >
+                                                          , is_format_tag< FormatTag >
+                                                          >
+                                               >::type* /* ptr */ = 0
+                           )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_convert< default_color_converter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( device
+                                 , settings
+                                 , detail::read_and_convert< default_color_converter >()
+                                 );
+
+    read_and_convert_image( reader
+                          , img
+                          );
+}
+
+/// \brief Reads and color-converts an image. Image memory is allocated. Default color converter is used.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param img       The image in which the data is read into.
+/// \param tag       Defines the image format. Must satisfy is_format_tag metafunction.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename Image
+         , typename FormatTag
+         >
+inline
+void read_and_convert_image( const String&    file_name
+                           , Image&           img
+                           , const FormatTag& tag
+                           , typename enable_if< mpl::and_< is_format_tag< FormatTag >
+                                                          , detail::is_supported_path_spec< String >
+                                                          >
+                                               >::type* /* ptr */ = 0
+                           )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_convert< default_color_converter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , tag
+                                 , detail::read_and_convert< default_color_converter >()
+                                 );
+
+    read_and_convert_image( reader
+                          , img
+                          );
+}
+
+/// \brief Reads and color-converts an image. Image memory is allocated. Default color converter is used.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param img       The image in which the data is read into.
+/// \param tag       Defines the image format. Must satisfy is_format_tag metafunction.
+/// \throw std::ios_base::failure
+template < typename Device
+         , typename Image
+         , typename FormatTag
+         >
+inline
+void read_and_convert_image( Device&          device
+                           , Image&           img
+                           , const FormatTag& tag
+                           , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                                  , Device
+                                                                                  >
+                                                          , is_format_tag< FormatTag >
+                                                          >
+                                               >::type* /* ptr */ = 0
+                           )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_convert< default_color_converter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( device
+                                 , tag
+                                 , detail::read_and_convert< default_color_converter >()
+                                 );
+
+    read_and_convert_image( reader
+                          , img
+                          );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_READ_AND_CONVERT_IMAGE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/read_and_convert_view.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/read_and_convert_view.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,357 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_READ_AND_CONVERT_VIEW_HPP
+#define BOOST_GIL_EXTENSION_IO_READ_AND_CONVERT_VIEW_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/type_traits/is_base_and_derived.hpp>
+#include <boost/mpl/and.hpp>
+#include <boost/utility/enable_if.hpp>
+
+#include "base.hpp"
+#include "io_device.hpp"
+#include "path_spec.hpp"
+#include "conversion_policies.hpp"
+
+namespace boost{ namespace gil {
+
+/// \ingroup IO
+
+/// \brief Reads and color-converts an image view. No memory is allocated.
+/// \param reader    An image reader.
+/// \param img       The image in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \param cc        Color converter function object.
+/// \throw std::ios_base::failure
+template< typename Reader
+        , typename View
+        >
+inline
+void read_and_convert_view( Reader&     reader
+                          , const View& view
+                          , typename enable_if< mpl::and_< detail::is_reader< Reader >
+                                                         , is_format_tag< typename Reader::format_tag_t >
+                                                         >
+                          >::type* /* ptr */ = 0
+                          )
+{
+    reader.init_view( view
+                    , reader._settings
+                    );
+
+    reader.apply( view );
+}
+
+/// \brief Reads and color-converts an image view. No memory is allocated.
+/// \param file      It's a device. Must satisfy is_input_device metafunction.
+/// \param view      The image view in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \param cc        Color converter function object.
+/// \throw std::ios_base::failure
+template< typename Device
+        , typename View
+        , typename ColorConverter
+        , typename FormatTag
+        >
+inline
+void read_and_convert_view( Device&                                 device
+                          , const View&                             view
+                          , const image_read_settings< FormatTag >& settings
+                          , const ColorConverter&                   cc
+                          , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                                 , Device
+                                                                                 >
+                                                         , is_format_tag< FormatTag >
+                                                         >
+                                              >::type* /* ptr */ = 0
+
+                          )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_convert< ColorConverter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( device
+                                 , settings
+                                 , detail::read_and_convert< ColorConverter >( cc )
+                                 );
+
+    read_and_convert_view( reader
+                         , view
+                         );
+}
+
+/// \brief Reads and color-converts an image view. No memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param view      The image view in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \param cc        Color converter function object.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename View
+         , typename ColorConverter
+         , typename FormatTag
+         >
+inline
+void read_and_convert_view( const String&                           file_name
+                          , const View&                             view
+                          , const image_read_settings< FormatTag >& settings
+                          , const ColorConverter&                   cc
+                          , typename enable_if< mpl::and_< is_format_tag< FormatTag >
+                                                         , detail::is_supported_path_spec< String >
+                                                         >
+                                            >::type* /* ptr */ = 0
+                          )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_convert< ColorConverter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , settings
+                                 , detail::read_and_convert< ColorConverter >( cc )
+                                 );
+
+    read_and_convert_view( reader
+                         , view
+                         );
+}
+
+/// \brief Reads and color-converts an image view. No memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param view      The image view in which the data is read into.
+/// \param cc        Color converter function object.
+/// \param tag       Defines the image format. Must satisfy is_format_tag metafunction. 
+/// \throw std::ios_base::failure
+template < typename String
+         , typename View
+         , typename ColorConverter
+         , typename FormatTag
+         >
+inline
+void read_and_convert_view( const String&         file_name
+                          , const View&           view
+                          , const ColorConverter& cc
+                          , const FormatTag&      tag
+                          , typename enable_if< mpl::and_< is_format_tag< FormatTag >
+                                                         , detail::is_supported_path_spec< String >
+                                                         >
+                                            >::type* /* ptr */ = 0
+                          )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_convert< ColorConverter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , tag
+                                 , detail::read_and_convert< ColorConverter >( cc )
+                                 );
+
+    read_and_convert_view( reader
+                         , view
+                         );
+}
+
+/// \brief Reads and color-converts an image view. No memory is allocated.
+/// \param file It's a device. Must satisfy is_input_device metafunction or is_adaptable_input_device.
+/// \param view The image view in which the data is read into.
+/// \param cc   Color converter function object.
+/// \param tag  Defines the image format. Must satisfy is_format_tag metafunction. 
+/// \throw std::ios_base::failure
+template < typename Device
+         , typename View
+         , typename ColorConverter
+         , typename FormatTag
+         >
+inline
+void read_and_convert_view( Device&               device
+                          , const View&           view
+                          , const ColorConverter& cc
+                          , const FormatTag&      tag
+                          , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                                 , Device
+                                                                                 >
+                                                         , is_format_tag< FormatTag >
+                                                         >
+                                               >::type* /* ptr */ = 0
+                          )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_convert< ColorConverter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( device
+                                 , tag
+                                 , detail::read_and_convert< ColorConverter >( cc )
+                                 );
+
+    read_and_convert_view( reader
+                         , view
+                         );
+}
+
+/// \brief Reads and color-converts an image view. No memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param view      The image view in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename View
+         , typename FormatTag
+         >
+inline
+void read_and_convert_view( const String&                           file_name
+                          , const View&                             view
+                          , const image_read_settings< FormatTag >& settings
+                          , typename enable_if< mpl::and_< is_format_tag< FormatTag >
+                                                         , detail::is_supported_path_spec< String >
+                                                         >
+                                            >::type* /* ptr */ = 0
+                          )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_convert< default_color_converter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , settings
+                                 , detail::read_and_convert< default_color_converter >()
+                                 );
+
+    read_and_convert_view( reader
+                         , view
+                         );
+}
+
+/// \brief Reads and color-converts an image view. No memory is allocated.
+/// \param file      It's a device. Must satisfy is_input_device metafunction or is_adaptable_input_device.
+/// \param view      The image view in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \throw std::ios_base::failure
+template < typename Device
+         , typename View
+         , typename FormatTag
+         >
+inline
+void read_and_convert_view( Device&                                 device
+                          , const View&                             view
+                          , const image_read_settings< FormatTag >& settings
+                          , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                                 , Device
+                                                                                 >
+                                                         , is_format_tag< FormatTag >
+                                                         >
+                                               >::type* /* ptr */ = 0
+                          )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_convert< default_color_converter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( device
+                                 , settings
+                                 , detail::read_and_convert< default_color_converter >()
+                                 );
+
+    read_and_convert_view( reader
+                         , view
+                         );
+
+}
+
+/// \brief Reads and color-converts an image view. No memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param view      The image view in which the data is read into.
+/// \param tag       Defines the image format. Must satisfy is_format_tag metafunction. 
+/// \throw std::ios_base::failure
+template < typename String
+         , typename View
+         , typename FormatTag
+         >
+inline
+void read_and_convert_view( const String&    file_name
+                          , const View&      view
+                          , const FormatTag& tag
+                          , typename enable_if< mpl::and_< is_format_tag< FormatTag >
+                                                         , detail::is_supported_path_spec< String >
+                                                         >
+                                              >::type* /* ptr */ = 0
+                          )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_convert< default_color_converter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , tag
+                                 , detail::read_and_convert< default_color_converter >()
+                                 );
+
+    read_and_convert_view( reader
+                         , view
+                         );
+}
+
+/// \brief Reads and color-converts an image view. No memory is allocated.
+/// \param file It's a device. Must satisfy is_input_device metafunction or is_adaptable_input_device.
+/// \param view The image view in which the data is read into.
+/// \param tag  Defines the image format. Must satisfy is_format_tag metafunction. 
+/// \throw std::ios_base::failure
+template < typename Device
+         , typename View
+         , typename FormatTag
+         >
+inline
+void read_and_convert_view( Device&          device
+                          , const View&      view
+                          , const FormatTag& tag
+                          , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                                 , Device
+                                                                                 >
+                                                         , is_format_tag< FormatTag >
+                                                         >
+                                               >::type* /* ptr */ = 0
+                          )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_convert< default_color_converter >
+                               >::type reader_t;
+
+    reader_t reader = make_reader( device
+                                 , tag
+                                 , detail::read_and_convert< default_color_converter >()
+                                 );
+
+    read_and_convert_view( reader
+                         , view
+                         );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_READ_AND_CONVERT_VIEW_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/read_image.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/read_image.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,366 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_READ_IMAGE_HPP
+#define BOOST_GIL_EXTENSION_IO_READ_IMAGE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/type_traits/is_base_and_derived.hpp>
+#include <boost/algorithm/string.hpp>
+#include <boost/mpl/and.hpp>
+#include <boost/utility/enable_if.hpp>
+
+#include <boost/gil/extension/toolbox/dynamic_images.hpp>
+
+#include "base.hpp"
+#include "io_device.hpp"
+#include "path_spec.hpp"
+#include "conversion_policies.hpp"
+
+namespace boost{ namespace gil {
+
+/// \ingroup IO
+
+/// \brief Reads an image without conversion. Image memory is allocated.
+/// \param reader    An image reader.
+/// \param img       The image in which the data is read into. Must satisfy is_read_supported metafunction.
+/// \throw std::ios_base::failure
+template < typename Reader
+         , typename Image
+         >
+inline
+void read_image( Reader           reader
+               , Image&           img
+               , typename enable_if< mpl::and_< detail::is_reader< Reader >
+                                              , is_format_tag< typename Reader::format_tag_t >
+                                              , is_read_supported< typename get_pixel_type< typename Image::view_t >::type
+                                                                 , typename Reader::format_tag_t
+                                                                 >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    reader.init_image( img
+                     , reader._settings
+                     );
+
+    reader.apply( view( img ));
+}
+
+/// \brief Reads an image without conversion. Image memory is allocated.
+/// \param file      It's a device. Must satisfy is_input_device metafunction.
+/// \param img       The image in which the data is read into. Must satisfy is_read_supported metafunction.
+/// \param settings  Specifies read settings depending on the image format.
+/// \throw std::ios_base::failure
+template < typename Device
+         , typename Image
+         , typename FormatTag
+         >
+inline
+void read_image( Device&                                 file
+               , Image&                                  img
+               , const image_read_settings< FormatTag >& settings
+               , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                      , Device
+                                                                      >
+                                              , is_format_tag< FormatTag >
+                                              , is_read_supported< typename get_pixel_type< typename Image::view_t >::type
+                                                                 , FormatTag
+                                                                 >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_no_convert
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file
+                                 , settings
+                                 , detail::read_and_no_convert()
+                                 );
+
+    read_image( reader
+              , img
+              );
+}
+
+/// \brief Reads an image without conversion. Image memory is allocated.
+/// \param file      It's a device. Must satisfy is_input_device metafunction.
+/// \param img       The image in which the data is read into. Must satisfy is_read_supported metafunction.
+/// \param tag       Defines the image format. Must satisfy is_format_tag metafunction.
+/// \throw std::ios_base::failure
+template < typename Device
+         , typename Image
+         , typename FormatTag
+         >
+inline
+void read_image( Device&          file
+               , Image&           img
+               , const FormatTag& tag
+               , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                      , Device
+                                                                      >
+                                              , is_format_tag< FormatTag >
+                                              , is_read_supported< typename get_pixel_type< typename Image::view_t >::type
+                                                                 , FormatTag
+                                                                 >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_no_convert
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file
+                                 , tag
+                                 , detail::read_and_no_convert()
+                                 );
+
+    read_image( reader
+              , img
+              );
+}
+
+/// \brief Reads an image without conversion. Image memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param img       The image in which the data is read into. Must satisfy is_read_supported metafunction.
+/// \param settings  Specifies read settings depending on the image format.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename Image
+         , typename FormatTag
+         >
+inline
+void read_image( const String&                           file_name
+               , Image&                                  img
+               , const image_read_settings< FormatTag >& settings
+               , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                              , is_format_tag< FormatTag >
+                                              , is_read_supported< typename get_pixel_type< typename Image::view_t >::type
+                                                                 , FormatTag
+                                                                 >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_no_convert
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , settings
+                                 , detail::read_and_no_convert()
+                                 );
+
+    read_image( reader
+              , img
+              );
+}
+
+/// \brief Reads an image without conversion. Image memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param img       The image in which the data is read into. Must satisfy is_read_supported metafunction.
+/// \param tag       Defines the image format. Must satisfy is_format_tag metafunction.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename Image
+         , typename FormatTag
+         >
+inline
+void read_image( const String&    file_name
+               , Image&           img
+               , const FormatTag& tag
+               , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                              , is_format_tag< FormatTag >
+                                              , is_read_supported< typename get_pixel_type< typename Image::view_t >::type
+                                                                 , FormatTag
+                                                                 >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_no_convert
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , tag
+                                 , detail::read_and_no_convert()
+                                 );
+
+    read_image( reader
+              , img
+              );
+}
+
+///
+
+template < typename Reader
+         , typename Images
+         >
+inline
+void read_image( Reader&              reader
+               , any_image< Images >& images
+               , typename enable_if< mpl::and_< detail::is_dynamic_image_reader< Reader >
+                                              , is_format_tag< typename Reader::format_tag_t >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    reader.apply( images );
+}
+
+/// \brief Reads an image without conversion. Image memory is allocated.
+/// \param file      It's a device. Must satisfy is_adaptable_input_device metafunction.
+/// \param images    Dynamic image ( mpl::vector ). See boost::gil::dynamic_image extension.
+/// \param settings  Specifies read settings depending on the image format.
+/// \throw std::ios_base::failure
+template < typename Device
+         , typename Images
+         , typename FormatTag
+         >
+inline
+void read_image( Device&                                 file
+               , any_image< Images >&                    images
+               , const image_read_settings< FormatTag >& settings
+               , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                      , Device
+                                                                      >
+                                              , is_format_tag< FormatTag >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_dynamic_image_reader< Device
+                                             , FormatTag
+                                             >::type reader_t;
+
+    reader_t reader = make_dynamic_image_reader( file
+                                               , settings
+                                               );
+
+    read_image( reader
+              , images
+              );
+}
+
+/// \brief Reads an image without conversion. Image memory is allocated.
+/// \param file      It's a device. Must satisfy is_adaptable_input_device metafunction.
+/// \param images    Dynamic image ( mpl::vector ). See boost::gil::dynamic_image extension.
+/// \param tag       Defines the image format. Must satisfy is_format_tag metafunction.
+/// \throw std::ios_base::failure
+template < typename Device
+         , typename Images
+         , typename FormatTag
+         >
+inline
+void read_image( Device&              file
+               , any_image< Images >& images
+               , const FormatTag&     tag
+               , typename enable_if< mpl::and_< detail::is_read_device< FormatTag
+                                                                      , Device
+                                                                      >
+                                              , is_format_tag< FormatTag >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_dynamic_image_reader< Device
+                                             , FormatTag
+                                             >::type reader_t;
+
+    reader_t reader = make_dynamic_image_reader( file
+                                               , tag
+                                               );
+
+    read_image( reader
+              , images
+              );
+}
+
+/// \brief Reads an image without conversion. Image memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param images    Dynamic image ( mpl::vector ). See boost::gil::dynamic_image extension.
+/// \param settings  Specifies read settings depending on the image format.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename Images
+         , typename FormatTag
+         >
+inline
+void read_image( const String&                           file_name
+               , any_image< Images >&                    images
+               , const image_read_settings< FormatTag >& settings
+               , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                              , is_format_tag< FormatTag >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_dynamic_image_reader< String
+                                             , FormatTag
+                                             >::type reader_t;
+
+    reader_t reader = make_dynamic_image_reader( file_name
+                                               , settings
+                                               );
+
+    read_image( reader
+              , images
+              );
+}
+
+/// \brief Reads an image without conversion. Image memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param images    Dynamic image ( mpl::vector ). See boost::gil::dynamic_image extension.
+/// \param tag       Defines the image format. Must satisfy is_format_tag metafunction.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename Images
+         , typename FormatTag
+         >
+inline
+void read_image( const String&        file_name
+               , any_image< Images >& images
+               , const FormatTag&     tag
+               , typename enable_if< mpl::and_< detail::is_supported_path_spec< String >
+                                              , is_format_tag< FormatTag >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_dynamic_image_reader< String
+                                             , FormatTag
+                                             >::type reader_t;
+
+    reader_t reader = make_dynamic_image_reader( file_name, tag );
+
+    read_image( reader
+              , images
+              );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_READ_IMAGE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/read_image_info.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/read_image_info.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,137 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_IMAGE_READ_INFO_HPP
+#define BOOST_GIL_EXTENSION_IO_IMAGE_READ_INFO_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/type_traits/is_base_and_derived.hpp>
+#include <boost/mpl/and.hpp>
+#include <boost/utility/enable_if.hpp>
+
+#include "base.hpp"
+#include "io_device.hpp"
+#include "path_spec.hpp"
+
+namespace boost{ namespace gil {
+
+/// \ingroup IO
+
+/// \brief Returns the image format backend. Backend is format specific.
+/// \param file      It's a device. Must satisfy is_adaptable_input_device metafunction.
+/// \param settings  Specifies read settings depending on the image format.
+/// \return image_read_info object dependent on the image format.
+/// \throw std::ios_base::failure
+template< typename Device
+        , typename FormatTag
+        >
+inline
+typename get_reader_backend< Device
+                           , FormatTag
+                           >::type
+read_image_info( Device&                                 file
+               , const image_read_settings< FormatTag >& settings
+               , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                                 , Device
+                                                                                 >
+                                              , is_format_tag< FormatTag >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    return make_reader_backend( file, settings );
+}
+
+/// \brief Returns the image format backend. Backend is format specific.
+/// \param file It's a device. Must satisfy is_adaptable_input_device metafunction.
+/// \param tag  Defines the image format. Must satisfy is_format_tag metafunction. 
+/// \return image_read_info object dependent on the image format.
+/// \throw std::ios_base::failure
+template< typename Device
+        , typename FormatTag
+        >
+inline
+typename get_reader_backend< Device
+                           , FormatTag
+                           >::type
+read_image_info( Device&          file
+               , const FormatTag&
+               , typename enable_if< mpl::and_< detail::is_adaptable_input_device< FormatTag
+                                                                                 , Device
+                                                                                 >
+                                              , is_format_tag< FormatTag >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    return read_image_info( file
+                          , image_read_settings< FormatTag >()
+                          );
+}
+
+/// \brief Returns the image format backend. Backend is format specific.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param settings  Specifies read settings depending on the image format.
+/// \return image_read_info object dependent on the image format.
+/// \throw std::ios_base::failure
+template< typename String
+        , typename FormatTag
+        >
+inline 
+typename get_reader_backend< String
+                           , FormatTag
+                           >::type
+read_image_info( const String&                           file_name
+               , const image_read_settings< FormatTag >& settings
+               , typename enable_if< mpl::and_< is_format_tag< FormatTag >
+                                              , detail::is_supported_path_spec< String >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    return make_reader_backend( file_name, settings );
+}
+
+/// \brief Returns the image format backend. Backend is format specific.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param tag       Defines the image format. Must satisfy is_format_tag metafunction. 
+/// \return image_read_info object dependent on the image format.
+/// \throw std::ios_base::failure
+template< typename String
+        , typename FormatTag
+        >
+inline 
+typename get_reader_backend< String
+                           , FormatTag
+                           >::type
+read_image_info( const String&    file_name
+               , const FormatTag&
+               , typename enable_if< mpl::and_< is_format_tag< FormatTag >
+                                              , detail::is_supported_path_spec< String >
+                                              >
+                                   >::type* /* ptr */ = 0
+               )
+{
+    return read_image_info( file_name
+                          , image_read_settings< FormatTag >()
+                          );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_IMAGE_READ_INFO_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/read_view.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/read_view.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,216 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_READ_VIEW_HPP
+#define BOOST_GIL_EXTENSION_IO_READ_VIEW_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/type_traits/is_base_and_derived.hpp>
+#include <boost/mpl/and.hpp>
+#include <boost/utility/enable_if.hpp>
+
+#include "base.hpp"
+#include "io_device.hpp"
+#include "path_spec.hpp"
+
+namespace boost{ namespace gil {
+
+/// \ingroup IO
+
+/// \brief Reads an image view without conversion. No memory is allocated.
+/// \param reader    An image reader.
+/// \param view      The image view in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \throw std::ios_base::failure
+template < typename Reader
+         , typename View
+         >
+inline
+void read_view( Reader                                  reader
+              , const View&                             view
+              , typename enable_if< typename mpl::and_< detail::is_reader< Reader >
+                                                      , typename is_format_tag< typename Reader::format_tag_t >::type
+                                                      , typename is_read_supported< typename get_pixel_type< View >::type
+                                                                                  , typename Reader::format_tag_t
+                                                                                  >::type
+                                                       >::type
+                                  >::type* /* ptr */ = 0
+              )
+{
+    reader.init_view( view
+                    , reader._settings
+                    );
+
+    reader.apply( view );
+}
+
+/// \brief Reads an image view without conversion. No memory is allocated.
+/// \param file      It's a device. Must satisfy is_input_device metafunction.
+/// \param view      The image view in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \throw std::ios_base::failure
+template < typename Device
+         , typename View
+         , typename FormatTag
+         >
+inline
+void read_view( Device&                                 file
+              , const View&                             view
+              , const image_read_settings< FormatTag >& settings
+              , typename enable_if< typename mpl::and_< detail::is_read_device< FormatTag
+                                                                              , Device
+                                                                              >
+                                                      , typename is_format_tag< FormatTag >::type
+                                                      , typename is_read_supported< typename get_pixel_type< View >::type
+                                                                                  , FormatTag
+                                                                                  >::type
+                                                      >::type
+                                  >::type* /* ptr */ = 0
+              )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_no_convert
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file
+                                 , settings
+                                 , detail::read_and_no_convert()
+                                 );
+
+    read_view( reader
+             , view
+             );
+}
+
+/// \brief Reads an image view without conversion. No memory is allocated.
+/// \param file It's a device. Must satisfy is_input_device metafunction or is_adaptable_input_device.
+/// \param view The image view in which the data is read into.
+/// \param tag  Defines the image format. Must satisfy is_format_tag metafunction.
+/// \throw std::ios_base::failure
+template< typename Device
+        , typename View
+        , typename FormatTag
+        >
+inline
+void read_view( Device&          file
+              , const View&      view
+              , const FormatTag& tag
+              , typename enable_if< typename mpl::and_< typename is_format_tag< FormatTag >::type
+                                                      , detail::is_read_device< FormatTag
+                                                                              , Device
+                                                                              >
+                                                      , typename is_read_supported< typename get_pixel_type< View >::type
+                                                                                  , FormatTag
+                                                                                  >::type
+                                                      >::type
+                                  >::type* /* ptr */ = 0
+              )
+{
+    typedef typename get_reader< Device
+                               , FormatTag
+                               , detail::read_and_no_convert
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file
+                                 , tag
+                                 , detail::read_and_no_convert()
+                                 );
+
+    read_view( reader
+             , view
+             );
+}
+
+/// \brief Reads an image view without conversion. No memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param view      The image view in which the data is read into.
+/// \param settings  Specifies read settings depending on the image format.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename View
+         , typename FormatTag
+         >
+inline
+void read_view( const String&                           file_name
+              , const View&                             view
+              , const image_read_settings< FormatTag >& settings
+              , typename enable_if< typename mpl::and_< typename detail::is_supported_path_spec< String >::type
+                                                      , typename is_format_tag< FormatTag >::type
+                                                      , typename is_read_supported< typename get_pixel_type< View >::type
+                                                                                  , FormatTag
+                                                                                  >::type
+                                                      >::type
+                                  >::type* /* ptr */ = 0
+              )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_no_convert
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , settings
+                                 , detail::read_and_no_convert()
+                                 );
+
+    read_view( reader
+             , view
+             );
+}
+
+/// \brief Reads an image view without conversion. No memory is allocated.
+/// \param file_name File name. Must satisfy is_supported_path_spec metafunction.
+/// \param view      The image view in which the data is read into.
+/// \param tag       Defines the image format. Must satisfy is_format_tag metafunction.
+/// \throw std::ios_base::failure
+template < typename String
+         , typename View
+         , typename FormatTag
+         >
+inline
+void read_view( const String&    file_name
+              , const View&      view
+              , const FormatTag& tag
+              , typename enable_if< typename mpl::and_< typename detail::is_supported_path_spec< String >::type
+                                                      , typename is_format_tag< FormatTag >::type
+                                                      , typename is_read_supported< typename get_pixel_type< View >::type
+                                                                                  , FormatTag
+                                                                                  >::type
+                                                      >::type
+                                  >::type* /* ptr */ = 0
+              )
+{
+    typedef typename get_reader< String
+                               , FormatTag
+                               , detail::read_and_no_convert
+                               >::type reader_t;
+
+    reader_t reader = make_reader( file_name
+                                 , tag
+                                 , detail::read_and_no_convert()
+                                 );
+
+    read_view( reader
+             , view
+             );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_READ_VIEW_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/reader_base.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/reader_base.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,135 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_READER_BASE_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_READER_BASE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "base.hpp"
+
+namespace boost { namespace gil { 
+
+/// Reader Base Class
+/// 
+/// It provides some basic functionality which is shared for all readers.
+/// For instance, it recreates images when necessary. It checks whether
+/// user supplied coordinates are valid.
+///
+/// @tparam FormatTag        A format tag, like jpeg_tag.
+/// @tparam ConversionPolicy Conversion policy, see coversion_policies.hpp.
+template< typename FormatTag
+        , typename ConversionPolicy
+        >
+struct reader_base
+{
+public:
+
+    ///
+    /// Default Constructor
+    ///
+    reader_base()
+    :_cc_policy()
+    {}
+
+    ///
+    /// Constructor
+    ///
+    reader_base( const ConversionPolicy& cc )
+    :_cc_policy( cc )
+    {}
+
+    /// Initializes an image. But also does some check ups.
+    ///
+    /// @tparam Image Image which implements boost::gil's ImageConcept.
+    ///
+    /// @param img  The image.
+    /// @param info The image read info.
+    template< typename Image >
+    void init_image( Image&                                  img
+                   , const image_read_settings< FormatTag >& settings
+                   )
+    {
+        //setup( backend._settings._dim );
+
+        assert( settings._dim.x && settings._dim.y );
+
+        img.recreate( settings._dim.x
+                    , settings._dim.y
+                    );
+    }
+
+    template< typename View >
+    void init_view( const View&                             view
+                  , const image_read_settings< FormatTag >& setttings
+                  )
+    {
+        setup( view.dimensions() );
+    }
+
+private:
+
+    void setup( const point_t& dim )
+    {
+        //check_coordinates( dim );
+
+        //if( dim == point_t( 0, 0 ))
+        //{
+        //    _settings._dim.x = _info._width;
+        //    _settings._dim.y = _info._height;
+        //}
+        //else
+        //{
+        //    _settings._dim = dim;
+        //}
+    }
+
+    void check_coordinates( const point_t& dim )
+    {
+       //typedef point_t::value_type int_t;
+
+       //int_t width  = static_cast< int_t >( _info._width  );
+       //int_t height = static_cast< int_t >( _info._height );
+
+       //io_error_if( (  _settings._top_left.x < 0
+       //             || _settings._top_left.y < 0
+       //             || dim.x < 0
+       //             || dim.y < 0
+       //             )
+       //          , "User provided view has incorrect size." );
+
+
+       //io_error_if( (  ( width  ) <  _settings._top_left.x
+       //             && ( width  ) <= dim.x
+       //             && ( height ) <  _settings._top_left.y
+       //             && ( height ) <= dim.y  )
+       //          , "User provided view has incorrect size."       );
+
+       //io_error_if( (  ( _settings._top_left.x + dim.x ) > width
+       //             || ( _settings._top_left.y + dim.y ) > height
+       //            )
+       //          , "User provided view has incorrect size." );
+    }
+
+protected:
+
+    ConversionPolicy _cc_policy;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_READER_BASE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/row_buffer_helper.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/row_buffer_helper.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,211 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_READ_HELPER_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_READ_HELPER_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief  Helper for having one read implementation used for
+///         bit_aligned and byte images.
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/toolbox/gil_extensions.hpp>
+
+#include "typedefs.hpp"
+
+
+namespace boost { namespace gil { namespace detail {
+
+template< typename Pixel
+        , typename DummyT = void
+        >
+struct row_buffer_helper
+{
+    typedef Pixel element_t;
+    typedef std::vector< element_t > buffer_t;
+    typedef typename buffer_t::iterator iterator_t;
+
+    row_buffer_helper( std::size_t width
+                     , bool
+                     )
+    : _row_buffer( width )
+    {}
+
+    element_t* data() { return &_row_buffer[0]; }
+
+    iterator_t begin() { return _row_buffer.begin(); }
+    iterator_t end()   { return _row_buffer.end();   }
+
+    buffer_t& buffer() { return _row_buffer; }
+
+private:
+
+    buffer_t _row_buffer;
+};
+
+template<typename Pixel >
+struct row_buffer_helper< Pixel
+                        , typename enable_if< typename is_bit_aligned< Pixel >::type >::type
+                        >
+{
+    typedef byte_t element_t;
+    typedef std::vector< element_t > buffer_t;
+    typedef Pixel pixel_type;
+    typedef bit_aligned_pixel_iterator<pixel_type> iterator_t;
+
+    row_buffer_helper( std::size_t width
+                     , bool        in_bytes
+                     )
+    : _c( ( width 
+          * pixel_bit_size< pixel_type >::value
+          )
+          >> 3 
+        )
+
+    , _r( width
+          * pixel_bit_size< pixel_type >::value
+        - ( _c << 3 )
+       )
+    {
+        if( in_bytes )
+        {
+            _row_buffer.resize( width );
+        }
+        else
+        {
+            // add one byte if there are remaining bits
+            _row_buffer.resize( _c + ( _r!=0 ));
+        }
+    }
+
+    element_t* data() { return &_row_buffer[0]; }
+
+    iterator_t begin() { return iterator_t( &_row_buffer.front(),0 ); }
+    iterator_t end()   { return _r == 0 ? iterator_t( &_row_buffer.back() + 1,  0 )
+                                        : iterator_t( &_row_buffer.back()    , (int) _r );
+                       }
+
+    buffer_t& buffer() { return _row_buffer; }
+
+private:
+
+    // For instance 25 pixels of rgb2 type would be:
+    // overall 25 pixels * 3 channels * 2 bits/channel = 150 bits
+    // c = 18 bytes
+    // r = 6 bits
+
+    std::size_t _c; // number of full bytes
+    std::size_t _r; // number of remaining bits
+
+    buffer_t _row_buffer;
+};
+
+template<typename Pixel >
+struct row_buffer_helper< Pixel
+                        , typename boost::enable_if< typename mpl::and_< typename is_bit_aligned< Pixel >::type
+                                                                , typename is_homogeneous< Pixel >::type
+                                                                >::type
+                                            >
+                        >
+{
+    typedef byte_t element_t;
+    typedef std::vector< element_t > buffer_t;
+    typedef Pixel pixel_type;
+    typedef bit_aligned_pixel_iterator<pixel_type> iterator_t;
+
+    row_buffer_helper( std::size_t width
+                     , bool        in_bytes
+                     )
+    : _c( ( width 
+          * num_channels< pixel_type >::type::value
+          * channel_type< pixel_type >::type::num_bits
+          )
+          >> 3 
+        )
+
+    , _r( width
+        * num_channels< pixel_type >::type::value 
+        * channel_type< pixel_type >::type::num_bits 
+        - ( _c << 3 )
+       )
+    {
+        if( in_bytes )
+        {
+            _row_buffer.resize( width );
+        }
+        else
+        {
+            // add one byte if there are remaining bits
+            _row_buffer.resize( _c + ( _r!=0 ));
+        }
+    }
+
+    element_t* data() { return &_row_buffer[0]; }
+
+    iterator_t begin() { return iterator_t( &_row_buffer.front(),0 ); }
+    iterator_t end()   { return _r == 0 ? iterator_t( &_row_buffer.back() + 1,  0 )
+                                        : iterator_t( &_row_buffer.back()    , (int) _r );
+                       }
+
+    buffer_t& buffer() { return _row_buffer; }
+
+private:
+
+    // For instance 25 pixels of rgb2 type would be:
+    // overall 25 pixels * 3 channels * 2 bits/channel = 150 bits
+    // c = 18 bytes
+    // r = 6 bits
+
+    std::size_t _c; // number of full bytes
+    std::size_t _r; // number of remaining bits
+
+    buffer_t _row_buffer;
+};
+
+template< typename View
+        , typename D = void
+        >
+struct row_buffer_helper_view : row_buffer_helper< typename View::value_type >
+{
+    row_buffer_helper_view( std::size_t width
+                          , bool        in_bytes
+                          )
+    :  row_buffer_helper< typename View::value_type >( width
+                                                     , in_bytes
+                                                     )
+    {}
+};
+
+
+template< typename View >
+struct row_buffer_helper_view< View
+                             , typename enable_if< typename is_bit_aligned< typename View::value_type 
+                                                                          >::type
+                                                 >::type
+                             > : row_buffer_helper< typename View::reference >
+{
+    row_buffer_helper_view( std::size_t width
+                          , bool        in_bytes
+                          ) 
+    : row_buffer_helper< typename View::reference >( width
+                                                   , in_bytes
+                                                   )
+    {}
+};
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_READ_HELPER_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/typedefs.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/typedefs.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,98 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BASE_HPP
+#define BOOST_GIL_EXTENSION_IO_BASE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <vector>
+
+#include <boost/type_traits/is_base_of.hpp>
+
+#include <boost/gil/image.hpp>
+#include <boost/gil/utilities.hpp>
+
+#ifdef BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+#include <boost/gil/extension/toolbox/gray_alpha.hpp>
+#endif // BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+namespace boost { namespace gil { 
+
+struct double_zero { static double apply() { return 0.0; } };
+struct double_one  { static double apply() { return 1.0; } };
+
+typedef scoped_channel_value< double, double_zero, double_one > bits64f;
+
+typedef unsigned char byte_t;
+typedef std::vector< byte_t > byte_vector_t;
+
+typedef point2< std::ptrdiff_t > point_t;
+
+} // namespace gil
+} // namespace boost
+
+namespace boost { 
+
+template<> struct is_floating_point< gil::bits32f > : mpl::true_ {};
+template<> struct is_floating_point< gil::bits64f > : mpl::true_ {};
+
+} // namespace boost
+
+namespace boost { namespace gil {
+
+///@todo We should use boost::preprocessor here.
+
+typedef bit_aligned_image1_type<  1, gray_layout_t >::type gray1_image_t;
+typedef bit_aligned_image1_type<  2, gray_layout_t >::type gray2_image_t;
+typedef bit_aligned_image1_type<  4, gray_layout_t >::type gray4_image_t;
+typedef bit_aligned_image1_type<  6, gray_layout_t >::type gray6_image_t;
+typedef bit_aligned_image1_type< 10, gray_layout_t >::type gray10_image_t;
+typedef bit_aligned_image1_type< 12, gray_layout_t >::type gray12_image_t;
+typedef bit_aligned_image1_type< 14, gray_layout_t >::type gray14_image_t;
+typedef bit_aligned_image1_type< 24, gray_layout_t >::type gray24_image_t;
+
+typedef pixel< double, gray_layout_t       > gray64f_pixel_t;
+
+#ifdef BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+typedef pixel<  uint8_t, gray_alpha_layout_t > gray_alpha8_pixel_t;
+typedef pixel< uint16_t, gray_alpha_layout_t > gray_alpha16_pixel_t;
+typedef pixel<   double, gray_alpha_layout_t > gray_alpha64f_pixel_t;
+#endif // BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+typedef pixel< double, rgb_layout_t        > rgb64f_pixel_t;
+typedef pixel< double, rgba_layout_t       > rgba64f_pixel_t;
+typedef image< gray64f_pixel_t      , false > gray64f_image_t;
+
+#ifdef BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+typedef image<  gray_alpha8_pixel_t, false  > gray_alpha8_image_t;
+typedef image<  gray_alpha16_pixel_t, false > gray_alpha16_image_t;
+typedef image< gray_alpha32f_pixel_t, false > gray_alpha32f_image_t;
+typedef image< gray_alpha32f_pixel_t, true  > gray_alpha32f_planar_image_t;
+typedef image< gray_alpha64f_pixel_t, false > gray_alpha64f_image_t;
+typedef image< gray_alpha64f_pixel_t, true  > gray_alpha64f_planar_image_t;
+
+#endif // BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+typedef image< rgb64f_pixel_t       , false > rgb64f_image_t;
+typedef image< rgb64f_pixel_t       , true  > rgb64f_planar_image_t;
+typedef image< rgba64f_pixel_t      , false > rgba64f_image_t;
+typedef image< rgba64f_pixel_t      , true  > rgba64f_planar_image_t;
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_BASE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/detail/write_view.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/detail/write_view.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,325 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_WRITE_VIEW_HPP
+#define BOOST_GIL_EXTENSION_IO_WRITE_VIEW_HPP
+
+#include <boost/type_traits/is_base_and_derived.hpp>
+#include <boost/type_traits/is_base_and_derived.hpp>
+#include <boost/mpl/and.hpp>
+#include <boost/utility/enable_if.hpp>
+
+#include "base.hpp"
+#include "io_device.hpp"
+#include "path_spec.hpp"
+#include "conversion_policies.hpp"
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost{ namespace gil {
+
+/// \ingroup IO
+
+template< typename Writer
+        , typename View
+        >
+inline
+void write_view( Writer&     writer
+               , const View& view
+               , typename enable_if< typename mpl::and_< typename detail::is_writer< Writer >::type
+                                                       , typename is_format_tag< typename Writer::format_tag_t >::type
+                                                       , typename is_write_supported< typename get_pixel_type< View >::type
+                                                                                    , typename Writer::format_tag_t
+                                                                                    >::type
+                                                       >::type
+                                   >::type* /* ptr */ = 0
+               )
+{
+    writer.apply( view );
+}
+
+template< typename Device
+        , typename View
+        , typename FormatTag
+        >
+inline
+void write_view( Device&          device
+               , const View&      view
+               , const FormatTag& tag
+               , typename enable_if< typename mpl::and_< typename detail::is_write_device< FormatTag
+                                                                                         , Device
+                                                                                         >::type
+                                                       , typename is_format_tag< FormatTag >::type
+                                                       , typename is_write_supported< typename get_pixel_type< View >::type
+                                                                                    , FormatTag
+                                                                                    >::type
+                                                       >::type
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_writer< Device
+                               , FormatTag
+                               >::type writer_t;
+
+    writer_t writer = make_writer( device
+                                 , tag
+                                 );
+
+    write_view( writer
+              , view
+              );
+}
+
+template< typename String
+        , typename View
+        , typename FormatTag
+        >
+inline
+void write_view( const String&    file_name
+               , const View&      view
+               , const FormatTag& tag
+               , typename enable_if< typename mpl::and_< typename detail::is_supported_path_spec< String >::type
+                                                       , typename is_format_tag< FormatTag >::type
+                                                       , typename is_write_supported< typename get_pixel_type< View >::type
+                                                                                    , FormatTag
+                                                                                    >::type
+                                                       >::type
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_writer< String
+                               , FormatTag
+                               >::type writer_t;
+
+    writer_t writer = make_writer( file_name
+                                 , tag
+                                 );
+
+    write_view( writer
+              , view
+              );
+}
+
+/// \ingroup IO
+template< typename Device
+        , typename View
+        , typename FormatTag
+        , typename Log
+        >
+inline
+void write_view( Device&                                 device
+               , const View&                             view
+               , const image_write_info<FormatTag, Log>& info
+               , typename enable_if< typename mpl::and_< typename detail::is_write_device< FormatTag
+                                                                                         , Device
+                                                                                         >::type
+                                                       , typename is_format_tag< FormatTag >::type
+                                                       , typename is_write_supported< typename get_pixel_type< View >::type
+                                                                                    , FormatTag
+                                                                                    >::type
+                                                       >::type
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_writer< Device
+                               , FormatTag
+                               >::type writer_t;
+
+    writer_t writer = make_writer( device
+                                 , info
+                                 );
+
+    write_view( writer
+              , view
+              );
+}
+
+template< typename String
+        , typename View
+        , typename FormatTag
+        , typename Log
+        >
+inline
+void write_view( const String&                             file_name
+               , const View&                               view
+               , const image_write_info< FormatTag, Log >& info
+               , typename enable_if< typename mpl::and_< typename detail::is_supported_path_spec< String >::type
+                                                       , typename is_format_tag< FormatTag >::type
+                                                       , typename is_write_supported< typename get_pixel_type< View >::type
+                                                                                    , FormatTag
+                                                                                    >::type
+                                                       >::type
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_writer< String
+                               , FormatTag
+                               >::type writer_t;
+
+    writer_t writer = make_writer( file_name
+                                 , info
+                                 );
+
+    write_view( writer
+              , view
+              );
+}
+
+
+////////////////////////////////////// dynamic_image
+
+// without image_write_info
+template< typename Writer
+        , typename Views
+        >
+inline
+void write_view( Writer&                        writer
+               , const any_image_view< Views >& view
+               , typename enable_if< typename mpl::and_< typename detail::is_dynamic_image_writer< Writer >::type
+                                                       , typename is_format_tag< typename Writer::format_tag_t >::type
+                                                       >::type
+                                   >::type* /* ptr */ = 0
+               )
+{
+    writer.apply( view );
+}
+
+// without image_write_info
+
+template< typename Device
+        , typename Views
+        , typename FormatTag
+        >
+inline
+void write_view( Device&                        device
+               , const any_image_view< Views >& views
+               , const FormatTag&               tag
+               , typename enable_if< typename mpl::and_< typename detail::is_write_device< FormatTag
+                                                                                         , Device
+                                                                                         >::type
+                                                       , typename is_format_tag< FormatTag >::type
+                                                       >::type
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_dynamic_image_writer< Device
+                                             , FormatTag
+                                             >::type writer_t;
+
+    writer_t writer = make_dynamic_image_writer( device
+                                               , tag
+                                               );
+
+    write_view( writer
+              , views
+              );
+}
+
+template< typename String
+        , typename Views
+        , typename FormatTag
+        >
+inline
+void write_view( const String&                  file_name
+               , const any_image_view< Views >& views
+               , const FormatTag&               tag
+               , typename enable_if< typename mpl::and_< typename detail::is_supported_path_spec< String >::type
+                                                       , typename is_format_tag< FormatTag >::type
+                                                       >::type
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_dynamic_image_writer< String
+                                             , FormatTag
+                                             >::type writer_t;
+
+    writer_t writer = make_dynamic_image_writer( file_name
+                                               , tag
+                                               );
+
+    write_view( writer
+              , views
+              );
+}
+
+// with image_write_info
+/// \ingroup IO
+template< typename Device
+        , typename Views
+        , typename FormatTag
+        , typename Log
+        >
+inline
+void write_view( Device&                           device
+               , const any_image_view< Views >&    views
+               , const image_write_info< FormatTag
+                                       , Log
+                                       >&           info
+               , typename enable_if< typename mpl::and_< typename detail::is_write_device< FormatTag
+                                                                                         , Device
+                                                                                         >::type
+                                                       , typename is_format_tag< FormatTag >::type
+                                                       >::type
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_dynamic_image_writer< Device
+                                             , FormatTag
+                                             >::type writer_t;
+
+    writer_t writer = make_dynamic_image_writer( device
+                                               , info
+                                               );
+
+    write_view( writer
+              , views
+              );
+}
+
+template< typename String
+        , typename Views
+        , typename FormatTag
+        , typename Log
+        >
+inline
+void write_view( const String&                      file_name
+               , const any_image_view< Views >&     views
+               , const image_write_info< FormatTag
+                                       , Log
+                                       >&           info
+               , typename enable_if< typename mpl::and_< typename detail::is_supported_path_spec< String >::type
+                                                       , typename is_format_tag< FormatTag >::type
+                                                       >::type
+                                   >::type* /* ptr */ = 0
+               )
+{
+    typedef typename get_dynamic_image_writer< String
+                                             , FormatTag
+                                             >::type writer_t;
+
+    writer_t writer = make_dynamic_image_writer( file_name
+                                               , info
+                                               );
+
+    write_view( writer
+              , views
+              );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_WRITE_VIEW_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/is_allowed.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/is_allowed.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,92 @@
+/*
+    Copyright 2009 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_IO_IS_ALLOWED_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_IO_IS_ALLOWED_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost { namespace gil { namespace detail {
+
+template< typename View >
+bool is_allowed( const image_read_info< bmp_tag >& info
+               , mpl::true_   // is read_and_no_convert
+               )
+{
+    bmp_bits_per_pixel::type src_bits_per_pixel = 0;
+
+    switch( info._bits_per_pixel )
+    {
+        case 1:
+        case 4:
+        case 8:
+        {
+            if(  info._header_size == bmp_header_size::_win32_info_size
+              && info._compression != bmp_compression::_rle8
+              && info._compression != bmp_compression::_rle4
+              )
+            {
+                src_bits_per_pixel = 32;
+            }
+            else
+            {
+                src_bits_per_pixel = 24;
+            }
+
+            break;
+        }
+
+        case 15:
+        case 16:
+        {
+            src_bits_per_pixel = 24;
+
+            break;
+        }
+
+        case 24:
+        case 32:
+        {
+            src_bits_per_pixel = info._bits_per_pixel;
+
+            break;
+        }
+        default:
+        {
+            io_error( "Pixel size not supported." );
+        }
+    }
+
+    typedef typename channel_traits< typename element_type< typename View::value_type >::type >::value_type channel_t;
+    bmp_bits_per_pixel::type dst_bits_per_pixel = detail::unsigned_integral_num_bits< channel_t >::value
+                                                * num_channels< View >::value;
+
+    return ( dst_bits_per_pixel == src_bits_per_pixel );
+}
+
+template< typename View >
+bool is_allowed( const image_read_info< bmp_tag >& /* info */
+               , mpl::false_  // is read_and_convert
+               )
+{
+    return true;
+}
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_IO_IS_ALLOWED_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,741 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_IO_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_IO_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <vector>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/bit_operations.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+
+#include "reader_backend.hpp"
+#include "is_allowed.hpp"
+
+namespace boost { namespace gil {
+
+///
+/// BMP Reader
+///
+template< typename Device
+        , typename ConversionPolicy
+        >
+class reader< Device
+            , bmp_tag
+            , ConversionPolicy
+            >
+    : public reader_base< bmp_tag
+                        , ConversionPolicy
+                        >
+    , public reader_backend< Device
+                           , bmp_tag
+                           >
+{
+private:
+
+    typedef reader< Device
+                  , bmp_tag
+                  , ConversionPolicy
+                  > this_t;
+
+    typedef typename ConversionPolicy::color_converter_type cc_t;
+
+public:
+
+    typedef reader_backend< Device, bmp_tag > backend_t;
+
+public:
+
+    //
+    // Constructor
+    //
+    reader( const Device&                         io_dev
+          , const image_read_settings< bmp_tag >& settings
+          )
+    : backend_t( io_dev
+               , settings
+               )
+    , _pitch( 0 )
+    {}
+
+    //
+    // Constructor
+    //
+    reader( const Device&                         io_dev
+          , const ConversionPolicy&               cc
+          , const image_read_settings< bmp_tag >& settings
+          )
+    : reader_base< bmp_tag
+                 , ConversionPolicy
+                 >( cc )
+    , backend_t( io_dev
+               , settings
+               )
+    , _pitch( 0 )
+    {}
+
+
+    /// Read image.
+    template< typename View >
+    void apply( const View& dst_view )
+    {
+        if( this->_info._valid == false )
+        {
+            io_error( "Image header was not read." );
+        }
+
+        typedef typename is_same< ConversionPolicy
+                                , detail::read_and_no_convert
+                                >::type is_read_and_convert_t;
+
+        io_error_if( !detail::is_allowed< View >( this->_info
+                                                , is_read_and_convert_t()
+                                                )
+                   , "Image types aren't compatible."
+                   );
+
+        // the row pitch must be multiple 4 bytes
+        if( this->_info._bits_per_pixel < 8 )
+        {
+            _pitch = static_cast<long>((( this->_info._width * this->_info._bits_per_pixel ) + 7 ) >> 3 );
+        }
+        else
+        {
+            _pitch = static_cast<long>( this->_info._width * (( this->_info._bits_per_pixel + 7 ) >> 3 ));
+        }
+
+        _pitch = (_pitch + 3) & ~3;
+
+        switch( this->_info._bits_per_pixel )
+        {
+            case 1:
+            {
+                this->_scanline_length = ( this->_info._width * num_channels< rgba8_view_t >::value + 3 ) & ~3;
+
+                read_palette_image< gray1_image_t::view_t
+                                  , detail::mirror_bits< byte_vector_t
+                                                       , mpl::true_
+                                                       >
+                                  > ( dst_view );
+                break;
+            }
+
+            case 4:
+            {
+				switch ( this->_info._compression )
+				{
+				    case bmp_compression::_rle4:
+				    {
+                        ///@todo How can we determine that?
+                        this->_scanline_length = 0;
+
+					    read_palette_image_rle( dst_view );
+
+					    break;
+                    }
+
+				    case bmp_compression::_rgb:
+				    {
+                        this->_scanline_length = ( this->_info._width * num_channels< rgba8_view_t >::value + 3 ) & ~3;
+
+					    read_palette_image< gray4_image_t::view_t
+									      , detail::swap_half_bytes< byte_vector_t
+									                               , mpl::true_
+									                               >
+									      > ( dst_view );
+					    break;
+                    }
+
+				    default:
+				    {
+					    io_error( "Unsupported compression mode in BMP file." );
+                        break;
+                    }
+                }
+                break;
+            }
+
+            case 8:
+            {
+				switch ( this->_info._compression )
+				{
+				    case bmp_compression::_rle8:
+				    {
+                        ///@todo How can we determine that?
+                        this->_scanline_length = 0;
+
+                        read_palette_image_rle( dst_view );
+					    break;
+                    }
+
+				    case bmp_compression::_rgb:
+				    {
+                        this->_scanline_length = ( this->_info._width * num_channels< rgba8_view_t >::value + 3 ) & ~3;
+
+					    read_palette_image< gray8_image_t::view_t
+									      , detail::do_nothing< std::vector< gray8_pixel_t > >
+									      > ( dst_view );
+					    break;
+                    }
+
+				    default:
+				    {
+					    io_error( "Unsupported compression mode in BMP file." );
+                        break;
+				    }
+                }
+
+                break;
+            }
+
+            case 15: case 16:
+            {
+                this->_scanline_length = ( this->_info._width * num_channels< rgb8_view_t >::value + 3 ) & ~3;
+
+                read_data_15( dst_view );
+
+                break;
+            }
+
+            case 24:
+            {
+                this->_scanline_length = ( this->_info._width * num_channels< rgb8_view_t >::value + 3 ) & ~3;
+
+                read_data< bgr8_view_t  >( dst_view );
+
+                break;
+            }
+
+            case 32:
+            {
+                this->_scanline_length = ( this->_info._width * num_channels< rgba8_view_t >::value + 3 ) & ~3;
+
+                read_data< bgra8_view_t >( dst_view );
+
+                break;
+            }
+        }
+    }
+
+private:
+
+    long get_offset( std::ptrdiff_t pos )
+    {
+        if( this->_info._height > 0 )
+        {
+            // the image is upside down
+            return static_cast<long>( ( this->_info._offset
+                                      + ( this->_info._height - 1 - pos ) * _pitch
+                                    ));
+        }
+        else
+        {
+            return static_cast<long>( ( this->_info._offset
+                                      + pos * _pitch
+                                    ));
+        }
+    }
+
+    template< typename View_Src
+            , typename Byte_Manipulator
+            , typename View_Dst
+            >
+    void read_palette_image( const View_Dst& view )
+    {
+        this->read_palette();
+
+        typedef detail::row_buffer_helper_view< View_Src > rh_t;
+        typedef typename rh_t::iterator_t          it_t;
+
+        rh_t rh( _pitch, true );
+
+        // we have to swap bits
+        Byte_Manipulator byte_manipulator;
+
+        for( std::ptrdiff_t y = 0
+           ; y < this->_settings._dim.y
+           ; ++y
+           )
+        {
+            this->_io_dev.seek( get_offset( y + this->_settings._top_left.y ));
+
+            this->_io_dev.read( reinterpret_cast< byte_t* >( rh.data() )
+                        , _pitch
+                        );
+
+            byte_manipulator( rh.buffer() );
+
+            typename View_Dst::x_iterator dst_it = view.row_begin( y );
+
+            it_t it  = rh.begin() + this->_settings._top_left.x;
+            it_t end = it + this->_settings._dim.x;
+
+            for( ; it != end; ++it, ++dst_it )
+            {
+                unsigned char c = get_color( *it, gray_color_t() );
+                *dst_it = this->_palette[ c ];
+            }
+        }
+    }
+
+    template< typename View >
+    void read_data_15( const View& view )
+    {
+        byte_vector_t row( _pitch );
+
+        // read the color masks
+        if( this->_info._compression == bmp_compression::_bitfield )
+        {
+            this->_mask.red.mask    = this->_io_dev.read_uint32();
+            this->_mask.green.mask  = this->_io_dev.read_uint32();
+            this->_mask.blue.mask   = this->_io_dev.read_uint32();
+
+            this->_mask.red.width   = detail::count_ones( this->_mask.red.mask   );
+            this->_mask.green.width = detail::count_ones( this->_mask.green.mask );
+            this->_mask.blue.width  = detail::count_ones( this->_mask.blue.mask  );
+
+            this->_mask.red.shift   = detail::trailing_zeros( this->_mask.red.mask   );
+            this->_mask.green.shift = detail::trailing_zeros( this->_mask.green.mask );
+            this->_mask.blue.shift  = detail::trailing_zeros( this->_mask.blue.mask  );
+        }
+        else if( this->_info._compression == bmp_compression::_rgb )
+        {
+            switch( this->_info._bits_per_pixel )
+            {
+                case 15:
+                case 16:
+                {
+                    this->_mask.red.mask   = 0x007C00; this->_mask.red.width   = 5; this->_mask.red.shift   = 10;
+                    this->_mask.green.mask = 0x0003E0; this->_mask.green.width = 5; this->_mask.green.shift =  5;
+                    this->_mask.blue.mask  = 0x00001F; this->_mask.blue.width  = 5; this->_mask.blue.shift  =  0;
+
+                    break;
+                }
+
+                case 24:
+                case 32:
+                {
+                    this->_mask.red.mask   = 0xFF0000; this->_mask.red.width   = 8; this->_mask.red.shift   = 16;
+                    this->_mask.green.mask = 0x00FF00; this->_mask.green.width = 8; this->_mask.green.shift =  8;
+                    this->_mask.blue.mask  = 0x0000FF; this->_mask.blue.width  = 8; this->_mask.blue.shift  =  0;
+
+                    break;
+                }
+            }
+        }
+        else
+        {
+            io_error( "bmp_reader::apply(): unsupported BMP compression" );
+        }
+
+        typedef rgb8_image_t image_t;
+        typedef typename image_t::view_t::x_iterator it_t;
+
+        for( std::ptrdiff_t y = 0
+           ; y < this->_settings._dim.y
+           ; ++y
+           )
+        {
+            this->_io_dev.seek( get_offset( y + this->_settings._top_left.y ));
+
+            this->_io_dev.read( &row.front()
+                        , row.size()
+                        );
+
+            image_t img_row( this->_info._width, 1 );
+            image_t::view_t v = gil::view( img_row );
+            it_t it = v.row_begin( 0 );
+
+            it_t beg = v.row_begin( 0 ) + this->_settings._top_left.x;
+            it_t end = beg + this->_settings._dim.x;
+
+            byte_t* src = &row.front();
+            for( int32_t i = 0 ; i < this->_info._width; ++i, src += 2 )
+            {
+                int p = ( src[1] << 8 ) | src[0];
+
+                int r = ((p & this->_mask.red.mask)   >> this->_mask.red.shift)   << (8 - this->_mask.red.width);
+                int g = ((p & this->_mask.green.mask) >> this->_mask.green.shift) << (8 - this->_mask.green.width);
+                int b = ((p & this->_mask.blue.mask)  >> this->_mask.blue.shift)  << (8 - this->_mask.blue.width);
+
+                get_color( it[i], red_t()   ) = static_cast< byte_t >( r );
+                get_color( it[i], green_t() ) = static_cast< byte_t >( g );
+                get_color( it[i], blue_t()  ) = static_cast< byte_t >( b );
+            }
+
+            this->_cc_policy.read( beg
+                                 , end
+                                 , view.row_begin( y )
+                                 );
+        }
+    }
+
+
+    // 8-8-8 BGR
+    // 8-8-8-8 BGRA
+    template< typename View_Src
+            , typename View_Dst
+            >
+    void read_data( const View_Dst& view )
+    {
+        byte_vector_t row( _pitch );
+
+        View_Src v = interleaved_view( this->_info._width
+                                     , 1
+                                     , (typename View_Src::value_type*) &row.front()
+                                     , this->_info._width * num_channels< View_Src >::value
+                                     );
+
+        typename View_Src::x_iterator beg = v.row_begin( 0 ) + this->_settings._top_left.x;
+        typename View_Src::x_iterator end = beg + this->_settings._dim.x;
+
+        for( std::ptrdiff_t y = 0
+           ; y < this->_settings._dim.y
+           ; ++y
+           )
+        {
+            this->_io_dev.seek( get_offset( y + this->_settings._top_left.y ));
+
+            this->_io_dev.read( &row.front()
+                        , row.size()
+                        );
+
+            this->_cc_policy.read( beg
+                                 , end
+                                 , view.row_begin( y )
+                                 );
+        }
+    }
+
+	template< typename Buffer
+            , typename View
+	        >
+	void copy_row_if_needed( const Buffer&  buf
+	                       , const View&    view
+						   , std::ptrdiff_t y
+						   )
+	{
+		if(  y >= this->_settings._top_left.y
+		  && y <  this->_settings._dim.y
+		  )
+		{
+            typename Buffer::const_iterator beg = buf.begin() + this->_settings._top_left.x;
+            typename Buffer::const_iterator end = beg + this->_settings._dim.x;
+
+			std::copy( beg
+			         , end
+			         , view.row_begin( y )
+			         );
+		}
+	}
+
+    template< typename View_Dst >
+    void read_palette_image_rle( const View_Dst& view )
+    {
+        assert(  this->_info._compression == bmp_compression::_rle4
+              || this->_info._compression == bmp_compression::_rle8
+              );
+
+        this->read_palette();
+
+        // jump to start of rle4 data
+        this->_io_dev.seek( this->_info._offset );
+
+        // we need to know the stream position for padding purposes
+        std::size_t stream_pos = this->_info._offset;
+
+        typedef std::vector< rgba8_pixel_t > Buf_type;
+        Buf_type buf( this->_settings._dim.x );
+        Buf_type::iterator dst_it  = buf.begin();
+        Buf_type::iterator dst_end = buf.end();
+
+        //
+		std::ptrdiff_t ybeg = 0;
+        std::ptrdiff_t yend = this->_settings._dim.y;
+        std::ptrdiff_t yinc = 1;
+
+        if( this->_info._height > 0 )
+        {
+            ybeg = this->_settings._dim.y - 1;
+            yend = -1;
+            yinc = -1;
+        }
+        //
+
+        std::ptrdiff_t y = ybeg;
+        bool finished = false;
+
+        while ( !finished )
+        {
+            std::ptrdiff_t count  = this->_io_dev.read_uint8();
+            std::ptrdiff_t second = this->_io_dev.read_uint8();
+            stream_pos += 2;
+
+            if ( count )
+            {
+                // encoded mode
+
+                // clamp to boundary
+                if( count > dst_end - dst_it )
+                {
+                    count = dst_end - dst_it;
+                }
+
+                if( this->_info._compression == bmp_compression::_rle4 )
+                {
+                    std::ptrdiff_t cs[2] = { second >> 4, second & 0x0f };
+
+                    for( int i = 0; i < count; ++i )
+                    {
+                        *dst_it++ = this->_palette[ cs[i & 1] ];
+                    }
+                }
+                else
+                {
+                    for( int i = 0; i < count; ++i )
+                    {
+                        *dst_it++ = this->_palette[ second ];
+                    }
+                }
+            }
+            else
+            {
+                switch( second )
+                {
+                    case 0:  // end of row
+                    {
+                        copy_row_if_needed( buf, view, y );
+
+                        y += yinc;
+                        if( y == yend )
+                        {
+                            finished = true;
+                        }
+                        else
+                        {
+                            dst_it = buf.begin();
+                            dst_end = buf.end();
+                        }
+
+                        break;
+                    }
+
+                    case 1:  // end of bitmap
+                    {
+                        copy_row_if_needed( buf, view, y );
+                        finished = true;
+
+                        break;
+                    }
+
+                    case 2:  // offset coordinates
+                    {
+                        std::ptrdiff_t dx = this->_io_dev.read_uint8();
+                        std::ptrdiff_t dy = this->_io_dev.read_uint8() * yinc;
+                        stream_pos += 2;
+
+                        if( dy )
+                        {
+                            copy_row_if_needed( buf, view, y );
+                        }
+
+                        std::ptrdiff_t x = dst_it - buf.begin();
+                        x += dx;
+
+                        if( x > this->_info._width )
+                        {
+                            io_error( "Mangled BMP file." );
+                        }
+
+                        y += dy;
+                        if( yinc > 0 ? y > yend : y < yend )
+                        {
+                            io_error( "Mangled BMP file." );
+                        }
+
+                        dst_it = buf.begin() + x;
+                        dst_end = buf.end();
+
+                        break;
+                    }
+
+                    default:  // absolute mode
+                    {
+                        count = second;
+
+                        // clamp to boundary
+                        if( count > dst_end - dst_it )
+                        {
+                            count = dst_end - dst_it;
+                        }
+
+                        if ( this->_info._compression == bmp_compression::_rle4 )
+                        {
+                            for( int i = 0; i < count; ++i )
+                            {
+                                uint8_t packed_indices = this->_io_dev.read_uint8();
+                                ++stream_pos;
+
+                                *dst_it++ = this->_palette[ packed_indices >> 4 ];
+                                if( ++i == second )
+                                    break;
+
+                                *dst_it++ = this->_palette[ packed_indices & 0x0f ];
+                            }
+                        }
+                        else
+                        {
+                            for( int i = 0; i < count; ++i )
+                            {
+                                uint8_t c = this->_io_dev.read_uint8();
+                                ++stream_pos;
+                                *dst_it++ = this->_palette[ c ];
+                             }
+                        }
+
+                        // pad to word boundary
+                        if( ( stream_pos - get_offset( 0 )) & 1 )
+                        {
+                            this->_io_dev.seek( 1, SEEK_CUR );
+                            ++stream_pos;
+                        }
+
+                        break;
+                    }
+                }
+            }
+        }
+	}
+
+private:
+
+    std::size_t _pitch;
+};
+
+namespace detail {
+
+class bmp_type_format_checker
+{
+public:
+
+    bmp_type_format_checker( const bmp_bits_per_pixel::type& bpp )
+    : _bpp( bpp )
+    {}
+
+    template< typename Image >
+    bool apply()
+    {
+        if( _bpp < 32 )
+        {
+            return pixels_are_compatible< typename Image::value_type, rgb8_pixel_t >::value
+                   ? true
+                   : false;
+        }
+        else
+        {
+            return pixels_are_compatible< typename Image::value_type, rgba8_pixel_t >::value
+                   ? true
+                   : false;
+        }
+    }
+
+private:
+
+    // to avoid C4512
+    bmp_type_format_checker& operator=( const bmp_type_format_checker& ) { return *this; }
+
+private:
+
+    const bmp_bits_per_pixel::type _bpp;
+};
+
+struct bmp_read_is_supported
+{
+    template< typename View >
+    struct apply : public is_read_supported< typename get_pixel_type< View >::type
+                                           , bmp_tag
+                                           >
+    {};
+};
+
+} // namespace detail
+
+///
+/// BMP Dynamic Reader
+///
+template< typename Device >
+class dynamic_image_reader< Device
+                          , bmp_tag
+                          >
+    : public reader< Device
+                   , bmp_tag
+                   , detail::read_and_no_convert
+                   >
+{
+    typedef reader< Device
+                  , bmp_tag
+                  , detail::read_and_no_convert
+                  > parent_t;
+
+public:
+
+    dynamic_image_reader( const Device&                         io_dev
+                        , const image_read_settings< bmp_tag >& settings
+                        )
+    : parent_t( io_dev
+              , settings
+              )
+    {}
+
+    template< typename Images >
+    void apply( any_image< Images >& images )
+    {
+        detail::bmp_type_format_checker format_checker( this->_info._bits_per_pixel );
+
+        if( !construct_matched( images
+                              , format_checker
+                              ))
+        {
+            io_error( "No matching image type between those of the given any_image and that of the file" );
+        }
+        else
+        {
+            init_image( images
+                      , this->_settings
+                      );
+
+            detail::dynamic_io_fnobj< detail::bmp_read_is_supported
+                                    , parent_t
+                                    > op( this );
+
+            apply_operation( view( images )
+                           , op
+                           );
+        }
+    }
+};
+
+} // gil
+} // boost
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_IO_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/reader_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/reader_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,197 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_IO_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_IO_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/bmp_tags.hpp>
+
+namespace boost { namespace gil {
+
+/// Color channel mask
+struct bit_field
+{
+    unsigned int mask;  // Bit mask at corresponding position
+    unsigned int width; // Bit width of the mask
+    unsigned int shift; // Bit position from right to left
+};
+
+/// BMP color masks
+struct color_mask
+{
+    bit_field red;   // Red bits
+    bit_field green; // Green bits
+    bit_field blue;  // Blue bits
+};
+
+
+///
+/// BMP Backend
+///
+template< typename Device >
+struct reader_backend< Device
+                     , bmp_tag
+                     >
+{
+public:
+
+    typedef bmp_tag format_tag_t;
+
+public:
+
+    reader_backend( const Device&                         io_dev
+                  , const image_read_settings< bmp_tag >& settings
+                  )
+    : _io_dev  ( io_dev   )
+    , _settings( settings )
+    , _info()
+    , _scanline_length( 0 )
+    , _palette()
+    {
+        read_header();
+
+        if( _settings._dim.x == 0 )
+        {
+            _settings._dim.x = _info._width;
+        }
+
+        if( _settings._dim.y == 0 )
+        {
+            _settings._dim.y = _info._height;
+        }
+    }
+
+    void read_header()
+    {
+        // the magic number used to identify the BMP file:
+        // 0x42 0x4D (ASCII code points for B and M)
+        if( _io_dev.read_uint16() == 0x424D )
+        {
+            io_error( "Wrong magic number for bmp file." );
+        }
+
+        // the size of the BMP file in bytes
+        _io_dev.read_uint32();
+
+        // reserved; actual value depends on the application that creates the image
+        _io_dev.read_uint16();
+        // reserved; actual value depends on the application that creates the image
+        _io_dev.read_uint16();
+
+        _info._offset = _io_dev.read_uint32();
+
+
+        // bitmap information
+
+        // the size of this header ( 40 bytes )
+        _info._header_size = _io_dev.read_uint32();
+
+        if( _info._header_size == bmp_header_size::_win32_info_size )
+        {
+            _info._width  = _io_dev.read_uint32();
+            _info._height = _io_dev.read_uint32();
+
+            // the number of color planes being used. Must be set to 1.
+            _io_dev.read_uint16();
+
+            _info._bits_per_pixel = _io_dev.read_uint16();
+
+            _info._compression = _io_dev.read_uint32();
+
+            _info._image_size = _io_dev.read_uint32();
+
+            _info._horizontal_resolution = _io_dev.read_uint32();
+            _info._vertical_resolution   = _io_dev.read_uint32();
+
+            _info._num_colors           = _io_dev.read_uint32();
+            _info._num_important_colors = _io_dev.read_uint32();
+
+        }
+        else if( _info._header_size == bmp_header_size::_os2_info_size )
+        {
+            _info._width  = static_cast< bmp_image_width::type  >( _io_dev.read_uint16() );
+            _info._height = static_cast< bmp_image_height::type >( _io_dev.read_uint16() );
+
+            // the number of color planes being used. Must be set to 1.
+            _io_dev.read_uint16();
+
+            _info._bits_per_pixel = _io_dev.read_uint16();
+
+            _info._compression = bmp_compression::_rgb;
+
+            // not used
+            _info._image_size            = 0;
+            _info._horizontal_resolution = 0;
+            _info._vertical_resolution   = 0;
+            _info._num_colors            = 0;
+            _info._num_important_colors  = 0;
+        }
+        else
+        {
+            io_error( "Invalid BMP info header." );
+        }
+
+        _info._valid = true;
+    }
+
+    void read_palette()
+    {
+        int entries = this->_info._num_colors;
+
+        if( entries == 0 )
+        {
+            entries = 1 << this->_info._bits_per_pixel;
+        }
+
+        _palette.resize( entries );
+
+        for( int i = 0; i < entries; ++i )
+        {
+            get_color( _palette[i], blue_t()  ) = _io_dev.read_uint8();
+            get_color( _palette[i], green_t() ) = _io_dev.read_uint8();
+            get_color( _palette[i], red_t()   ) = _io_dev.read_uint8();
+
+            // there are 4 entries when windows header
+            // but 3 for os2 header
+            if( _info._header_size == bmp_header_size::_win32_info_size )
+            {
+                _io_dev.read_uint8();
+            }
+
+        } // for
+    }
+
+public:
+
+    Device _io_dev;
+
+    image_read_settings< bmp_tag > _settings;
+    image_read_info< bmp_tag >     _info;
+
+    std::size_t _scanline_length;
+
+    ///@todo make it an image.
+    std::vector< rgba8_pixel_t > _palette;
+
+    color_mask _mask;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_IO_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/scanline_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/scanline_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,427 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_IO_SCANLINE_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_IO_SCANLINE_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2008 - 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <vector>
+
+#include <boost/function.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/bit_operations.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+
+#include "reader_backend.hpp"
+#include "is_allowed.hpp"
+
+namespace boost { namespace gil {
+
+///
+/// BMP Scanline Reader
+///
+template< typename Device >
+class scanline_reader< Device
+                     , bmp_tag
+                     >
+    : public reader_backend< Device
+                           , bmp_tag
+                           >
+{
+private:
+
+    typedef scanline_reader< Device
+                           , bmp_tag
+                           > this_t;
+
+public:
+
+    typedef reader_backend< Device, bmp_tag > backend_t;
+
+public:
+
+    //
+    // Constructor
+    //
+    scanline_reader( Device&                               device
+                   , const image_read_settings< bmp_tag >& settings
+                   )
+    : backend_t( device
+                    , settings
+                    )
+
+    , _pitch( 0 )
+    {
+        initialize();
+    }
+
+    void clean_up(){}
+
+    /// Read part of image defined by View and return the data.
+    void read( byte_t* dst, int pos )
+    {
+        // jump to scanline
+        long offset = 0;
+
+        if( this->_info._height > 0 )
+        {
+            // the image is upside down
+            offset = this->_info._offset
+                   + ( this->_info._height - 1 - pos ) * this->_pitch;
+        }
+        else
+        {
+            offset = this->_info._offset
+                   + pos * _pitch;
+        }
+
+        this->_io_dev.seek( offset );
+
+
+        // read data
+        _read_function(this, dst);
+    }
+
+    /// Skip over a scanline.
+    void skip( byte_t*, int )
+    {
+        // nothing to do.
+    }
+
+private:
+
+    void initialize()
+    {
+        if( this->_info._bits_per_pixel < 8 )
+        {
+            _pitch = (( this->_info._width * this->_info._bits_per_pixel ) + 7 ) >> 3;
+        }
+        else
+        {
+            _pitch = this->_info._width * (( this->_info._bits_per_pixel + 7 ) >> 3);
+        }
+
+        _pitch = (_pitch + 3) & ~3;
+
+        //
+
+        switch( this->_info._bits_per_pixel )
+        {
+            case 1:
+            {
+                this->_scanline_length = ( this->_info._width * num_channels< rgba8_view_t >::value + 3 ) & ~3;
+
+                read_palette();
+                _buffer.resize( _pitch );
+
+                _read_function = boost::mem_fn( &this_t::read_1_bit_row );
+
+                break;
+            }
+
+            case 4:
+            {
+				switch( this->_info._compression )
+				{
+				    case bmp_compression::_rle4:
+                    {
+                        io_error( "Cannot read run-length encoded images in iterator mode. Try to read as whole image." );
+
+                        break;
+                    }
+
+				    case bmp_compression::_rgb :
+                    {
+                        this->_scanline_length = ( this->_info._width * num_channels< rgba8_view_t >::value + 3 ) & ~3;
+
+                        read_palette();
+                        _buffer.resize( _pitch );
+
+                        _read_function = boost::mem_fn( &this_t::read_4_bits_row );
+
+                        break;
+                    }
+
+				    default:
+                    {
+                        io_error( "Unsupported compression mode in BMP file." );
+                    }
+                }
+
+                break;
+            }
+
+            case 8:
+            {
+				switch( this->_info._compression )
+				{
+				    case bmp_compression::_rle8:
+                    {
+                        io_error( "Cannot read run-length encoded images in iterator mode. Try to read as whole image." );
+
+                        break;
+                    }
+				    case bmp_compression::_rgb:
+                    {
+                        this->_scanline_length = ( this->_info._width * num_channels< rgba8_view_t >::value + 3 ) & ~3;
+
+                        read_palette();
+                        _buffer.resize( _pitch );
+
+                        _read_function = boost::mem_fn( &this_t::read_8_bits_row );
+
+                        break;
+                    }
+
+				    default: { io_error( "Unsupported compression mode in BMP file." ); break; }
+                }
+
+                break;
+            }
+
+            case 15:
+            case 16:
+            {
+                this->_scanline_length = ( this->_info._width * num_channels< rgb8_view_t >::value + 3 ) & ~3;
+
+                _buffer.resize( _pitch );
+
+                if( this->_info._compression == bmp_compression::_bitfield )
+                {
+                    this->_mask.red.mask    = this->_io_dev.read_uint32();
+                    this->_mask.green.mask  = this->_io_dev.read_uint32();
+                    this->_mask.blue.mask   = this->_io_dev.read_uint32();
+
+                    this->_mask.red.width   = detail::count_ones( this->_mask.red.mask   );
+                    this->_mask.green.width = detail::count_ones( this->_mask.green.mask );
+                    this->_mask.blue.width  = detail::count_ones( this->_mask.blue.mask  );
+
+                    this->_mask.red.shift   = detail::trailing_zeros( this->_mask.red.mask   );
+                    this->_mask.green.shift = detail::trailing_zeros( this->_mask.green.mask );
+                    this->_mask.blue.shift  = detail::trailing_zeros( this->_mask.blue.mask  );
+                }
+                else if( this->_info._compression == bmp_compression::_rgb )
+                {
+                    switch( this->_info._bits_per_pixel )
+                    {
+                        case 15:
+                        case 16:
+                        {
+                            this->_mask.red.mask   = 0x007C00; this->_mask.red.width   = 5; this->_mask.red.shift   = 10;
+                            this->_mask.green.mask = 0x0003E0; this->_mask.green.width = 5; this->_mask.green.shift =  5;
+                            this->_mask.blue.mask  = 0x00001F; this->_mask.blue.width  = 5; this->_mask.blue.shift  =  0;
+
+                            break;
+                        }
+
+                        case 24:
+                        case 32:
+                        {
+                            this->_mask.red.mask   = 0xFF0000; this->_mask.red.width   = 8; this->_mask.red.shift   = 16;
+                            this->_mask.green.mask = 0x00FF00; this->_mask.green.width = 8; this->_mask.green.shift =  8;
+                            this->_mask.blue.mask  = 0x0000FF; this->_mask.blue.width  = 8; this->_mask.blue.shift  =  0;
+
+                            break;
+                        }
+                    }
+                }
+                else
+                {
+                    io_error( "Unsupported BMP compression." );
+                }
+
+
+                _read_function = boost::mem_fn( &this_t::read_15_bits_row );
+
+                break;
+            }
+
+            case 24:
+            {
+                this->_scanline_length = ( this->_info._width * num_channels< rgb8_view_t >::value + 3 ) & ~3;
+                _read_function = boost::mem_fn( &this_t::read_row );
+
+                break;
+            }
+
+            case 32:
+            {
+                this->_scanline_length = ( this->_info._width * num_channels< rgba8_view_t >::value + 3 ) & ~3;
+                _read_function = boost::mem_fn( &this_t::read_row );
+
+                break;
+            }
+
+            default:
+            {
+                io_error( "Unsupported bits per pixel." );
+            }
+        }
+    }
+
+    void read_palette()
+    {
+        if( this->_palette.size() > 0 )
+        {
+            // palette has been read already.
+            return;
+        }
+
+        int entries = this->_info._num_colors;
+
+        if( entries == 0 )
+        {
+            entries = 1 << this->_info._bits_per_pixel;
+        }
+
+        this->_palette.resize( entries );
+
+        for( int i = 0; i < entries; ++i )
+        {
+            get_color( this->_palette[i], blue_t()  ) = this->_io_dev.read_uint8();
+            get_color( this->_palette[i], green_t() ) = this->_io_dev.read_uint8();
+            get_color( this->_palette[i], red_t()   ) = this->_io_dev.read_uint8();
+
+            // there are 4 entries when windows header
+            // but 3 for os2 header
+            if( this->_info._header_size == bmp_header_size::_win32_info_size )
+            {
+                this->_io_dev.read_uint8();
+            }
+
+        } // for
+    }
+
+    template< typename View >
+    void read_bit_row( byte_t* dst )
+    {
+        typedef View src_view_t;
+        typedef rgba8_image_t::view_t dst_view_t;
+
+        src_view_t src_view = interleaved_view( this->_info._width
+                                              , 1
+                                              , (typename src_view_t::x_iterator) &_buffer.front()
+                                              , this->_pitch
+                                              );
+
+        dst_view_t dst_view = interleaved_view( this->_info._width
+                                              , 1
+                                              , (typename dst_view_t::value_type*) dst
+                                              , num_channels< dst_view_t >::value * this->_info._width
+                                              );
+
+
+        typename src_view_t::x_iterator src_it = src_view.row_begin( 0 );
+        typename dst_view_t::x_iterator dst_it = dst_view.row_begin( 0 );
+
+        for( dst_view_t::x_coord_t i = 0
+           ; i < this->_info._width
+           ; ++i, src_it++, dst_it++
+           )
+        {
+            unsigned char c = get_color( *src_it, gray_color_t() );
+            *dst_it = this->_palette[c];
+        }
+    }
+
+    // Read 1 bit image. The colors are encoded by an index.
+    void read_1_bit_row( byte_t* dst )
+    {
+        this->_io_dev.read( &_buffer.front(), _pitch );
+        _mirror_bits( _buffer );
+
+        read_bit_row< gray1_image_t::view_t >( dst );
+    }
+
+    // Read 4 bits image. The colors are encoded by an index.
+    void read_4_bits_row( byte_t* dst )
+    {
+        this->_io_dev.read( &_buffer.front(), _pitch );
+        _swap_half_bytes( _buffer );
+
+        read_bit_row< gray4_image_t::view_t >( dst );
+    }
+
+    /// Read 8 bits image. The colors are encoded by an index.
+    void read_8_bits_row( byte_t* dst )
+    {
+        this->_io_dev.read( &_buffer.front(), _pitch );
+
+        read_bit_row< gray8_image_t::view_t >( dst );
+    }
+
+    /// Read 15 or 16 bits image.
+    void read_15_bits_row( byte_t* dst )
+    {
+        typedef rgb8_view_t dst_view_t;
+        typedef typename dst_view_t::x_iterator it_t;
+
+        dst_view_t dst_view = interleaved_view( this->_info._width
+                                              , 1
+                                              , (typename dst_view_t::value_type*) dst
+                                              , this->_pitch
+                                              );
+
+        typename dst_view_t::x_iterator dst_it = dst_view.row_begin( 0 );
+
+        //
+        byte_t* src = &_buffer.front();
+        this->_io_dev.read( src, _pitch );
+
+        for( dst_view_t::x_coord_t i = 0
+           ; i < this->_info._width
+           ; ++i, src += 2
+           )
+        {
+            int p = ( src[1] << 8 ) | src[0];
+
+            int r = ((p & this->_mask.red.mask)   >> this->_mask.red.shift)   << (8 - this->_mask.red.width);
+            int g = ((p & this->_mask.green.mask) >> this->_mask.green.shift) << (8 - this->_mask.green.width);
+            int b = ((p & this->_mask.blue.mask)  >> this->_mask.blue.shift)  << (8 - this->_mask.blue.width);
+
+            get_color( dst_it[i], red_t()   ) = static_cast< byte_t >( r );
+            get_color( dst_it[i], green_t() ) = static_cast< byte_t >( g );
+            get_color( dst_it[i], blue_t()  ) = static_cast< byte_t >( b );
+        }
+    }
+
+    void read_row( byte_t* dst )
+    {
+        this->_io_dev.read( dst, _pitch );
+    }
+
+private:
+
+    // the row pitch must be multiple of 4 bytes
+    int _pitch;
+
+    std::vector< byte_t > _buffer;
+    detail::mirror_bits    < std::vector< byte_t >, mpl::true_ > _mirror_bits;
+    detail::swap_half_bytes< std::vector< byte_t >, mpl::true_ > _swap_half_bytes;
+
+    boost::function< void ( this_t*, byte_t* ) > _read_function;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_IO_SCANLINE_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/supported_types.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/supported_types.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,147 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_SUPPORTED_TYPES_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_SUPPORTED_TYPES_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief 
+/// \author Christian Henning \n
+///
+/// \date   2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/mpl/not.hpp>
+#include <boost/type_traits/is_same.hpp>
+
+#include <boost/gil/channel.hpp>
+#include <boost/gil/color_base.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+
+namespace boost { namespace gil { namespace detail {
+
+// Read support
+
+template< typename Channel
+        , typename ColorSpace
+        >
+struct bmp_read_support : read_support_false
+{
+    static const bmp_bits_per_pixel::type bpp = 0;
+};
+
+template< typename BitField
+        , bool     Mutable
+        >
+struct bmp_read_support< packed_dynamic_channel_reference< BitField
+                                                         , 1
+                                                         , Mutable
+                                                         >
+                       , gray_t
+                       > : read_support_true
+{
+    static const bmp_bits_per_pixel::type bpp = 1;
+};
+
+template< typename BitField
+        , bool     Mutable
+        >
+struct bmp_read_support< packed_dynamic_channel_reference< BitField
+                                                         , 4
+                                                         , Mutable
+                                                         >
+                       , gray_t
+                       > : read_support_true
+{
+    static const bmp_bits_per_pixel::type bpp = 4;
+};
+
+
+template<>
+struct bmp_read_support< bits8
+                       , gray_t
+                       > : read_support_true
+{
+    static const bmp_bits_per_pixel::type bpp = 8;
+};
+                      
+
+
+template<>
+struct bmp_read_support< bits8
+                       , rgb_t
+                       > : read_support_true
+{
+    static const bmp_bits_per_pixel::type bpp = 24;
+};
+
+
+template<>
+struct bmp_read_support< bits8
+                       , rgba_t
+                       > : read_support_true
+{
+    static const bmp_bits_per_pixel::type bpp = 32;
+};
+
+
+// Write support
+
+template< typename Channel
+        , typename ColorSpace
+        >
+struct bmp_write_support : write_support_false
+{};
+
+template<>
+struct bmp_write_support< bits8
+                        , rgb_t
+                        > : write_support_true {};
+
+template<>
+struct bmp_write_support< bits8
+                        , rgba_t
+                        > : write_support_true {};
+
+} // namespace detail
+
+
+template< typename Pixel >
+struct is_read_supported< Pixel
+                        , bmp_tag
+                        >
+    : mpl::bool_< detail::bmp_read_support< typename channel_type< Pixel >::type
+                                          , typename color_space_type< Pixel >::type
+                                          >::is_supported 
+                >
+{
+    typedef detail::bmp_read_support< typename channel_type< Pixel >::type
+                                    , typename color_space_type< Pixel >::type
+                                    > parent_t;
+
+    static const typename bmp_bits_per_pixel::type bpp = parent_t::bpp;
+};
+
+template< typename Pixel >
+struct is_write_supported< Pixel
+                         , bmp_tag
+                         >
+    : mpl::bool_< detail::bmp_write_support< typename channel_type< Pixel >::type
+                                           , typename color_space_type< Pixel >::type
+                                           >::is_supported
+                > {};
+
+} // namespace gil
+} // namespace boost
+
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_SUPPORTED_TYPES_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,222 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_IO_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_IO_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <vector>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+
+#include <boost/gil/extension/io_new/bmp_tags.hpp>
+
+#include "writer_backend.hpp"
+
+namespace boost { namespace gil {
+
+namespace detail {
+
+struct bmp_write_is_supported
+{
+    template< typename View >
+    struct apply
+        : public is_write_supported< typename get_pixel_type< View >::type
+                                   , bmp_tag
+                                   >
+    {};
+};
+
+template < int N > struct get_bgr_cs {};
+template <> struct get_bgr_cs< 1 > { typedef gray8_view_t type; };
+template <> struct get_bgr_cs< 3 > { typedef bgr8_view_t type;  };
+template <> struct get_bgr_cs< 4 > { typedef bgra8_view_t type; };
+
+} // namespace detail
+
+///
+/// BMP Writer
+///
+template< typename Device >
+class writer< Device
+            , bmp_tag
+            >
+    : public writer_backend< Device
+                           , bmp_tag
+                           >
+{
+public:
+
+    writer( const Device&                      io_dev
+          , const image_write_info< bmp_tag >& info 
+          )
+    : backend_t( io_dev
+                    , info
+                    )
+    {}
+
+    template<typename View>
+    void apply( const View& view )
+    {
+        write( view );
+    }
+
+private:
+
+    typedef writer_backend< Device, bmp_tag > backend_t;
+
+    template< typename View >
+    void write( const View& view )
+    {
+        typedef typename channel_type<
+                    typename get_pixel_type< View >::type >::type channel_t;
+
+        typedef typename color_space_type< View >::type color_space_t;
+
+        // check if supported
+/*
+        /// todo
+        if( bmp_read_write_support_private<channel_t, color_space_t>::channel != 8)
+        {
+            io_error("Input view type is incompatible with the image type");
+        }
+*/
+
+        // compute the file size
+        int bpp = num_channels< View >::value * 8;
+        int entries = 0;
+
+/*
+        /// @todo: Not supported for now. bit_aligned_images refer to indexed images
+        ///        in this context.
+        if( bpp <= 8 )
+        {
+            entries = 1 << bpp;
+        }
+*/
+
+        std::size_t spn = ( view.width() * num_channels< View >::value + 3 ) & ~3;
+        std::size_t ofs = bmp_header_size::_size 
+                        + bmp_header_size::_win32_info_size 
+                        + entries * 4;
+
+        std::size_t siz = ofs + spn * view.height();
+
+        // write the BMP file header
+        this->_io_dev.write_uint16( bmp_signature );
+        this->_io_dev.write_uint32( (uint32_t) siz );
+        this->_io_dev.write_uint16( 0 );
+        this->_io_dev.write_uint16( 0 );
+        this->_io_dev.write_uint32( (uint32_t) ofs );
+
+        // writes Windows information header
+        this->_io_dev.write_uint32( bmp_header_size::_win32_info_size );
+        this->_io_dev.write_uint32( static_cast< uint32_t >( view.width()  ));
+        this->_io_dev.write_uint32( static_cast< uint32_t >( view.height() ));
+        this->_io_dev.write_uint16( 1 );
+        this->_io_dev.write_uint16( static_cast< uint16_t >( bpp ));
+        this->_io_dev.write_uint32( bmp_compression::_rgb );
+        this->_io_dev.write_uint32( 0 );
+        this->_io_dev.write_uint32( 0 );
+        this->_io_dev.write_uint32( 0 );
+        this->_io_dev.write_uint32( entries );
+        this->_io_dev.write_uint32( 0 );
+
+        write_image< View
+                   , typename detail::get_bgr_cs< num_channels< View >::value >::type
+                   >( view, spn );
+    }
+
+
+    template< typename View
+            , typename BMP_View
+            >
+    void write_image( const View&       view
+                    , const std::size_t spn
+                    )
+    {
+        byte_vector_t buffer( spn );
+        std::fill( buffer.begin(), buffer.end(), 0 );
+
+
+        BMP_View row = interleaved_view( view.width()
+                                       , 1
+                                       , (typename BMP_View::value_type*) &buffer.front()
+                                       , spn
+                                       );
+
+        for( typename View::y_coord_t y = view.height() - 1; y > -1; --y  )
+        {
+            copy_pixels( subimage_view( view
+                                      , 0
+                                      , (int) y
+                                      , (int) view.width()
+                                      , 1
+                                      )
+                       , row
+                       );
+
+            this->_io_dev.write( &buffer.front(), spn );
+        }
+
+    }
+};
+
+///
+/// BMP Dynamic Image Writer
+///
+template< typename Device >
+class dynamic_image_writer< Device
+                          , bmp_tag
+                          >
+    : public writer< Device
+                   , bmp_tag
+                   >
+{
+    typedef writer< Device
+                  , bmp_tag
+                  > parent_t;
+
+public:
+
+    dynamic_image_writer( const Device&                      io_dev
+                        , const image_write_info< bmp_tag >& info
+                        )
+    : parent_t( io_dev
+              , info
+              )
+    {}
+
+    template< typename Views >
+    void apply( const any_image_view< Views >& views )
+    {
+        detail::dynamic_io_fnobj< detail::bmp_write_is_supported
+                                , parent_t
+                                > op( this );
+
+        apply_operation( views
+                       , op
+                       );
+    }
+};
+
+
+} // gil
+} // boost
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_IO_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/writer_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/bmp/writer_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,57 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_IO_WRITER_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_IO_WRITER_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/bmp_tags.hpp>
+
+namespace boost { namespace gil {
+
+///
+/// BMP Writer Backend
+///
+template< typename Device >
+struct writer_backend< Device
+                     , bmp_tag
+                     >
+{
+public:
+
+    typedef bmp_tag format_tag_t;
+
+public:
+
+    writer_backend( const Device&                      io_dev
+                  , const image_write_info< bmp_tag >& info
+                  )
+    : _io_dev( io_dev )
+    , _info  ( info   )
+    {}
+
+public:
+
+    Device _io_dev;
+
+    image_write_info< bmp_tag > _info;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_IO_WRITER_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/base.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/base.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,37 @@
+/*
+    Copyright 2010 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_JPEG_IO_BASE_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_JPEG_IO_BASE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date   2010 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+#include <boost/gil/extension/io_new/jpeg_tags.hpp>
+
+namespace boost { namespace gil { 
+
+class jpeg_io_base
+{
+
+protected:
+
+    jpeg_error_mgr _jerr;
+    jmp_buf        _mark;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_JPEG_IO_BASE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/is_allowed.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/is_allowed.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,54 @@
+/*
+    Copyright 2009 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_IO_IS_ALLOWED_HPP
+#define BOOST_GIL_EXTENSION_IO_JPEG_IO_IS_ALLOWED_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost { namespace gil { namespace detail {
+
+template< typename View >
+bool is_allowed( const image_read_info< jpeg_tag >& info
+               , mpl::true_   // is read_and_no_convert
+               )
+{
+    if( info._color_space == JCS_YCbCr )
+    {
+        // We read JCS_YCbCr files as rgb.
+        return ( is_read_supported< typename View::value_type
+                                  , jpeg_tag
+                                  >::_color_space == JCS_RGB );
+    }
+
+    return ( is_read_supported< typename View::value_type
+                              , jpeg_tag
+                              >::_color_space == info._color_space );
+}
+
+template< typename View >
+bool is_allowed( const image_read_info< jpeg_tag >& /* info */
+               , mpl::false_  // is read_and_convert
+               )
+{
+    return true;
+}
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_IO_IS_ALLOWED_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,321 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_IO_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_JPEG_IO_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <csetjmp>
+#include <vector>
+#include <boost/gil/extension/io_new/jpeg_tags.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+    
+#include "base.hpp"
+#include "is_allowed.hpp"
+
+namespace boost { namespace gil {
+
+///
+/// JPEG Reader
+///
+template< typename Device
+        , typename ConversionPolicy
+        >
+class reader< Device
+            , jpeg_tag
+            , ConversionPolicy
+            >
+    : public reader_base< jpeg_tag
+                        , ConversionPolicy
+                        >
+    , public reader_backend< Device
+                           , jpeg_tag
+                           >
+{
+private:
+
+    typedef reader< Device
+                  , jpeg_tag
+                  , ConversionPolicy
+                  > this_t;
+
+    typedef typename ConversionPolicy::color_converter_type cc_t;
+
+public:
+
+    typedef reader_backend< Device, jpeg_tag > backend_t;
+
+public:
+
+    //
+    // Constructor
+    //
+    reader( const Device&                          io_dev
+          , const image_read_settings< jpeg_tag >& settings
+          )
+    : reader_base< jpeg_tag
+                 , ConversionPolicy
+                 >()
+
+    , backend_t( io_dev
+               , settings
+               )
+    {}
+
+    //
+    // Constructor
+    //
+    reader( const Device&                                          io_dev
+          , const typename ConversionPolicy::color_converter_type& cc
+          , const image_read_settings< jpeg_tag >&                 settings
+          )
+    : reader_base< jpeg_tag
+                 , ConversionPolicy
+                 >( cc )
+    , backend_t( io_dev
+               , settings
+               )
+    {}
+
+    template<typename View>
+    void apply( const View& view )
+    {
+        // Fire exception in case of error.
+        if( setjmp( this->_mark ))
+        {
+            this->raise_error();
+        }
+
+        this->get()->dct_method = this->_settings._dct_method;
+
+        typedef typename is_same< ConversionPolicy
+                                , detail::read_and_no_convert
+                                >::type is_read_and_convert_t;
+
+        io_error_if( !detail::is_allowed< View >( this->_info
+                                                , is_read_and_convert_t()
+                                                )
+                   , "Image types aren't compatible."
+                   );
+
+        if( jpeg_start_decompress( this->get() ) == false )
+        {
+            io_error( "Cannot start decompression." );
+        }
+
+        switch( this->_info._color_space )
+        {
+            case JCS_GRAYSCALE:
+            {
+                this->_scanline_length = this->_info._width;
+                read_rows< gray8_pixel_t >( view );
+
+                break;
+            }
+
+            case JCS_RGB:
+            //!\todo add Y'CbCr? We loose image quality when reading JCS_YCbCr as JCS_RGB
+            case JCS_YCbCr:
+            {
+                this->_scanline_length = this->_info._width * num_channels< rgb8_view_t >::value;
+
+                read_rows< rgb8_pixel_t  >( view ); 
+                break;
+            }
+
+            case JCS_CMYK:
+            //!\todo add Y'CbCrK? We loose image quality when reading JCS_YCCK as JCS_CMYK
+            case JCS_YCCK:
+            {
+                this->get()->out_color_space = JCS_CMYK;
+                this->_scanline_length = this->_info._width * num_channels< cmyk8_view_t >::value;
+
+                read_rows< cmyk8_pixel_t >( view );
+
+                break;
+            }
+            default: { io_error( "Unsupported jpeg color space." ); }
+        }
+
+        jpeg_finish_decompress ( this->get() );
+    }
+
+private:
+
+    template< typename ImagePixel
+            , typename View
+            >
+    void read_rows( const View& view )
+    {
+        typedef std::vector<ImagePixel> buffer_t;
+        buffer_t buffer( this->_info._width );
+
+        // In case of an error we'll jump back to here and fire an exception.
+        // @todo Is the buffer above cleaned up when the exception is thrown?
+        //       The strategy right now is to allocate necessary memory before
+        //       the setjmp.
+        if( setjmp( this->_mark ))
+        {
+            this->raise_error();
+        }
+
+
+        JSAMPLE *row_adr = reinterpret_cast< JSAMPLE* >( &buffer[0] );
+
+        //Skip scanlines if necessary.
+        for( int y = 0; y <  this->_settings._top_left.y; ++y )
+        {
+            io_error_if( jpeg_read_scanlines( this->get()
+                                            , &row_adr
+                                            , 1
+                                            ) !=1
+                       , "jpeg_read_scanlines: fail to read JPEG file"
+                       );
+        }
+
+        // Read data.
+        for( int y = 0; y < view.height(); ++y )
+        {
+            io_error_if( jpeg_read_scanlines( this->get()
+                                            , &row_adr
+                                            , 1
+                                            ) != 1
+                       , "jpeg_read_scanlines: fail to read JPEG file"
+                       );
+
+            typename buffer_t::iterator beg = buffer.begin() + this->_settings._top_left.x;
+            typename buffer_t::iterator end = beg + this->_settings._dim.x;
+
+            this->_cc_policy.read( beg
+                                 , end
+                                 , view.row_begin( y )
+                                 );
+        }
+
+        //@todo: There might be a better way to do that.
+        while( this->get()->output_scanline < this->get()->image_height )
+        {
+            io_error_if( jpeg_read_scanlines( this->get()
+                                            , &row_adr
+                                            , 1
+                                            ) !=1
+                       , "jpeg_read_scanlines: fail to read JPEG file"
+                       );
+        }
+
+    }
+};
+
+namespace detail { 
+
+struct jpeg_type_format_checker
+{
+    jpeg_type_format_checker( jpeg_color_space::type color_space )
+    : _color_space( color_space )
+    {}
+
+    template< typename Image >
+    bool apply()
+    {
+        return is_read_supported< typename get_pixel_type< typename Image::view_t >::type
+                                , jpeg_tag
+                                >::_color_space == _color_space;
+    }
+
+private:
+
+    jpeg_color_space::type _color_space;
+};
+
+struct jpeg_read_is_supported
+{
+    template< typename View >
+    struct apply : public is_read_supported< typename get_pixel_type< View >::type
+                                           , jpeg_tag
+                                           >
+    {};
+};
+
+} // namespace detail
+
+///
+/// JPEG Dynamic Reader
+///
+template< typename Device >
+class dynamic_image_reader< Device
+                          , jpeg_tag
+                          >
+    : public reader< Device
+                   , jpeg_tag
+                   , detail::read_and_no_convert
+                   >
+{
+    typedef reader< Device
+                  , jpeg_tag
+                  , detail::read_and_no_convert
+                  > parent_t;
+
+public:
+
+    dynamic_image_reader( const Device&                          io_dev
+                        , const image_read_settings< jpeg_tag >& settings
+                        )
+    : parent_t( io_dev
+              , settings
+              )
+    {}
+
+    template< typename Images >
+    void apply( any_image< Images >& images )
+    {
+        detail::jpeg_type_format_checker format_checker( this->_info._color_space != JCS_YCbCr
+                                                       ? this->_info._color_space
+                                                       : JCS_RGB
+                                                       );
+
+        if( !construct_matched( images
+                              , format_checker
+                              ))
+        {
+            io_error( "No matching image type between those of the given any_image and that of the file" );
+        }
+        else
+        {
+            init_image( images
+                      , this->_settings
+                      );
+
+            detail::dynamic_io_fnobj< detail::jpeg_read_is_supported
+                                    , parent_t
+                                    > op( this );
+
+            apply_operation( view( images )
+                           , op
+                           );
+        }
+    }
+};
+
+} // gil
+} // boost
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_IO_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/reader_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/reader_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,294 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_IO_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_JPEG_IO_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/jpeg_tags.hpp>
+
+namespace boost { namespace gil {
+
+namespace detail { 
+
+///
+/// Wrapper for libjpeg's decompress object. Implements value semantics.
+///
+struct jpeg_decompress_wrapper
+{
+protected:
+
+    typedef boost::shared_ptr< jpeg_decompress_struct > jpeg_decompress_ptr_t;
+
+protected:
+
+    ///
+    /// Default Constructor
+    ///
+    jpeg_decompress_wrapper()
+    : _jpeg_decompress_ptr( new jpeg_decompress_struct()
+                          , jpeg_decompress_deleter
+                          )
+    {}
+
+    jpeg_decompress_struct*       get()       { return _jpeg_decompress_ptr.get(); }
+    const jpeg_decompress_struct* get() const { return _jpeg_decompress_ptr.get(); }
+
+private:
+
+    static void jpeg_decompress_deleter( jpeg_decompress_struct* jpeg_decompress_ptr )
+    {
+        if( jpeg_decompress_ptr )
+        {
+            jpeg_destroy_decompress( jpeg_decompress_ptr );
+
+            delete jpeg_decompress_ptr;
+            jpeg_decompress_ptr = NULL;
+        }
+    }
+
+private:
+
+   jpeg_decompress_ptr_t _jpeg_decompress_ptr;
+
+};
+
+} // namespace detail
+
+///
+/// JPEG Backend
+///
+template< typename Device >
+struct reader_backend< Device
+                     , jpeg_tag
+                     >
+    : public jpeg_io_base
+    , public detail::jpeg_decompress_wrapper
+{
+public:
+
+    typedef jpeg_tag format_tag_t;
+
+public:
+    //
+    // Constructor
+    //
+    reader_backend( const Device&                          io_dev
+                  , const image_read_settings< jpeg_tag >& settings
+                  )
+    : _io_dev( io_dev )
+    , _settings( settings )
+    , _info()
+
+    , _scanline_length( 0 )
+    {
+        get()->err         = jpeg_std_error( &_jerr );
+        get()->client_data = this;
+
+        // Error exit handler: does not return to caller.
+        _jerr.error_exit = &reader_backend::error_exit;
+
+        if( setjmp( _mark ))
+        {
+            raise_error();
+        }
+
+        _src._jsrc.bytes_in_buffer   = 0;
+        _src._jsrc.next_input_byte   = buffer;
+        _src._jsrc.init_source       = reinterpret_cast< void(*)   ( j_decompress_ptr )>( &reader_backend< Device, jpeg_tag >::init_device );
+        _src._jsrc.fill_input_buffer = reinterpret_cast< boolean(*)( j_decompress_ptr )>( &reader_backend< Device, jpeg_tag >::fill_buffer );
+        _src._jsrc.skip_input_data   = reinterpret_cast< void(*)   ( j_decompress_ptr
+                                                                   , long num_bytes
+                                                                   ) >( &reader_backend< Device, jpeg_tag >::skip_input_data );
+        _src._jsrc.term_source       = reinterpret_cast< void(*)   ( j_decompress_ptr ) >( &reader_backend< Device, jpeg_tag >::close_device );
+        _src._jsrc.resync_to_restart = jpeg_resync_to_restart;
+        _src._this = this;
+
+        jpeg_create_decompress( get() );
+
+        get()->src = &_src._jsrc;
+
+        jpeg_read_header( get()
+                        , TRUE
+                        );
+
+        io_error_if( get()->data_precision != 8
+                   , "Image file is not supported."
+                   );
+
+        //
+        read_header();
+
+        //
+        if( _settings._dim.x == 0 )
+        {
+            _settings._dim.x = _info._width;
+        }
+
+        if( _settings._dim.y == 0 )
+        {
+            _settings._dim.y = _info._height;
+        }
+    }
+
+    /// Read image header.
+    void read_header()
+    {
+        _info._width          = get()->image_width;
+        _info._height         = get()->image_height;
+        _info._num_components = get()->num_components;
+        _info._color_space    = get()->jpeg_color_space;
+        _info._data_precision = get()->data_precision;
+
+        _info._density_unit = get()->density_unit;
+        _info._x_density    = get()->X_density;
+        _info._y_density    = get()->Y_density;
+
+        // obtain real world dimensions
+        // taken from https://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/read.cpp#cl-62
+
+        jpeg_calc_output_dimensions( get() );
+
+        double units_conversion = 0;
+        if (get()->density_unit == 1) // dots per inch
+        {
+            units_conversion = 25.4; // millimeters in an inch
+        }
+        else if (get()->density_unit == 2) // dots per cm
+        {
+            units_conversion = 10; // millimeters in a centimeter
+        }
+
+        _info._pixel_width_mm  = get()->X_density ? (get()->output_width  / double(get()->X_density)) * units_conversion : 0;
+        _info._pixel_height_mm = get()->Y_density ? (get()->output_height / double(get()->Y_density)) * units_conversion : 0;
+    }
+
+    /// Return image read settings.
+    const image_read_settings< jpeg_tag >& get_settings()
+    {
+        return _settings;
+    }
+    
+    /// Return image header info.
+    const image_read_info< jpeg_tag >& get_info()
+    {
+        return _info;
+    }
+
+protected:
+
+    // Taken from jerror.c
+    /*
+     * Error exit handler: must not return to caller.
+     *
+     * Applications may override this if they want to get control back after
+     * an error.  Typically one would longjmp somewhere instead of exiting.
+     * The setjmp buffer can be made a private field within an expanded error
+     * handler object.  Note that the info needed to generate an error message
+     * is stored in the error object, so you can generate the message now or
+     * later, at your convenience.
+     * You should make sure that the JPEG object is cleaned up (with jpeg_abort
+     * or jpeg_destroy) at some point.
+     */
+    static void error_exit( j_common_ptr cinfo )
+    {
+        reader_backend< Device, jpeg_tag >* mgr = reinterpret_cast< reader_backend< Device, jpeg_tag >* >( cinfo->client_data );
+
+        longjmp( mgr->_mark, 1 );
+    }
+
+    void raise_error()
+    {
+        // we clean up in the destructor
+
+        io_error( "jpeg is invalid." );
+    }
+
+private:
+
+    // See jdatasrc.c for default implementation for the following static member functions.
+
+    static void init_device( jpeg_decompress_struct* cinfo )
+    {
+        gil_jpeg_source_mgr* src = reinterpret_cast< gil_jpeg_source_mgr* >( cinfo->src );
+        src->_jsrc.bytes_in_buffer = 0;
+        src->_jsrc.next_input_byte = src->_this->buffer;
+    }
+
+    static boolean fill_buffer( jpeg_decompress_struct* cinfo )
+    {
+        gil_jpeg_source_mgr* src = reinterpret_cast< gil_jpeg_source_mgr* >( cinfo->src );
+        size_t count = src->_this->_io_dev.read(src->_this->buffer, sizeof(src->_this->buffer) );
+
+        if( count <= 0 )
+        {
+            // libjpeg does that: adding an EOF marker
+            src->_this->buffer[0] = (JOCTET) 0xFF;
+            src->_this->buffer[1] = (JOCTET) JPEG_EOI;
+            count = 2;
+        }
+
+        src->_jsrc.next_input_byte = src->_this->buffer;
+        src->_jsrc.bytes_in_buffer = count;
+
+        return TRUE;
+    }
+
+    static void skip_input_data( jpeg_decompress_struct * cinfo, long num_bytes  )
+    {
+        gil_jpeg_source_mgr* src = reinterpret_cast< gil_jpeg_source_mgr* >( cinfo->src );
+
+        if( num_bytes > 0 )
+        {
+            while( num_bytes > long( src->_jsrc.bytes_in_buffer ))
+            {
+                num_bytes -= (long) src->_jsrc.bytes_in_buffer;
+                fill_buffer( cinfo );
+            }
+
+            src->_jsrc.next_input_byte += num_bytes;
+            src->_jsrc.bytes_in_buffer -= num_bytes;
+        }
+    }
+
+    static void close_device( jpeg_decompress_struct* ) {}
+
+public:
+
+    Device _io_dev;
+
+    image_read_settings< jpeg_tag > _settings;
+    image_read_info< jpeg_tag >     _info;
+
+    std::size_t _scanline_length;
+
+    struct gil_jpeg_source_mgr
+    {
+        jpeg_source_mgr _jsrc;
+        reader_backend* _this;
+    };
+
+    gil_jpeg_source_mgr _src;
+
+    // libjpeg default is 4096 - see jdatasrc.c
+    JOCTET buffer[4096];
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_IO_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/scanline_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/scanline_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,146 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_IO_SCANLINE_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_JPEG_IO_SCANLINE_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <csetjmp>
+#include <vector>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+
+#include "reader_backend.hpp"
+#include "base.hpp"
+#include "is_allowed.hpp"
+
+namespace boost { namespace gil {
+
+///
+/// JPEG Scanline Reader
+///
+template< typename Device >
+class scanline_reader< Device
+                     , jpeg_tag
+                     >
+    : public reader_backend< Device
+                           , jpeg_tag
+                           >
+{
+public:
+
+    typedef reader_backend< Device, jpeg_tag > backend_t;
+
+public:
+    scanline_reader( Device&                                device
+                   , const image_read_settings< jpeg_tag >& settings
+                   )
+    : reader_backend< Device
+                    , jpeg_tag
+                     >( device
+                      , settings
+                      )
+    {
+        initialize();
+    }
+
+    void read( byte_t* dst, int pos )
+    {
+        // Fire exception in case of error.
+        if( setjmp( this->_mark )) { this->raise_error(); }
+
+        // read data
+        read_scanline( dst );
+    }
+
+    /// Skip over a scanline.
+    void skip( byte_t* dst, int )
+    {
+        // Fire exception in case of error.
+        if( setjmp( this->_mark )) { this->raise_error(); }
+
+        // read data
+        read_scanline( dst );
+    }
+
+    void clean_up() {}
+
+private:
+
+    void initialize()
+    {
+        this->get()->dct_method = this->_settings._dct_method;
+
+        io_error_if( jpeg_start_decompress( this->get() ) == false
+                    , "Cannot start decompression." );
+
+        switch( this->_info._color_space )
+        {
+            case JCS_GRAYSCALE:
+            {
+                this->_scanline_length = this->_info._width;
+
+                break;
+            }
+
+            case JCS_RGB:
+            //!\todo add Y'CbCr? We loose image quality when reading JCS_YCbCr as JCS_RGB
+            case JCS_YCbCr:
+            {
+                this->_scanline_length = this->_info._width * num_channels< rgb8_view_t >::value;
+
+                break;
+            }
+
+
+            case JCS_CMYK:
+            //!\todo add Y'CbCrK? We loose image quality when reading JCS_YCCK as JCS_CMYK
+            case JCS_YCCK:
+            {
+                this->get()->out_color_space = JCS_CMYK;
+                this->_scanline_length = this->_info._width * num_channels< cmyk8_view_t >::value;
+
+                break;
+            }
+
+            default: { io_error( "Unsupported jpeg color space." ); }
+        }
+    }
+
+    void read_scanline( byte_t* dst )
+    {
+        JSAMPLE *row_adr = reinterpret_cast< JSAMPLE* >( dst );
+
+        // Read data.
+        io_error_if( jpeg_read_scanlines( this->get()
+                                        , &row_adr
+                                        , 1
+                                        ) != 1
+                    , "jpeg_read_scanlines: fail to read JPEG file"
+                    );
+
+    }
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_IO_SCANLINE_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/supported_types.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/supported_types.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,121 @@
+/*
+    Copyright 2007-2008 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_SUPPORTED_TYPES_HPP
+#define BOOST_GIL_EXTENSION_IO_JPEG_SUPPORTED_TYPES_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/mpl/not.hpp>
+#include <boost/type_traits/is_same.hpp>
+
+#include <boost/gil/channel.hpp>
+#include <boost/gil/color_base.hpp>
+
+namespace boost { namespace gil { namespace detail {
+
+// Read support
+
+template< jpeg_color_space::type ColorSpace >
+struct jpeg_rw_support_base
+{
+    static const jpeg_color_space::type _color_space = ColorSpace;
+};
+
+template< typename Channel
+        , typename ColorSpace
+        >
+struct jpeg_read_support : read_support_false
+                         , jpeg_rw_support_base< JCS_UNKNOWN > {};
+
+template<>
+struct jpeg_read_support< bits8
+                        , rgb_t
+                        > : read_support_true
+                          , jpeg_rw_support_base< JCS_RGB > {};
+
+template<>
+struct jpeg_read_support< bits8
+                        , cmyk_t
+                        > : read_support_true
+                          , jpeg_rw_support_base< JCS_CMYK > {};
+
+template<>
+struct jpeg_read_support< bits8
+                        , gray_t
+                        > : read_support_true
+                          , jpeg_rw_support_base< JCS_GRAYSCALE > {};
+
+// Write support
+
+template< typename Channel
+        , typename ColorSpace
+        >
+struct jpeg_write_support : write_support_false
+                          , jpeg_rw_support_base< JCS_UNKNOWN > {};
+
+template<>
+struct jpeg_write_support< bits8
+                         , gray_t
+                         > : write_support_true
+                          , jpeg_rw_support_base< JCS_GRAYSCALE > {};
+
+template<>
+struct jpeg_write_support< bits8
+                         , rgb_t
+                         > : write_support_true
+                          , jpeg_rw_support_base< JCS_RGB > {};
+
+template<>
+struct jpeg_write_support< bits8
+                         , cmyk_t
+                         > : write_support_true
+                          , jpeg_rw_support_base< JCS_CMYK > {};
+
+} // namespace detail
+
+template< typename Pixel >
+struct is_read_supported< Pixel
+                        , jpeg_tag
+                        > 
+    : mpl::bool_< detail::jpeg_read_support< typename channel_type< Pixel >::type
+                                           , typename color_space_type< Pixel >::type
+                                           >::is_supported
+                >
+{
+    typedef detail::jpeg_read_support< typename channel_type< Pixel >::type
+                                     , typename color_space_type< Pixel >::type
+                                     > parent_t;
+
+    static const typename jpeg_color_space::type _color_space = parent_t::_color_space;
+};
+
+template< typename Pixel >
+struct is_write_supported< Pixel
+                         , jpeg_tag
+                         >
+    : mpl::bool_< detail::jpeg_write_support< typename channel_type< Pixel >::type
+                                            , typename color_space_type< Pixel >::type
+                                            >::is_supported
+                > 
+{};
+
+
+} // namespace gil
+} // namespace boost
+
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_SUPPORTED_TYPES_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,184 @@
+/*
+    Copyright 2007-2008 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_IO_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_JPEG_IO_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <vector>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+
+#include <boost/gil/extension/io_new/jpeg_tags.hpp>
+
+#include "supported_types.hpp"
+#include "writer_backend.hpp"
+
+namespace boost { namespace gil {
+
+namespace detail { 
+
+struct jpeg_write_is_supported
+{
+    template< typename View >
+    struct apply
+        : public is_write_supported< typename get_pixel_type< View >::type
+                                   , jpeg_tag
+                                   >
+    {};
+};
+
+} // detail
+
+///
+/// JPEG Writer
+///
+template< typename Device >
+class writer< Device
+            , jpeg_tag
+            >
+    : public writer_backend< Device
+                           , jpeg_tag
+                           >
+{
+public:
+
+    typedef writer_backend< Device
+                          , jpeg_tag
+                          > backend_t;
+
+public:
+
+    writer( const Device&                       io_dev
+          , const image_write_info< jpeg_tag >& info
+          )
+    : backend_t( io_dev
+               , info
+               )
+    {}
+
+    template<typename View>
+    void apply( const View& view )
+    {
+        write_rows( view );
+    }
+
+private:
+
+    template<typename View>
+    void write_rows( const View& view )
+    {
+        std::vector< pixel< typename channel_type< View >::type
+                          , layout<typename color_space_type< View >::type >
+                          >
+                   > row_buffer( view.width() );
+
+        // In case of an error we'll jump back to here and fire an exception.
+        // @todo Is the buffer above cleaned up when the exception is thrown?
+        //       The strategy right now is to allocate necessary memory before
+        //       the setjmp.
+        if( setjmp( this->_mark )) { this->raise_error(); }
+
+        typedef typename channel_type< typename View::value_type >::type channel_t;
+
+        this->get()->image_width      = JDIMENSION( view.width()  );
+        this->get()->image_height     = JDIMENSION( view.height() );
+        this->get()->input_components = num_channels<View>::value;
+        this->get()->in_color_space   = detail::jpeg_write_support< channel_t
+                                                                  , typename color_space_type< View >::type
+                                                                  >::_color_space;
+
+        jpeg_set_defaults( this->get() );
+
+        jpeg_set_quality( this->get()
+                        , this->_info._quality
+                        , TRUE
+                        );
+
+        // Needs to be done after jpeg_set_defaults() since it's overridding this value back to slow.
+        this->get()->dct_method = this->_info._dct_method;
+
+
+        // set the pixel dimensions
+        this->get()->density_unit = this->_info._density_unit;
+        this->get()->X_density    = this->_info._x_density;
+        this->get()->Y_density    = this->_info._y_density;
+
+        // done reading header information
+
+        jpeg_start_compress( this->get()
+                           , TRUE
+                           );
+
+        JSAMPLE* row_addr = reinterpret_cast< JSAMPLE* >( &row_buffer[0] );
+
+        for( int y =0; y != view.height(); ++ y )
+        {
+            std::copy( view.row_begin( y )
+                     , view.row_end  ( y )
+                     , row_buffer.begin()
+                     );
+
+            jpeg_write_scanlines( this->get()
+                                , &row_addr
+                                , 1
+                                );
+        }
+    }
+};
+
+///
+/// JPEG Dyamic Image Writer
+///
+template< typename Device >
+class dynamic_image_writer< Device
+                          , jpeg_tag
+                          >
+    : public writer< Device
+                   , jpeg_tag
+                   >
+{
+    typedef writer< Device
+                  , jpeg_tag
+                  > parent_t;
+
+public:
+
+    dynamic_image_writer( const Device&                       io_dev
+                        , const image_write_info< jpeg_tag >& info
+                        )
+    : parent_t( io_dev
+              , info
+              )
+    {}
+
+    template< typename Views >
+    void apply( const any_image_view< Views >& views )
+    {
+        detail::dynamic_io_fnobj< detail::jpeg_write_is_supported
+                                , parent_t
+                                > op( this );
+
+        apply_operation( views, op );
+    }
+};
+
+} // gil
+} // boost
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_IO_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/writer_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/jpeg/writer_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,192 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_IO_WRITER_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_JPEG_IO_WRITER_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/jpeg_tags.hpp>
+
+#include "base.hpp"
+
+namespace boost { namespace gil {
+
+namespace detail { 
+
+///
+/// Wrapper for libjpeg's compress object. Implements value semantics.
+///
+struct jpeg_compress_wrapper
+{
+protected:
+
+    typedef boost::shared_ptr< jpeg_compress_struct > jpeg_compress_ptr_t;
+
+protected:
+
+    ///
+    /// Default Constructor
+    ///
+    jpeg_compress_wrapper()
+    : _jpeg_compress_ptr( new jpeg_compress_struct()
+                        , jpeg_compress_deleter
+                        )
+    {}
+
+    jpeg_compress_struct*       get()       { return _jpeg_compress_ptr.get(); }
+    const jpeg_compress_struct* get() const { return _jpeg_compress_ptr.get(); }
+
+private:
+
+    static void jpeg_compress_deleter( jpeg_compress_struct* jpeg_compress_ptr )
+    {
+        if( jpeg_compress_ptr )
+        {
+            jpeg_destroy_compress( jpeg_compress_ptr );
+
+            delete jpeg_compress_ptr;
+            jpeg_compress_ptr = NULL;
+        }
+    }
+
+private:
+
+   jpeg_compress_ptr_t _jpeg_compress_ptr;
+
+};
+
+} // namespace detail
+
+///
+/// JPEG Writer Backend
+///
+template< typename Device >
+struct writer_backend< Device
+                     , jpeg_tag
+                     >
+    : public jpeg_io_base
+    , public detail::jpeg_compress_wrapper
+{
+public:
+
+    typedef jpeg_tag format_tag_t;
+
+public:
+    ///
+    /// Constructor
+    ///
+    writer_backend( const Device&                       io_dev
+                  , const image_write_info< jpeg_tag >& info
+                  )
+    : _io_dev( io_dev )
+    , _info( info )
+    {
+        get()->err         = jpeg_std_error( &_jerr );
+        get()->client_data = this;
+
+        // Error exit handler: does not return to caller.
+        _jerr.error_exit = &writer< Device, jpeg_tag >::error_exit;
+
+        // Fire exception in case of error.
+        if( setjmp( _mark )) { raise_error(); }
+
+        _dest._jdest.free_in_buffer      = sizeof( buffer );
+        _dest._jdest.next_output_byte    = buffer;
+        _dest._jdest.init_destination    = reinterpret_cast< void(*)   ( j_compress_ptr ) >( &writer< Device, jpeg_tag >::init_device  );
+        _dest._jdest.empty_output_buffer = reinterpret_cast< boolean(*)( j_compress_ptr ) >( &writer< Device, jpeg_tag >::empty_buffer );
+        _dest._jdest.term_destination    = reinterpret_cast< void(*)   ( j_compress_ptr ) >( &writer< Device, jpeg_tag >::close_device );
+        _dest._this = this;
+
+        jpeg_create_compress( get() );
+        get()->dest = &_dest._jdest;
+    }
+
+    ~writer_backend()
+    {
+        jpeg_finish_compress ( get() );
+        jpeg_destroy_compress( get() );
+    }
+
+protected:
+
+    struct gil_jpeg_destination_mgr
+    {
+        jpeg_destination_mgr _jdest;
+        writer_backend< Device
+                      , jpeg_tag
+                      >* _this;
+    };
+
+    static void init_device( jpeg_compress_struct* cinfo )
+    {
+        gil_jpeg_destination_mgr* dest = reinterpret_cast< gil_jpeg_destination_mgr* >( cinfo->dest );
+
+        dest->_jdest.free_in_buffer   = sizeof( dest->_this->buffer );
+        dest->_jdest.next_output_byte = dest->_this->buffer;
+    }
+
+    static boolean empty_buffer( jpeg_compress_struct* cinfo )
+    {
+        gil_jpeg_destination_mgr* dest = reinterpret_cast< gil_jpeg_destination_mgr* >( cinfo->dest );
+
+        dest->_this->_io_dev.write( dest->_this->buffer
+                                  , buffer_size
+                                  );
+
+        writer<Device,jpeg_tag>::init_device( cinfo );
+        return 1;
+    }
+
+    static void close_device( jpeg_compress_struct* cinfo )
+    {
+        writer_backend< Device
+                      , jpeg_tag
+                      >::empty_buffer( cinfo );
+
+        gil_jpeg_destination_mgr* dest = reinterpret_cast< gil_jpeg_destination_mgr* >( cinfo->dest );
+
+        dest->_this->_io_dev.flush();
+    }
+
+    void raise_error()
+    {
+        io_error( "Cannot write jpeg file." );
+    }
+
+    static void error_exit( j_common_ptr cinfo )
+    {
+        writer< Device, jpeg_tag >* mgr = reinterpret_cast< writer< Device, jpeg_tag >* >( cinfo->client_data );
+
+        longjmp( mgr->_mark, 1 );
+    }
+
+public:
+
+    Device _io_dev;
+
+    image_write_info< jpeg_tag > _info;
+
+    gil_jpeg_destination_mgr _dest;
+
+    static const unsigned int buffer_size = 1024;
+    JOCTET buffer[buffer_size];
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_IO_WRITER_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/png/base.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/png/base.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,107 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_BASE_HPP
+#define BOOST_GIL_EXTENSION_IO_PNG_BASE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/png_tags.hpp>
+
+namespace boost { namespace gil { namespace detail {
+
+struct png_ptr_wrapper
+{
+    png_ptr_wrapper()
+    : _struct( NULL )
+    , _info  ( NULL )
+    {}
+
+    png_structp _struct;
+    png_infop   _info;
+};
+
+///
+/// Wrapper for libpng's png_struct and png_info object. Implements value semantics.
+///
+struct png_struct_info_wrapper
+{
+protected:
+
+    typedef boost::shared_ptr< png_ptr_wrapper > png_ptr_t;
+
+protected:
+
+    ///
+    /// Default Constructor
+    ///
+    png_struct_info_wrapper( bool read = true )
+    : _png_ptr( new png_ptr_wrapper()
+              , ( ( read ) ? png_ptr_read_deleter : png_ptr_write_deleter )
+              )
+    {}
+
+    png_ptr_wrapper*       get()       { return _png_ptr.get(); }
+    const png_ptr_wrapper* get() const { return _png_ptr.get(); }
+    
+    png_structp       get_struct()       { return get()->_struct; }
+    const png_structp get_struct() const { return get()->_struct; }
+
+    png_infop       get_info()       { return get()->_info; }
+    const png_infop get_info() const { return get()->_info; }
+
+private:
+
+    static void png_ptr_read_deleter( png_ptr_wrapper* png_ptr )
+    {
+        if( png_ptr )
+        {
+            assert( png_ptr->_struct && png_ptr->_info );
+
+            png_destroy_read_struct( &png_ptr->_struct
+                                   , &png_ptr->_info
+                                   , NULL
+                                   );
+
+            delete png_ptr;
+            png_ptr = NULL;
+        }
+    }
+
+    static void png_ptr_write_deleter( png_ptr_wrapper* png_ptr )
+    {
+        if( png_ptr )
+        {
+            assert( png_ptr->_struct && png_ptr->_info );
+
+            png_destroy_write_struct( &png_ptr->_struct
+                                    , &png_ptr->_info
+                                    );
+
+            delete png_ptr;
+            png_ptr = NULL;
+        }
+    }
+
+
+private:
+
+    png_ptr_t _png_ptr;
+};
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNG_BASE_HPP
\ No newline at end of file
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/png/is_allowed.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/png/is_allowed.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,55 @@
+/*
+    Copyright 2008 Christian Henning, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_IO_IS_ALLOWED_HPP
+#define BOOST_GIL_EXTENSION_IO_PNG_IO_IS_ALLOWED_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/mpl/for_each.hpp>
+
+namespace boost { namespace gil { namespace detail {
+
+template< typename View >
+bool is_allowed( const image_read_info< png_tag >& info
+               , mpl::true_   // is read_and_no_convert
+               )
+{
+    typedef typename get_pixel_type< View >::type pixel_t;
+
+    typedef typename channel_traits< 
+                typename element_type< pixel_t >::type >::value_type channel_t;
+
+    const png_num_channels::type dst_num_channels = num_channels< pixel_t >::value;
+    const png_bitdepth::type     dst_bit_depth    = detail::unsigned_integral_num_bits< channel_t >::value;
+
+    return   dst_num_channels == info._num_channels
+          && dst_bit_depth    == info._bit_depth;
+}
+
+template< typename View >
+bool is_allowed( const image_read_info< png_tag >& /* info */
+               , mpl::false_  // is read_and_convert
+               )
+{
+    return true;
+}
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNG_IO_IS_ALLOWED_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/png/read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/png/read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,438 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_PNG_IO_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_PNG_IO_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/png_tags.hpp>
+
+#include <boost/gil/gil_all.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+
+#include "reader_backend.hpp"
+#include "is_allowed.hpp"
+
+namespace boost { namespace gil {
+
+///
+/// PNG Reader
+///
+template< typename Device
+        , typename ConversionPolicy
+        >
+class reader< Device
+            , png_tag
+            , ConversionPolicy
+            >
+    : public reader_base< png_tag
+                        , ConversionPolicy >
+    , public reader_backend< Device
+                           , png_tag
+                           >
+{
+private:
+
+    typedef reader< Device
+                  , png_tag
+                  , ConversionPolicy
+                  > this_t;
+
+    typedef typename ConversionPolicy::color_converter_type cc_t;
+
+public:
+
+    typedef reader_backend< Device, png_tag > backend_t;
+
+public:
+
+    reader( const Device&                         io_dev
+          , const image_read_settings< png_tag >& settings
+          )
+    : reader_base< png_tag
+                 , ConversionPolicy
+                 >()
+    , backend_t( io_dev
+               , settings
+               )
+    {}
+
+    reader( const Device&                                          io_dev
+          , const typename ConversionPolicy::color_converter_type& cc
+          , const image_read_settings< png_tag >&                  settings
+          )
+    : reader_base< png_tag
+                 , ConversionPolicy
+                 >( cc )
+    , backend_t( io_dev
+               , settings
+               )
+    {}
+
+    template< typename View >
+    void apply( const View& view )
+    {
+        // The info structures are filled at this point.
+
+        // Now it's time for some transformations.
+
+        if( little_endian() )
+        {
+            if( this->_info._bit_depth == 16 )
+            {
+                // Swap bytes of 16 bit files to least significant byte first.
+                png_set_swap( this->get_struct() );
+            }
+
+            if( this->_info._bit_depth < 8 )
+            {
+                // swap bits of 1, 2, 4 bit packed pixel formats
+                png_set_packswap( this->get_struct() );
+            }
+        }
+
+        if( this->_info._color_type == PNG_COLOR_TYPE_PALETTE )
+        {
+            png_set_palette_to_rgb( this->get_struct() );
+        }
+
+        if( this->_info._num_trans > 0 )
+        {
+            png_set_tRNS_to_alpha( this->get_struct() );
+        }
+
+        // Tell libpng to handle the gamma conversion for you.  The final call
+        // is a good guess for PC generated images, but it should be configurable
+        // by the user at run time by the user.  It is strongly suggested that
+        // your application support gamma correction.
+        if( this->_settings._apply_screen_gamma )
+        {
+            // png_set_gamma will change the image data!
+
+#ifdef BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+        png_set_gamma( this->get_struct()
+                     , this->_settings._screen_gamma
+                     , this->_info._file_gamma
+                     );
+#else
+        png_set_gamma( this->get_struct()
+                     , this->_settings._screen_gamma
+                     , this->_info._file_gamma
+                     );
+#endif // BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+        }
+
+        // Turn on interlace handling.  REQUIRED if you are not using
+        // png_read_image().  To see how to handle interlacing passes,
+        // see the png_read_row() method below:
+        this->_number_passes = png_set_interlace_handling( this->get_struct() );
+
+
+        // The above transformation might have changed the bit_depth and color type.
+        png_read_update_info( this->get_struct()
+                            , this->get_info()
+                            );
+
+        this->_info._bit_depth = png_get_bit_depth( this->get_struct()
+                                                  , this->get_info()
+                                                  );
+
+        this->_info._num_channels = png_get_channels( this->get_struct()
+                                                    , this->get_info()
+                                                    );
+
+        this->_info._color_type = png_get_color_type( this->get_struct()
+                                                    , this->get_info()
+                                                    );
+
+        this->_scanline_length = png_get_rowbytes( this->get_struct()
+                                                 , this->get_info()
+                                                 );
+
+        switch( this->_info._color_type )
+        {
+            case PNG_COLOR_TYPE_GRAY:
+            {
+                switch( this->_info._bit_depth )
+                {
+                    case  1: read_rows< gray1_image_t::view_t::reference >( view ); break;
+                    case  2: read_rows< gray2_image_t::view_t::reference >( view ); break;
+                    case  4: read_rows< gray4_image_t::view_t::reference >( view ); break;
+                    case  8: read_rows< gray8_pixel_t  >( view ); break;
+                    case 16: read_rows< gray16_pixel_t >( view ); break;
+                    default: io_error( "png_reader::read_data(): unknown combination of color type and bit depth" );
+                }
+
+                break;
+            }
+            case PNG_COLOR_TYPE_GA:
+            {
+                #ifdef BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+                switch( this->_info._bit_depth )
+                {
+                    case  8: read_rows< gray_alpha8_pixel_t > ( view ); break;
+                    case 16: read_rows< gray_alpha16_pixel_t >( view ); break;
+                    default: io_error( "png_reader::read_data(): unknown combination of color type and bit depth" );
+                }
+                #else
+                    io_error( "gray_alpha isn't enabled. Use ENABLE_GRAY_ALPHA when building application." );
+                #endif // BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+
+                break;
+            }
+            case PNG_COLOR_TYPE_RGB:
+            {
+                switch( this->_info._bit_depth )
+                {
+                    case 8:  read_rows< rgb8_pixel_t > ( view ); break;
+                    case 16: read_rows< rgb16_pixel_t >( view ); break;
+                    default: io_error( "png_reader::read_data(): unknown combination of color type and bit depth" );
+                }
+
+                break;
+            }
+            case PNG_COLOR_TYPE_RGBA:
+            {
+                switch( this->_info._bit_depth )
+                {
+                    case  8: read_rows< rgba8_pixel_t > ( view ); break;
+                    case 16: read_rows< rgba16_pixel_t >( view ); break;
+                    default: io_error( "png_reader_color_convert::read_data(): unknown combination of color type and bit depth" );
+                }
+
+                break;
+            }
+            default: io_error( "png_reader_color_convert::read_data(): unknown color type" );
+        }
+
+        // read rest of file, and get additional chunks in info_ptr
+        png_read_end( this->get_struct()
+                    , NULL
+                    );
+    }
+
+private:
+
+    template< typename ImagePixel
+            , typename View
+            >
+    void read_rows( const View& view )
+    {		
+        typedef detail::row_buffer_helper_view< ImagePixel > row_buffer_helper_t;
+
+        typedef typename row_buffer_helper_t::buffer_t   buffer_t;
+        typedef typename row_buffer_helper_t::iterator_t it_t;
+
+        typedef typename is_same< ConversionPolicy
+                                , detail::read_and_no_convert
+                                >::type is_read_and_convert_t;
+
+        io_error_if( !detail::is_allowed< View >( this->_info
+                                                , is_read_and_convert_t()
+                                                )
+                   , "Image types aren't compatible."
+                   );
+
+        std::size_t rowbytes = png_get_rowbytes( this->get_struct()
+                                               , this->get_info()
+                                               );
+
+        row_buffer_helper_t buffer( rowbytes
+                                  , true
+                                  );
+
+        png_bytep row_ptr = (png_bytep)( &( buffer.data()[0]));
+
+        for( std::size_t pass = 0; pass < this->_number_passes; pass++ )
+        {
+            if( pass == this->_number_passes - 1 )
+            {
+                // skip lines if necessary
+                for( std::ptrdiff_t y = 0; y < this->_settings._top_left.y; ++y )
+                {
+                    // Read the image using the "sparkle" effect.
+                    png_read_rows( this->get_struct()
+                                 , &row_ptr
+                                 , NULL
+                                 , 1
+                                 );
+                }
+
+                for( std::ptrdiff_t y = 0
+                   ; y < this->_settings._dim.y
+                   ; ++y
+                   )
+                {
+                    // Read the image using the "sparkle" effect.
+                    png_read_rows( this->get_struct()
+                                 , &row_ptr
+                                 , NULL
+                                 , 1
+                                 );
+
+                    it_t first = buffer.begin() + this->_settings._top_left.x;
+                    it_t last  = first + this->_settings._dim.x; // one after last element
+
+                    this->_cc_policy.read( first
+                                         , last
+                                         , view.row_begin( y ));
+                }
+
+                // Read the rest of the image. libpng needs that.
+                std::ptrdiff_t remaining_rows = static_cast< std::ptrdiff_t >( this->_info._height )
+                                              - this->_settings._top_left.y
+                                              - this->_settings._dim.y;
+                for( std::ptrdiff_t y = 0
+                   ; y < remaining_rows
+                   ; ++y
+                   )
+                {
+                    // Read the image using the "sparkle" effect.
+                    png_read_rows( this->get_struct()
+                                 , &row_ptr
+                                 , NULL
+                                 , 1
+                                 );
+                }
+            }
+            else
+            {
+                for( int y = 0; y < view.height(); ++y )
+                {
+                    // Read the image using the "sparkle" effect.
+                    png_read_rows( this->get_struct()
+                                 , &row_ptr
+                                 , NULL
+                                 , 1
+                                 );
+                }
+            }
+        }
+    }
+};
+
+namespace detail {
+
+struct png_type_format_checker
+{
+    png_type_format_checker( png_bitdepth::type   bit_depth
+                           , png_color_type::type color_type
+                           )
+    : _bit_depth ( bit_depth  )
+    , _color_type( color_type )
+    {}
+
+    template< typename Image >
+    bool apply()
+    {
+        typedef is_read_supported< typename get_pixel_type< typename Image::view_t >::type
+                                 , png_tag
+                                 > is_supported_t;
+
+        return is_supported_t::_bit_depth  == _bit_depth
+            && is_supported_t::_color_type == _color_type;
+    }
+
+private:
+
+    png_bitdepth::type   _bit_depth;
+    png_color_type::type _color_type;
+};
+
+struct png_read_is_supported
+{
+    template< typename View >
+    struct apply : public is_read_supported< typename get_pixel_type< View >::type
+                                           , png_tag
+                                           >
+    {};
+};
+
+} // namespace detail
+
+
+///
+/// PNG Dynamic Image Reader
+///
+template< typename Device
+        >
+class dynamic_image_reader< Device
+                          , png_tag
+                          >
+    : public reader< Device
+                   , png_tag
+                   , detail::read_and_no_convert
+                   >
+{
+    typedef reader< Device
+                  , png_tag
+                  , detail::read_and_no_convert
+                  > parent_t;
+
+public:
+
+    dynamic_image_reader( const Device&                         io_dev
+                        , const image_read_settings< png_tag >& settings
+                        )
+    : parent_t( io_dev
+              , settings
+              )
+    {}
+
+    template< typename Images >
+    void apply( any_image< Images >& images )
+    {
+        detail::png_type_format_checker format_checker( this->_info._bit_depth
+                                                      , this->_info._color_type
+                                                      );
+
+        if( !construct_matched( images
+                              , format_checker
+                              ))
+        {
+            io_error( "No matching image type between those of the given any_image and that of the file" );
+        }
+        else
+        {
+            init_image( images
+                      , this->_settings
+                      );
+
+            detail::dynamic_io_fnobj< detail::png_read_is_supported
+                                    , parent_t
+                                    > op( this );
+
+            apply_operation( view( images )
+                           , op
+                           );
+        }
+    }
+};
+
+} // namespace gil
+} // namespace boost
+
+
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_PNG_IO_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/png/reader_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/png/reader_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,654 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_IO_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_PNG_IO_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/png_tags.hpp>
+
+#include "base.hpp"
+
+namespace boost { namespace gil {
+
+///
+/// PNG Backend
+///
+template<typename Device >
+struct reader_backend< Device
+                     , png_tag
+                     >
+    : public detail::png_struct_info_wrapper
+{
+public:
+
+    typedef png_tag format_tag_t;
+
+public:
+
+    typedef reader_backend< Device
+                          , png_tag
+                          > this_t;
+
+
+public:
+
+    reader_backend( const Device&                         io_dev
+                  , const image_read_settings< png_tag >& settings
+                  )
+    : _io_dev( io_dev )
+
+    , _settings( settings )
+    , _info()
+    , _scanline_length( 0 )
+
+    , _number_passes( 0 )
+    {
+        read_header();
+
+        if( _settings._dim.x == 0 )
+        {
+            _settings._dim.x = _info._width;
+        }
+
+        if( _settings._dim.y == 0 )
+        {
+            _settings._dim.y = _info._height;
+        }
+    }
+
+    void read_header()
+    {
+		using boost::gil::detail::PNG_BYTES_TO_CHECK;
+		
+        // check the file's first few bytes
+        byte_t buf[PNG_BYTES_TO_CHECK];
+
+        io_error_if( _io_dev.read( buf
+                                , PNG_BYTES_TO_CHECK
+                                ) != PNG_BYTES_TO_CHECK
+                   , "png_check_validity: failed to read image"
+                   );
+
+        io_error_if( png_sig_cmp( png_bytep(buf)
+                                , png_size_t(0)
+                                , PNG_BYTES_TO_CHECK
+                                ) != 0
+                   , "png_check_validity: invalid png image"
+                   );
+
+        // Create and initialize the png_struct with the desired error handler
+        // functions.  If you want to use the default stderr and longjump method,
+        // you can supply NULL for the last three parameters.  We also supply the
+        // the compiler header file version, so that we know if the application
+        // was compiled with a compatible version of the library.  REQUIRED
+        get()->_struct = png_create_read_struct( PNG_LIBPNG_VER_STRING
+                                             , NULL  // user_error_ptr
+                                             , NULL  // user_error_fn
+                                             , NULL  // user_warning_fn
+                                             );
+
+        io_error_if( get()->_struct == NULL
+                   , "png_reader: fail to call png_create_write_struct()"
+                   );
+
+        png_uint_32 user_chunk_data[4];
+        user_chunk_data[0] = 0;
+        user_chunk_data[1] = 0;
+        user_chunk_data[2] = 0;
+        user_chunk_data[3] = 0;
+        png_set_read_user_chunk_fn( get_struct()
+                                  , user_chunk_data
+                                  , this_t::read_user_chunk_callback
+                                  );
+
+        // Allocate/initialize the memory for image information.  REQUIRED.
+        get()->_info = png_create_info_struct( get_struct() );
+
+        if( get_info() == NULL )
+        {
+            png_destroy_read_struct( &get()->_struct
+                                   , NULL
+                                   , NULL
+                                   );
+
+            io_error( "png_reader: fail to call png_create_info_struct()" );
+        }
+
+        // Set error handling if you are using the setjmp/longjmp method (this is
+        // the normal method of doing things with libpng).  REQUIRED unless you
+        // set up your own error handlers in the png_create_read_struct() earlier.
+        if( setjmp( png_jmpbuf( get_struct() )))
+        {
+            //free all of the memory associated with the png_ptr and info_ptr
+            png_destroy_read_struct( &get()->_struct
+                                   , &get()->_info
+                                   , NULL
+                                   );
+
+            io_error( "png is invalid" );
+        }
+
+        png_set_read_fn( get_struct()
+                       , static_cast< png_voidp >( &this->_io_dev )
+                       , this_t::read_data
+                       );
+
+        // Set up a callback function that will be
+        // called after each row has been read, which you can use to control
+        // a progress meter or the like.
+        png_set_read_status_fn( get_struct()
+                              , this_t::read_row_callback
+                              );
+
+        // Set up a callback which implements user defined transformation.
+        // @todo
+        png_set_read_user_transform_fn( get_struct()
+                                      , png_user_transform_ptr( NULL )
+                                      );
+
+        png_set_keep_unknown_chunks( get_struct()
+                                   , PNG_HANDLE_CHUNK_ALWAYS
+                                   , NULL
+                                   , 0
+                                   );
+
+
+        // Make sure we read the signature.
+        // @todo make it an option
+        png_set_sig_bytes( get_struct()
+                         , PNG_BYTES_TO_CHECK
+                         );
+
+        // The call to png_read_info() gives us all of the information from the
+        // PNG file before the first IDAT (image data chunk).  REQUIRED
+        png_read_info( get_struct()
+                     , get_info()
+                     );
+
+        ///
+        /// Start reading the image information
+        ///
+
+        // get PNG_IHDR chunk information from png_info structure
+        png_get_IHDR( get_struct()
+                    , get_info()
+                    , &this->_info._width
+                    , &this->_info._height
+                    , &this->_info._bit_depth
+                    , &this->_info._color_type
+                    , &this->_info._interlace_method
+                    , &this->_info._compression_method
+                    , &this->_info._filter_method
+                    );
+
+        // get number of color channels in image
+        this->_info._num_channels = png_get_channels( get_struct()
+                                              , get_info()
+                                              );
+
+#ifdef BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+
+        // Get CIE chromacities and referenced white point
+        if( this->_settings._read_cie_chromacities )
+        {
+            this->_info._valid_cie_colors = png_get_cHRM( get_struct()
+                                                        , get_info()
+                                                        , &this->_info._white_x, &this->_info._white_y
+                                                        ,   &this->_info._red_x,   &this->_info._red_y
+                                                        , &this->_info._green_x, &this->_info._green_y
+                                                        ,  &this->_info._blue_x,  &this->_info._blue_y
+                                                        );
+        }
+
+        // get the gamma value
+        if( this->_settings._read_file_gamma )
+        {
+            this->_info._valid_file_gamma = png_get_gAMA( get_struct()
+                                                        , get_info()
+                                                        , &this->_info._file_gamma
+                                                        );
+
+            if( this->_info._valid_file_gamma == false )
+            {
+                this->_info._file_gamma = 1.0;
+            }
+        }
+#else
+
+        // Get CIE chromacities and referenced white point
+        if( this->_settings._read_cie_chromacities )
+        {
+            this->_info._valid_cie_colors = png_get_cHRM_fixed( get_struct()
+                                                              , get_info()
+                                                              , &this->_info._white_x, &this->_info._white_y
+                                                              ,   &this->_info._red_x,   &this->_info._red_y
+                                                              , &this->_info._green_x, &this->_info._green_y
+                                                              ,  &this->_info._blue_x,  &this->_info._blue_y
+                                                              );
+        }
+
+        // get the gamma value
+        if( this->_settings._read_file_gamma )
+        {
+            this->_info._valid_file_gamma = png_get_gAMA_fixed( get_struct()
+                                                              , get_info()
+                                                              , &this->_info._file_gamma
+                                                              );
+
+            if( this->_info._valid_file_gamma == false )
+            {
+                this->_info._file_gamma = 1;
+            }
+        }
+#endif // BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+
+        // get the embedded ICC profile data
+        if( this->_settings._read_icc_profile )
+        {
+#if PNG_LIBPNG_VER_MINOR >= 5
+            png_charp icc_name = png_charp( NULL );
+            png_bytep profile  = png_bytep( NULL );
+
+            this->_info._valid_icc_profile = png_get_iCCP( get_struct()
+                                                         , get_info()
+                                                         , &icc_name
+                                                         , &this->_info._iccp_compression_type
+                                                         , &profile
+                                                         , &this->_info._profile_length
+                                                         );
+#else
+            png_charp icc_name = png_charp( NULL );
+            png_charp profile  = png_charp( NULL );
+
+            this->_info._valid_icc_profile = png_get_iCCP( get_struct()
+                                                         , get_info()
+                                                         , &icc_name
+                                                         , &this->_info._iccp_compression_type
+                                                         , &profile
+                                                         , &this->_info._profile_length
+                                                         );
+#endif
+            if( icc_name )
+            {
+                this->_info._icc_name.append( icc_name
+                                            , std::strlen( icc_name )
+                                            );
+            }
+
+            if( this->_info._profile_length > 0 )
+            {
+                this->_info._profile.append( reinterpret_cast< char* >( profile )
+                                           , this->_info._profile_length
+                                           );
+            }
+        }
+
+        // get the rendering intent
+        if( this->_settings._read_intent )
+        {
+            this->_info._valid_intent = png_get_sRGB( get_struct()
+                                                    , get_info()
+                                                    , &this->_info._intent
+                                                    );
+        }
+
+        // get image palette information from png_info structure
+        if( this->_settings._read_palette )
+        {
+            png_colorp palette = png_colorp( NULL );
+
+            this->_info._valid_palette = png_get_PLTE( get_struct()
+                                                     , get_info()
+                                                     , &palette
+                                                     , &this->_info._num_palette
+                                                     );
+
+            if( this->_info._num_palette > 0 )
+            {
+                this->_info._palette.resize( this->_info._num_palette );
+                std::copy( palette
+                         , palette + this->_info._num_palette
+                         , &this->_info._palette.front()
+                         );
+            }
+        }
+
+        // get background color
+        if( this->_settings._read_background )
+        {
+            png_color_16p background = png_color_16p( NULL );
+
+            this->_info._valid_background = png_get_bKGD( get_struct()
+                                                        , get_info()
+                                                        , &background
+                                                        );
+            if( background )
+            {
+                this->_info._background = *background;
+            }
+        }
+
+        // get the histogram
+        if( this->_settings._read_histogram )
+        {
+            png_uint_16p histogram = png_uint_16p( NULL );
+
+            this->_info._valid_histogram = png_get_hIST( get_struct()
+                                                       , get_info()
+                                                       , &histogram
+                                                       );
+
+            if( histogram )
+            {
+                // the number of values is set by the number of colors inside
+                // the palette.
+                if( this->_settings._read_palette == false )
+                {
+                    png_colorp palette = png_colorp( NULL );
+                    png_get_PLTE( get_struct()
+                                , get_info()
+                                , &palette
+                                , &this->_info._num_palette
+                                );
+                }
+
+                std::copy( histogram
+                         , histogram + this->_info._num_palette
+                         , &this->_info._histogram.front()
+                         );
+            }
+        }
+
+        // get screen offsets for the given image
+        if( this->_settings._read_screen_offsets )
+        {
+            this->_info._valid_offset = png_get_oFFs( get_struct()
+                                                    , get_info()
+                                                    , &this->_info._offset_x
+                                                    , &this->_info._offset_y
+                                                    , &this->_info._off_unit_type
+                                                    );
+        }
+
+
+        // get pixel calibration settings
+        if( this->_settings._read_pixel_calibration )
+        {
+            png_charp purpose = png_charp ( NULL );
+            png_charp units   = png_charp ( NULL );
+            png_charpp params = png_charpp( NULL );
+
+            this->_info._valid_pixel_calibration = png_get_pCAL( get_struct()
+                                                               , get_info()
+                                                               , &purpose
+                                                               , &this->_info._X0
+                                                               , &this->_info._X1
+                                                               , &this->_info._cal_type
+                                                               , &this->_info._num_params
+                                                               , &units
+                                                               , &params
+                                                               );
+            if( purpose )
+            {
+                this->_info._purpose.append( purpose
+                                           , std::strlen( purpose )
+                                           );
+            }
+
+            if( units )
+            {
+                this->_info._units.append( units
+                                         , std::strlen( units )
+                                         );
+            }
+
+            if( this->_info._num_params > 0 )
+            {
+                this->_info._params.resize( this->_info._num_params );
+
+                for( png_CAL_nparam::type i = 0
+                   ; i < this->_info._num_params
+                   ; ++i
+                   )
+                {
+                    this->_info._params[i].append( params[i]
+                                                 , std::strlen( params[i] )
+                                                 );
+                }
+            }
+        }
+
+        // get the physical resolution
+        if( this->_settings._read_physical_resolution )
+        {
+            this->_info._valid_resolution = png_get_pHYs( get_struct()
+                                                        , get_info()
+                                                        , &this->_info._res_x
+                                                        , &this->_info._res_y
+                                                        , &this->_info._phy_unit_type
+                                                        );
+        }
+
+        // get the image resolution in pixels per meter.
+        if( this->_settings._read_pixels_per_meter )
+        {
+            this->_info._pixels_per_meter = png_get_pixels_per_meter( get_struct()
+                                                                    , get_info()
+                                                                    );
+        }
+
+
+        // get number of significant bits for each color channel
+        if( this->_settings._read_number_of_significant_bits )
+        {
+            png_color_8p sig_bits = png_color_8p( NULL );
+
+            this->_info._valid_significant_bits = png_get_sBIT( get_struct()
+                                                              , get_info()
+                                                              , &sig_bits
+                                                              );
+
+            // @todo Is there one or more colors?
+            if( sig_bits )
+            {
+                this->_info._sig_bits = *sig_bits;
+            }
+        }
+
+#ifdef BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+
+        // get physical scale settings
+        if( this->_settings._read_scale_factors )
+        {
+            this->_info._valid_scale_factors = png_get_sCAL( get_struct()
+                                                           , get_info()
+                                                           , &this->_info._scale_unit
+                                                           , &this->_info._scale_width
+                                                           , &this->_info._scale_height
+                                                           );
+        }
+#else
+#ifdef BOOST_GIL_IO_PNG_FIXED_POINT_SUPPORTED
+        if( this->_settings._read_scale_factors )
+        {
+            png_charp scale_width, scale_height;
+
+            if( this->_info._valid_scale_factors = png_get_sCAL_s( get_struct()
+                                                                 , get_info()
+                                                                 , &this->_info._scale_unit
+                                                                 , &scale_width
+                                                                 , &scale_height
+                                                                 )
+              )
+            {
+                if( scale_width )
+                {
+                    this->_info._scale_width.append( scale_width
+                                                   , std::strlen( scale_width )
+                                                   );
+                }
+
+                if( scale_height )
+                {
+                    this->_info._scale_height.append( scale_height
+                                                    , std::strlen( scale_height )
+                                                    );
+                }
+            }
+        }
+#endif // BOOST_GIL_IO_PNG_FIXED_POINT_SUPPORTED
+#endif // BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+
+        // get comments information from png_info structure
+        if( this->_settings._read_comments )
+        {
+            png_textp text = png_textp( NULL );
+
+            this->_info._valid_text = png_get_text( get_struct()
+                                                  , get_info()
+                                                  , &text
+                                                  , &this->_info._num_text
+                                                  );
+
+            if( this->_info._num_text > 0 )
+            {
+                this->_info._text.resize( this->_info._num_text );
+
+                for( png_num_text::type i = 0
+                   ; i < this->_info._num_text
+                   ; ++i
+                   )
+                {
+                    this->_info._text[i]._compression = text[i].compression;
+                    this->_info._text[i]._key.append( text[i].key
+                                                    , std::strlen( text[i].key )
+                                                    );
+
+                    this->_info._text[i]._text.append( text[i].text
+                                                     , std::strlen( text[i].text )
+                                                     );
+                }
+            }
+        }
+
+        // get last modification time
+        if( this->_settings._read_last_modification_time )
+        {
+            png_timep mod_time = png_timep( NULL );
+            this->_info._valid_modification_time = png_get_tIME( get_struct()
+                                                               , get_info()
+                                                               , &mod_time
+                                                               );
+            if( mod_time )
+            {
+                this->_info._mod_time = *mod_time;
+            }
+        }
+
+        // get transparency data
+        if( this->_settings._read_transparency_data )
+        {
+            png_bytep     trans        = png_bytep    ( NULL );
+            png_color_16p trans_values = png_color_16p( NULL );
+
+            this->_info._valid_transparency_factors = png_get_tRNS( get_struct()
+                                                                  , get_info()
+                                                                  , &trans
+                                                                  , &this->_info._num_trans
+                                                                  , &trans_values
+                                                                  );
+
+            if( trans )
+            {
+                //@todo What to do, here? How do I know the length of the "trans" array?
+            }
+
+            if( this->_info._num_trans )
+            {
+                this->_info._trans_values.resize( this->_info._num_trans );
+                std::copy( trans_values
+                         , trans_values + this->_info._num_trans
+                         , &this->_info._trans_values.front()
+                         );
+            }
+        }
+
+        // @todo One day!
+/*
+        if( false )
+        {
+            png_unknown_chunkp unknowns = png_unknown_chunkp( NULL );
+            int num_unknowns = static_cast< int >( png_get_unknown_chunks( get_struct()
+                                                                         , get_info()
+                                                                         , &unknowns
+                                                                         )
+                                                 );
+        }
+*/
+    }
+
+protected:
+
+    static void read_data( png_structp png_ptr
+                         , png_bytep   data
+                         , png_size_t length
+                         )
+    {
+        static_cast<Device*>(png_get_io_ptr(png_ptr) )->read( data
+                                                            , length );
+    }
+
+    static void flush( png_structp png_ptr )
+    {
+        static_cast<Device*>(png_get_io_ptr(png_ptr) )->flush();
+    }
+
+
+    static int read_user_chunk_callback( png_struct*        /* png_ptr */
+                                       , png_unknown_chunkp /* chunk */
+                                       )
+    {
+        // @todo
+        return 0;
+    }
+
+    static void read_row_callback( png_structp /* png_ptr    */
+                                 , png_uint_32 /* row_number */
+                                 , int         /* pass       */
+                                 )
+    {
+        // @todo
+    }
+
+public:
+
+    Device _io_dev;
+
+    image_read_settings< png_tag > _settings;
+    image_read_info    < png_tag > _info;
+
+    std::size_t _scanline_length;
+
+    std::size_t _number_passes;
+};
+
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNG_IO_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/png/scanline_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/png/scanline_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,180 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_PNG_IO_SCANLINE_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_PNG_IO_SCANLINE_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/gil_all.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+
+#include "reader_backend.hpp"
+#include "is_allowed.hpp"
+
+namespace boost { namespace gil { 
+
+///
+/// PNG Reader
+///
+template< typename Device >
+class scanline_reader< Device
+                     , png_tag
+                     >
+    : public reader_backend< Device
+                           , png_tag
+                           >
+{
+private:
+
+    typedef scanline_reader< Device
+                           , png_tag
+                           > this_t;
+
+public:
+
+    typedef reader_backend< Device, png_tag > backend_t;
+
+public:
+
+    //
+    // Constructor
+    //
+    scanline_reader( const Device&                         io_dev
+                   , const image_read_settings< png_tag >& settings
+                   )
+    : reader_backend< Device
+                    , png_tag
+                    >( io_dev
+                     , settings
+                     )
+    {
+        initialize();
+    }
+
+    void read( byte_t* dst, int pos )
+    {
+        read_scanline( dst );
+    }
+
+    /// Skip over a scanline.
+    void skip( byte_t* dst, int )
+    {
+        read_scanline( dst );
+    }
+
+    void clean_up() {}
+
+private:
+
+    void initialize()
+    {
+        // Now it's time for some transformations.
+
+        if( little_endian() )
+        {
+            if( this->_info._bit_depth == 16 )
+            {
+                // Swap bytes of 16 bit files to least significant byte first.
+                png_set_swap( this->get()->_struct );
+            }
+
+            if( this->_info._bit_depth < 8 )
+            {
+                // swap bits of 1, 2, 4 bit packed pixel formats
+                png_set_packswap( this->get()->_struct );
+            }
+        }
+
+        if( this->_info._color_type == PNG_COLOR_TYPE_PALETTE )
+        {
+            png_set_palette_to_rgb( this->get()->_struct );
+        }
+
+        if( this->_info._num_trans > 0 )
+        {
+            png_set_tRNS_to_alpha( this->get()->_struct );
+        }
+
+        // Tell libpng to handle the gamma conversion for you.  The final call
+        // is a good guess for PC generated images, but it should be configurable
+        // by the user at run time by the user.  It is strongly suggested that
+        // your application support gamma correction.
+        if( this->_settings._apply_screen_gamma )
+        {
+            // png_set_gamma will change the image data!
+
+#ifdef BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+        png_set_gamma( this->get()->_struct
+                     , this->_settings._screen_gamma
+                     , this->_info._file_gamma
+                     );
+#else
+        png_set_gamma( this->get()->_struct
+                     , this->_settings._screen_gamma
+                     , this->_info._file_gamma
+                     );
+#endif // BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+        }
+
+        // Interlaced images are not supported.
+        this->_number_passes = png_set_interlace_handling( this->get()->_struct );
+        io_error_if( this->_number_passes != 1
+                   , "scanline_read_iterator cannot read interlaced png images."
+                   );
+
+
+        // The above transformation might have changed the bit_depth and color type.
+        png_read_update_info( this->get()->_struct
+                            , this->get()->_info
+                            );
+
+        this->_info._bit_depth = png_get_bit_depth( this->get()->_struct
+                                                  , this->get()->_info
+                                                  );
+
+        this->_info._num_channels = png_get_channels( this->get()->_struct
+                                                    , this->get()->_info
+                                                    );
+
+        this->_info._color_type = png_get_color_type( this->get()->_struct
+                                                    , this->get()->_info
+                                                    );
+
+        this->_scanline_length = png_get_rowbytes( this->get()->_struct
+                                                 , this->get()->_info
+                                                 );
+    }
+
+    void read_scanline( byte_t* dst )
+    {
+        png_read_row( this->get()->_struct
+                    , dst
+                    , NULL
+                    );
+    }
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_PNG_IO_SCANLINE_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/png/supported_types.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/png/supported_types.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,366 @@
+/*
+    Copyright 2007-2008 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_SUPPORTED_TYPES_HPP
+#define BOOST_GIL_EXTENSION_IO_PNG_SUPPORTED_TYPES_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#ifdef BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+#include <boost/gil/extension/toolbox/gray_alpha.hpp>
+#endif // BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+namespace boost { namespace gil { namespace detail {
+
+static const size_t PNG_BYTES_TO_CHECK = 4;
+
+// Read support
+template< png_bitdepth::type   BitDepth
+        , png_color_type::type ColorType
+        >
+struct png_rw_support_base
+{
+    static const png_bitdepth::type   _bit_depth  = BitDepth;
+    static const png_color_type::type _color_type = ColorType;
+};
+
+template< typename Channel
+        , typename ColorSpace
+        >
+struct png_read_support : read_support_false
+                        , png_rw_support_base< 1
+                                             , PNG_COLOR_TYPE_GRAY
+                                             > {};
+
+template< typename BitField
+        , bool     Mutable
+        >
+struct png_read_support< packed_dynamic_channel_reference< BitField
+                                                         , 1
+                                                         , Mutable
+                                                         >
+                       , gray_t
+                       > : read_support_true
+                         , png_rw_support_base< 1
+                                              , PNG_COLOR_TYPE_GRAY
+                                              > {};
+
+template< typename BitField
+        , bool     Mutable
+        >
+struct png_read_support< packed_dynamic_channel_reference< BitField
+                                                         , 2
+                                                         , Mutable
+                                                         >
+                       , gray_t
+                       > : read_support_true
+                         , png_rw_support_base< 2
+                                              , PNG_COLOR_TYPE_GRAY
+                                              > {};
+
+template< typename BitField
+        , bool     Mutable
+        >
+struct png_read_support< packed_dynamic_channel_reference< BitField
+                                                         , 4
+                                                         , Mutable
+                                                         >
+                       , gray_t
+                       > : read_support_true
+                         , png_rw_support_base< 4
+                                              , PNG_COLOR_TYPE_GRAY
+                                              > {};
+
+template<>
+struct png_read_support< bits8
+                       , gray_t
+                       > : read_support_true
+                         , png_rw_support_base< 8
+                                              , PNG_COLOR_TYPE_GRAY
+                                              > {};
+
+#ifdef BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+template<>
+struct png_read_support< bits8
+                       , gray_alpha_t
+                       > : read_support_true
+                         , png_rw_support_base< 8
+                                              , PNG_COLOR_TYPE_GA
+                                              > {};
+#endif // BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+template<>
+struct png_read_support< bits8
+                       , rgb_t
+                       > : read_support_true
+                         , png_rw_support_base< 8
+                                              , PNG_COLOR_TYPE_RGB
+                                              > {};
+
+template<>
+struct png_read_support< bits8
+                       , rgba_t
+                       > : read_support_true
+                         , png_rw_support_base< 8
+                                              , PNG_COLOR_TYPE_RGBA
+                                              > {};
+
+template<>
+struct png_read_support< bits16
+                       , gray_t
+                       > : read_support_true
+                         , png_rw_support_base< 16
+                                              , PNG_COLOR_TYPE_GRAY
+                                              > {};
+
+template<>
+struct png_read_support< bits16
+                       , rgb_t
+                       > : read_support_true
+                         , png_rw_support_base< 16
+                                              , PNG_COLOR_TYPE_RGB
+                                              > {};
+
+template<>
+struct png_read_support< bits16
+                       , rgba_t
+                       > : read_support_true
+                         , png_rw_support_base< 16
+                                              , PNG_COLOR_TYPE_RGBA
+                                              > {};
+
+#ifdef BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+template<>
+struct png_read_support< bits16
+                       , gray_alpha_t
+                       > : read_support_true
+                         , png_rw_support_base< 16
+                                              , PNG_COLOR_TYPE_GA
+                                              > {};
+#endif // BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+// Write support
+
+template< typename Channel
+        , typename ColorSpace
+        >
+struct png_write_support : write_support_false
+                         , png_rw_support_base< 1
+                                              , PNG_COLOR_TYPE_GRAY
+                                              > {};
+
+template< typename BitField
+        , bool     Mutable
+        >
+struct png_write_support< packed_dynamic_channel_reference< BitField
+                                                          , 1
+                                                          , Mutable
+                                                          > 
+                        , gray_t
+                        > : write_support_true
+                          , png_rw_support_base< 1
+                                               , PNG_COLOR_TYPE_GRAY
+                                               >
+{};
+
+template< typename BitField
+        , bool     Mutable
+        >
+struct png_write_support< packed_dynamic_channel_reference< BitField
+                                                          , 1
+                                                          , Mutable
+                                                          > const
+                        , gray_t
+                        > : write_support_true
+                          , png_rw_support_base< 1
+                                               , PNG_COLOR_TYPE_GRAY
+                                               >
+{};
+
+template< typename BitField
+        , bool     Mutable
+        >
+struct png_write_support< packed_dynamic_channel_reference< BitField
+                                                          , 2
+                                                          , Mutable
+                                                          > 
+                        , gray_t
+                        > : write_support_true
+                          , png_rw_support_base< 2
+                                               , PNG_COLOR_TYPE_GRAY
+                                               >
+{};
+
+template< typename BitField
+        , bool     Mutable
+        >
+struct png_write_support< packed_dynamic_channel_reference< BitField
+                                                          , 2
+                                                          , Mutable
+                                                          > const
+                        , gray_t
+                        > : write_support_true
+                          , png_rw_support_base< 2
+                                               , PNG_COLOR_TYPE_GRAY
+                                               >
+{};
+
+template< typename BitField
+        , bool     Mutable
+        >
+struct png_write_support< packed_dynamic_channel_reference< BitField
+                                                          , 4
+                                                          , Mutable
+                                                          > 
+                        , gray_t
+                        > : write_support_true
+                          , png_rw_support_base< 4
+                                               , PNG_COLOR_TYPE_GRAY
+                                               >
+{};
+
+template< typename BitField
+        , bool     Mutable
+        >
+struct png_write_support< packed_dynamic_channel_reference< BitField
+                                                          , 4
+                                                          , Mutable
+                                                          > const
+                        , gray_t
+                        > : write_support_true
+                          , png_rw_support_base< 4
+                                               , PNG_COLOR_TYPE_GRAY
+                                               >
+{};
+
+template<>
+struct png_write_support< bits8
+                        , gray_t
+                        > : write_support_true
+                          , png_rw_support_base< 8
+                                               , PNG_COLOR_TYPE_GRAY
+                                               >
+{};
+
+#ifdef BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+template<>
+struct png_write_support< bits8
+                        , gray_alpha_t
+                        > : write_support_true
+                          , png_rw_support_base< 8
+                                               , PNG_COLOR_TYPE_GA
+                                               >
+{};
+#endif // BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+template<>
+struct png_write_support< bits8
+                        , rgb_t
+                        > : write_support_true
+                          , png_rw_support_base< 8
+                                               , PNG_COLOR_TYPE_RGB
+                                               >
+{};
+
+template<>
+struct png_write_support< bits8
+                        , rgba_t
+                        > : write_support_true
+                          , png_rw_support_base< 8
+                                               , PNG_COLOR_TYPE_RGBA
+                                               >
+{};
+
+template<>
+struct png_write_support< bits16
+                        , gray_t
+                        > : write_support_true
+                          , png_rw_support_base< 16
+                                               , PNG_COLOR_TYPE_GRAY
+                                               >
+{};
+
+template<>
+struct png_write_support< bits16
+                        , rgb_t
+                        > : write_support_true
+                          , png_rw_support_base< 16
+                                               , PNG_COLOR_TYPE_RGB
+                                               >
+{};
+
+template<>
+struct png_write_support< bits16
+                        , rgba_t
+                        > : write_support_true
+                          , png_rw_support_base< 16
+                                               , PNG_COLOR_TYPE_RGBA
+                                               >
+{};
+
+#ifdef BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+template<>
+struct png_write_support< bits16
+                        , gray_alpha_t
+                        > : write_support_true
+                          , png_rw_support_base< 16
+                                               , PNG_COLOR_TYPE_GA
+                                               >
+{};
+#endif // BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+
+} // namespace detail
+
+template< typename Pixel >
+struct is_read_supported< Pixel
+                        , png_tag
+                        >
+    : mpl::bool_< detail::png_read_support< typename channel_type< Pixel >::type
+                                          , typename color_space_type< Pixel >::type
+                                          >::is_supported
+                >
+{
+    typedef detail::png_read_support< typename channel_type< Pixel >::type
+                                    , typename color_space_type< Pixel >::type
+                                    > parent_t;
+
+    static const png_bitdepth::type   _bit_depth  = parent_t::_bit_depth;
+    static const png_color_type::type _color_type = parent_t::_color_type;
+};
+
+template< typename Pixel >
+struct is_write_supported< Pixel
+                         , png_tag
+                         >
+    : mpl::bool_< detail::png_write_support< typename channel_type< Pixel >::type
+                                           , typename color_space_type< Pixel >::type
+                                           >::is_supported
+                > 
+{
+    typedef detail::png_write_support< typename channel_type< Pixel >::type
+                                     , typename color_space_type< Pixel >::type
+                                     > parent_t;
+
+    static const png_bitdepth::type   _bit_depth  = parent_t::_bit_depth;
+    static const png_color_type::type _color_type = parent_t::_color_type;
+};
+
+} // namespace gil
+} // namespace boost
+
+
+#endif // BOOST_GIL_EXTENSION_IO_PNG_SUPPORTED_TYPES_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/png/write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/png/write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,240 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_PNG_IO_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_PNG_IO_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+// taken from jpegxx - https://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/ijg_headers.hpp
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_C_LIB_COMPILED_AS_CPLUSPLUS
+    extern "C" {
+#else
+    // DONT_USE_EXTERN_C introduced in v7 of the IJG library.
+    // By default the v7 IJG headers check for __cplusplus being defined and
+    // wrap the content in an 'extern "C"' block if it's present.
+    // When DONT_USE_EXTERN_C is defined, this wrapping is not performed.
+    #ifndef DONT_USE_EXTERN_C
+        #define DONT_USE_EXTERN_C 1
+    #endif
+#endif
+
+#include <png.h>
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_C_LIB_COMPILED_AS_CPLUSPLUS
+    }
+#endif
+
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+
+#include "writer_backend.hpp"
+
+namespace boost { namespace gil {
+
+namespace detail {
+
+struct png_write_is_supported
+{
+    template< typename View >
+    struct apply 
+        : public is_write_supported< typename get_pixel_type< View >::type
+                                   , png_tag
+                                   >
+    {};
+};
+
+} // namespace detail
+
+///
+/// PNG Writer
+///
+template< typename Device >
+class writer< Device
+            , png_tag
+            > 
+    : public writer_backend< Device
+                           , png_tag
+                           >
+{
+
+public:
+
+    typedef writer_backend< Device , png_tag > backend_t;
+
+    writer( const Device&                      io_dev
+          , const image_write_info< png_tag >& info
+          )
+    : backend_t( io_dev
+               , info
+               )
+    {}
+
+
+    template< typename View >
+    void apply( const View& view )
+    {
+        io_error_if( view.width() == 0 && view.height() == 0
+                   , "png format cannot handle empty views."
+                   );
+
+        this->write_header( view );
+
+        write_view( view
+                  , typename is_bit_aligned< typename View::value_type >::type()
+                  );
+    }
+
+private:
+
+    template<typename View>
+    void write_view( const View& view
+                   ,  mpl::false_       // is bit aligned
+                   )
+    {
+        typedef typename get_pixel_type< View >::type pixel_t;
+
+        typedef detail::png_write_support< typename channel_type    < pixel_t >::type
+                                         , typename color_space_type< pixel_t >::type
+                                         > png_rw_info;
+
+        if( little_endian() )
+        {
+            if( png_rw_info::_bit_depth == 16 )
+            {
+                png_set_swap( this->get_struct() );
+            }
+
+            if( png_rw_info::_bit_depth < 8 )
+            {
+                png_set_packswap( this->get_struct() );
+            }
+        }
+
+        std::vector< pixel< typename channel_type< View >::type
+                          , layout<typename color_space_type< View >::type >
+                          >
+                   > row_buffer( view.width() );
+
+        for( int y = 0; y != view.height(); ++ y)
+        {
+            std::copy( view.row_begin( y )
+                     , view.row_end  ( y )
+                     , row_buffer.begin()
+                     );
+
+            png_write_row( this->get_struct()
+                         , reinterpret_cast< png_bytep >( row_buffer.data() )
+                         );
+        }
+
+        png_write_end( this->get_struct()
+                     , this->get_info()
+                     );
+    }
+
+    template<typename View>
+    void write_view( const View& view
+                   , mpl::true_         // is bit aligned
+                   )
+    {
+        typedef detail::png_write_support< typename kth_semantic_element_type< typename View::value_type
+                                                                             , 0
+                                                                             >::type
+                                         , typename color_space_type<View>::type
+                                         > png_rw_info;
+
+        if (little_endian() )
+        {
+            if( png_rw_info::_bit_depth == 16 )
+            {
+                png_set_swap( this->get_struct() );
+            }
+
+            if( png_rw_info::_bit_depth < 8 )
+            {
+                png_set_packswap( this->get_struct() );
+            }
+        }
+
+        detail::row_buffer_helper_view< View > row_buffer( view.width()
+                                                         , false
+                                                         );
+
+        for( int y = 0; y != view.height(); ++y )
+        {
+            std::copy( view.row_begin( y )
+                     , view.row_end  ( y )
+                     , row_buffer.begin()
+                     );
+
+            png_write_row( this->get_struct()
+                         , reinterpret_cast< png_bytep >( row_buffer.data() )
+                         );
+        }
+
+        png_free_data( this->get_struct()
+                     , this->get_info()
+                     , PNG_FREE_UNKN
+                     , -1
+                     );
+
+        png_write_end( this->get_struct()
+                     , this->get_info()
+                     );
+    }
+};
+
+///
+/// PNG Dynamic Image Writer
+///
+template< typename Device >
+class dynamic_image_writer< Device
+                          , png_tag
+                          >
+    : public writer< Device
+                   , png_tag
+                   >
+{
+    typedef writer< Device
+                  , png_tag
+                  > parent_t;
+
+public:
+
+    dynamic_image_writer( const Device&                      io_dev
+                        , const image_write_info< png_tag >& info
+)
+    : parent_t( io_dev
+              , info
+              )
+    {}
+
+    template< typename Views >
+    void apply( const any_image_view< Views >& views )
+    {
+        detail::dynamic_io_fnobj< detail::png_write_is_supported
+                                , parent_t
+                                > op( this );
+
+        apply_operation( views, op );
+    }
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_PNG_IO_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/png/writer_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/png/writer_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,409 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_IO_WRITER_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_PNG_IO_WRITER_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+#include <boost/gil/extension/io_new/detail/base.hpp>
+
+#include <boost/gil/extension/io_new/png_tags.hpp>
+
+#include "base.hpp"
+#include "supported_types.hpp"
+
+namespace boost { namespace gil {
+
+///
+/// PNG Writer Backend
+///
+template< typename Device >
+struct writer_backend< Device
+                     , png_tag
+                     >
+    : public detail::png_struct_info_wrapper
+{
+
+private:
+
+    typedef writer_backend< Device
+                          , png_tag
+                          > this_t;
+
+public:
+
+    typedef png_tag format_tag_t;
+
+public:
+
+    ///
+    /// Constructor
+    ///
+    writer_backend( const Device&                      io_dev
+                  , const image_write_info< png_tag >& info
+                  )
+    : png_struct_info_wrapper( false )
+    , _io_dev( io_dev )
+    , _info( info )
+    {
+        // Create and initialize the png_struct with the desired error handler
+        // functions.  If you want to use the default stderr and longjump method,
+        // you can supply NULL for the last three parameters.  We also check that
+        // the library version is compatible with the one used at compile time,
+        // in case we are using dynamically linked libraries.  REQUIRED.
+        get()->_struct = png_create_write_struct( PNG_LIBPNG_VER_STRING
+                                                , NULL  // user_error_ptr
+                                                , NULL  // user_error_fn
+                                                , NULL  // user_warning_fn
+                                                );
+
+        io_error_if( get_struct() == NULL
+                   , "png_writer: fail to call png_create_write_struct()"
+                   );
+
+        // Allocate/initialize the image information data.  REQUIRED 
+        get()->_info = png_create_info_struct( get_struct() );
+
+        if( get_info() == NULL )
+        {
+            png_destroy_write_struct( &get()->_struct
+                                    , NULL
+                                    );
+
+            io_error( "png_writer: fail to call png_create_info_struct()" );
+        }
+
+        // Set error handling.  REQUIRED if you aren't supplying your own
+        // error handling functions in the png_create_write_struct() call.
+        if( setjmp( png_jmpbuf( get_struct() )))
+        {
+            //free all of the memory associated with the png_ptr and info_ptr
+            png_destroy_write_struct( &get()->_struct
+                                    , &get()->_info
+                                    );
+
+            io_error( "png_writer: fail to call setjmp()" );
+        }
+
+        init_io( get_struct() );
+    }
+
+protected:
+
+    template< typename View >
+    void write_header( const View& view )
+    {
+        typedef detail::png_write_support< typename channel_type< typename get_pixel_type< View >::type >::type
+                                         , typename color_space_type< View >::type
+                                         > png_rw_info_t;
+
+        // Set the image information here.  Width and height are up to 2^31,
+        // bit_depth is one of 1, 2, 4, 8, or 16, but valid values also depend on
+        // the color_type selected. color_type is one of PNG_COLOR_TYPE_GRAY,
+        // PNG_COLOR_TYPE_GRAY_ALPHA, PNG_COLOR_TYPE_PALETTE, PNG_COLOR_TYPE_RGB,
+        // or PNG_COLOR_TYPE_RGB_ALPHA.  interlace is either PNG_INTERLACE_NONE or
+        // PNG_INTERLACE_ADAM7, and the compression_type and filter_type MUST
+        // currently be PNG_COMPRESSION_TYPE_BASE and PNG_FILTER_TYPE_BASE. REQUIRED
+        png_set_IHDR( get_struct()
+                    , get_info()
+                    , static_cast< png_image_width::type  >( view.width()  )
+                    , static_cast< png_image_height::type >( view.height() )
+                    , static_cast< png_bitdepth::type     >( png_rw_info_t::_bit_depth )
+                    , static_cast< png_color_type::type   >( png_rw_info_t::_color_type )
+                    , _info._interlace_method
+                    , _info._compression_method
+                    , _info._filter_method
+                    );
+
+#ifdef BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+        if( _info._valid_cie_colors )
+        {
+            png_set_cHRM( get_struct()
+                        , get_info()
+                        , _info._white_x
+                        , _info._white_y
+                        , _info._red_x
+                        , _info._red_y
+                        , _info._green_x
+                        , _info._green_y
+                        , _info._blue_x
+                        , _info._blue_y
+                        );
+        }
+
+        if( _info._valid_file_gamma )
+        {
+            png_set_gAMA( get_struct()
+                        , get_info()
+                        , _info._gamma
+                        );
+        }
+#else
+        if( _info._valid_cie_colors )
+        {
+            png_set_cHRM_fixed( get_struct()
+                              , get_info()
+                              , _info._white_x
+                              , _info._white_y
+                              , _info._red_x
+                              , _info._red_y
+                              , _info._green_x
+                              , _info._green_y
+                              , _info._blue_x
+                              , _info._blue_y
+                              );
+        }
+
+        if( _info._valid_file_gamma )
+        {
+            png_set_gAMA_fixed( get_struct()
+                              , get_info()
+                              , _info._file_gamma
+                              );
+        }
+#endif // BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+
+        if( _info._valid_icc_profile )
+        {
+#if PNG_LIBPNG_VER_MINOR >= 5
+            png_set_iCCP( get_struct()
+                        , get_info()
+                        , const_cast< png_charp >( _info._icc_name.c_str() )
+                        , _info._iccp_compression_type
+                        , reinterpret_cast< png_const_bytep >( _info._profile.c_str() )
+                        , _info._profile_length
+                        );
+#else
+            png_set_iCCP( get_struct()
+                        , get_info()
+                        , const_cast< png_charp >( _info._icc_name.c_str() )
+                        , _info._iccp_compression_type
+                        , const_cast< png_charp >( _info._profile.c_str() )
+                        , _info._profile_length
+                        );
+#endif
+        }
+
+        if( _info._valid_intent )
+        {
+            png_set_sRGB( get_struct()
+                        , get_info()
+                        , _info._intent
+                        );
+        }
+
+        if( _info._valid_palette )
+        {
+            png_set_PLTE( get_struct()
+                        , get_info()
+                        , const_cast< png_colorp >( &_info._palette.front() )
+                        , _info._num_palette
+                        );
+        }
+
+        if( _info._valid_background )
+        {
+            png_set_bKGD( get_struct()
+                        , get_info()
+                        , const_cast< png_color_16p >( &_info._background )
+                        );
+        }
+
+        if( _info._valid_histogram )
+        {
+            png_set_hIST( get_struct()
+                        , get_info()
+                        , const_cast< png_uint_16p >( &_info._histogram.front() )
+                        );
+        }
+
+        if( _info._valid_offset )
+        {
+            png_set_oFFs( get_struct()
+                        , get_info()
+                        , _info._offset_x
+                        , _info._offset_y
+                        , _info._off_unit_type
+                        );
+        }
+
+        if( _info._valid_pixel_calibration )
+        {
+            std::vector< const char* > params( _info._num_params );
+            for( std::size_t i = 0; i < params.size(); ++i )
+            {
+                params[i] = _info._params[ i ].c_str();
+            }
+
+            png_set_pCAL( get_struct()
+                        , get_info()
+                        , const_cast< png_charp >( _info._purpose.c_str() )
+                        , _info._X0
+                        , _info._X1
+                        , _info._cal_type
+                        , _info._num_params
+                        , const_cast< png_charp  >( _info._units.c_str() )
+                        , const_cast< png_charpp >( &params.front()     )
+                        );
+        }
+
+        if( _info._valid_resolution )
+        {
+            png_set_pHYs( get_struct()
+                        , get_info()
+                        , _info._res_x
+                        , _info._res_y
+                        , _info._phy_unit_type
+                        );
+        }
+
+        if( _info._valid_significant_bits )
+        {
+            png_set_sBIT( get_struct()
+                        , get_info()
+                        , const_cast< png_color_8p >( &_info._sig_bits )
+                        );
+        }
+
+#ifdef BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED 
+        if( _info._valid_scale_factors )
+        {
+            png_set_sCAL( get_struct()
+                        , get_info()
+                        , _info._scale_unit
+                        , _info._scale_width
+                        , _info._scale_height
+                        );
+        }
+#else
+#ifdef BOOST_GIL_IO_PNG_FIXED_POINT_SUPPORTED
+
+        if( _info._valid_scale_factors )
+        {
+            png_set_sCAL_s( get_struct()
+                          , get_info()
+                          , _scale_unit
+                          , const_cast< png_charp >( _scale_width.c_str()  )
+                          , const_cast< png_charp >( _scale_height.c_str() )
+                          );
+        }
+#endif // BOOST_GIL_IO_PNG_FIXED_POINT_SUPPORTED
+#endif // BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+
+
+        if( _info._valid_text )
+        {
+            std::vector< png_text > texts( _info._num_text );
+            for( std::size_t i = 0; i < texts.size(); ++i )
+            {
+                png_text pt;
+                pt.compression = _info._text[i]._compression;
+                pt.key         = const_cast< png_charp >( _info._text[i]._key.c_str()  );
+                pt.text        = const_cast< png_charp >( _info._text[i]._text.c_str() );
+                pt.text_length = _info._text[i]._text.length();
+
+                texts[i] = pt;
+            }
+
+            png_set_text( get_struct()
+                        , get_info()
+                        , &texts.front()
+                        , _info._num_text
+                        );
+        }
+
+        if( _info._valid_modification_time )
+        {
+            png_set_tIME( get_struct()
+                        , get_info()
+                        , const_cast< png_timep >( &_info._mod_time )
+                        );
+        }
+
+        if( _info._valid_transparency_factors )
+        {
+            int sample_max = ( 1 << _info._bit_depth );
+
+            /* libpng doesn't reject a tRNS chunk with out-of-range samples */
+            if( !(  (  _info._color_type == PNG_COLOR_TYPE_GRAY 
+                    && (int) _info._trans_values[0].gray > sample_max
+                    )
+                 || (  _info._color_type == PNG_COLOR_TYPE_RGB
+                    &&(  (int) _info._trans_values[0].red   > sample_max 
+                      || (int) _info._trans_values[0].green > sample_max
+                      || (int) _info._trans_values[0].blue  > sample_max
+                      )
+                    )
+                 )
+              )
+            {
+                //@todo Fix that once reading transparency values works
+/*
+                png_set_tRNS( get_struct()
+                            , get_info()
+                            , trans
+                            , num_trans
+                            , trans_values
+                            );
+*/
+            }
+        }
+
+        png_write_info( get_struct()
+                      , get_info()
+                      );
+    }
+
+protected:
+
+    static void write_data( png_structp png_ptr
+                          , png_bytep   data
+                          , png_size_t  length
+                          )
+    {
+        static_cast< Device* >( png_get_io_ptr( png_ptr ))->write( data
+                                                                 , length );
+    }
+
+    static void flush( png_structp png_ptr )
+    {
+        static_cast< Device* >(png_get_io_ptr(png_ptr) )->flush();
+    }
+
+private:
+
+    void init_io( png_structp png_ptr )
+    {
+        png_set_write_fn( png_ptr
+                        , static_cast< void* >        ( &this->_io_dev      )
+                        , static_cast< png_rw_ptr >   ( &this_t::write_data )
+                        , static_cast< png_flush_ptr >( &this_t::flush      )
+                        );
+    }
+
+public:
+
+    Device _io_dev;
+
+    image_write_info< png_tag > _info;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNG_IO_WRITER_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/is_allowed.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/is_allowed.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,60 @@
+/*
+    Copyright 2009 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_IO_IS_ALLOWED_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_IO_IS_ALLOWED_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost { namespace gil { namespace detail {
+
+template< typename View >
+bool is_allowed( const image_read_info< pnm_tag >& info
+               , mpl::true_   // is read_and_no_convert
+               )
+{
+    pnm_image_type::type asc_type = is_read_supported< typename get_pixel_type< View >::type
+                                                     , pnm_tag
+                                                     >::_asc_type;
+
+    pnm_image_type::type bin_type = is_read_supported< typename get_pixel_type< View >::type
+                                                     , pnm_tag
+                                                     >::_bin_type;
+    if( info._type == pnm_image_type::mono_asc_t::value )
+    {
+        // ascii mono images are read gray8_image_t
+        return (  asc_type == pnm_image_type::gray_asc_t::value );
+    }
+
+
+    return (  asc_type == info._type
+           || bin_type == info._type
+           );
+}
+
+template< typename View >
+bool is_allowed( const image_read_info< pnm_tag >& /* info */
+               , mpl::false_  // is read_and_convert
+               )
+{
+    return true;
+}
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNM_IO_IS_ALLOWED_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,457 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_IO_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_IO_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <vector>
+#include <boost/bind.hpp>
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/pnm_tags.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+#include <boost/gil/extension/io_new/detail/bit_operations.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+
+#include "reader_backend.hpp"
+#include "is_allowed.hpp"
+
+
+namespace boost { namespace gil {
+
+///
+/// PNM Reader
+///
+template< typename Device
+        , typename ConversionPolicy
+        >
+class reader< Device
+            , pnm_tag
+            , ConversionPolicy
+            >
+    : public reader_base< pnm_tag
+                        , ConversionPolicy
+                        >
+    , public reader_backend< Device
+                           , pnm_tag
+                           >
+{
+
+private:
+
+    typedef reader< Device
+                  , pnm_tag
+                  , ConversionPolicy
+                  > this_t;
+
+    typedef typename ConversionPolicy::color_converter_type cc_t;
+
+public:
+
+    typedef reader_backend< Device, pnm_tag > backend_t;
+
+public:
+
+    reader( const Device&                         io_dev
+          , const image_read_settings< pnm_tag >& settings
+          )
+    : reader_base< pnm_tag
+                 , ConversionPolicy
+                 >()
+    , backend_t( io_dev
+               , settings
+               )
+    {}
+
+    reader( const Device&                         io_dev
+          , const cc_t&                           cc
+          , const image_read_settings< pnm_tag >& settings
+          )
+    : reader_base< pnm_tag
+                 , ConversionPolicy
+                 >( cc )
+    , backend_t( io_dev
+               , settings
+               )
+    {}
+
+    template<typename View>
+    void apply( const View& view )
+    {
+        typedef typename is_same< ConversionPolicy
+                                , detail::read_and_no_convert
+                                >::type is_read_and_convert_t;
+
+        io_error_if( !detail::is_allowed< View >( this->_info
+                                                , is_read_and_convert_t()
+                                                )
+                   , "Image types aren't compatible."
+                   );
+
+        switch( this->_info._type )
+		{
+            // reading mono text is reading grayscale but with only two values
+			case pnm_image_type::mono_asc_t::value:
+			case pnm_image_type::gray_asc_t::value:
+            {
+                this->_scanline_length = this->_info._width;
+
+                read_text_data< gray8_view_t >( view ); 
+
+                break;
+            }
+
+			case pnm_image_type::color_asc_t::value:
+            {
+                this->_scanline_length = this->_info._width * num_channels< rgb8_view_t >::value;
+
+                read_text_data< rgb8_view_t  >( view );
+
+                break;
+            }
+
+			case pnm_image_type::mono_bin_t::value:
+            {
+                //gray1_image_t
+                this->_scanline_length = ( this->_info._width + 7 ) >> 3;
+
+                read_bin_data< gray1_image_t::view_t >( view );
+
+                break;
+            }
+
+			case pnm_image_type::gray_bin_t::value:
+            {
+                // gray8_image_t
+                this->_scanline_length = this->_info._width;
+
+                read_bin_data< gray8_view_t >( view );
+
+                break;
+            }
+
+			case pnm_image_type::color_bin_t::value:
+            {
+                // rgb8_image_t
+                this->_scanline_length = this->_info._width * num_channels< rgb8_view_t >::value;
+
+                read_bin_data< rgb8_view_t >( view );
+                break;
+            }
+		}
+    }
+
+private:
+
+    template< typename View_Src
+            , typename View_Dst
+            >
+    void read_text_data( const View_Dst& dst )
+    {
+        typedef typename View_Dst::y_coord_t y_t;
+
+        byte_vector_t row( this->_scanline_length );
+
+        //Skip scanlines if necessary.
+        for( int y = 0; y <  this->_settings._top_left.y; ++y )
+        {
+            read_text_row< View_Src >( dst, row, y, false );
+        }
+
+        for( y_t y = 0; y < dst.height(); ++y )
+        {
+            read_text_row< View_Src >( dst, row, y, true );
+        }
+    }
+
+    template< typename View_Src
+            , typename View_Dst
+            >
+    void read_text_row( const View_Dst&              dst
+                      , byte_vector_t&               row
+                      , typename View_Dst::y_coord_t y
+                      , bool                         process
+                      )
+    {
+        View_Src src = interleaved_view( this->_info._width
+                                       , 1
+                                       , (typename View_Src::value_type*) &row.front()
+                                       , this->_scanline_length
+                                       );
+
+        for( uint32_t x = 0; x < this->_scanline_length; ++x )
+        {
+            for( uint32_t k = 0; ; )
+            {
+				int ch = this->_io_dev.getc_unchecked();
+
+				if( isdigit( ch ))
+				{
+                    buf[ k++ ] = static_cast< char >( ch );
+				}
+				else if( k )
+				{
+					buf[ k ] = 0;
+					break;
+				}
+				else if( ch == EOF || !isspace( ch ))
+				{
+					return;
+				}
+            }
+
+            if( process )
+            {
+                int value = atoi( buf );
+
+                if( this->_info._max_value == 1 )
+                {
+                    typedef typename channel_type< typename get_pixel_type< View_Dst >::type >::type channel_t;
+
+                    // for pnm format 0 is white
+                    row[x] = ( value != 0 )
+                             ? typename channel_traits< channel_t >::value_type( 0 )
+                             : channel_traits< channel_t >::max_value();
+                }
+                else
+                {
+                    row[x] = static_cast< byte_t >( value );
+                }
+            }
+        }
+
+        if( process )
+        {
+            // We are reading a gray1_image like a gray8_image but the two pixel_t
+            // aren't compatible. Though, read_and_no_convert::read(...) wont work.
+            copy_data< View_Dst
+                     , View_Src >( dst
+                                 , src
+                                 , y
+                                 , typename is_same< View_Dst
+                                                   , gray1_image_t::view_t
+                                                   >::type()
+                                 );
+        }
+    }
+
+    template< typename View_Dst
+            , typename View_Src
+            >
+    void copy_data( const View_Dst&              dst
+                  , const View_Src&              src
+                  , typename View_Dst::y_coord_t y
+                  , mpl::true_ // is gray1_view
+                  )
+    {
+        if(  this->_info._max_value == 1 )
+        {
+            typename View_Dst::x_iterator it = dst.row_begin( y );
+
+            for( typename View_Dst::x_coord_t x = 0
+               ; x < dst.width()
+               ; ++x
+               )
+            {
+                it[x] = src[x];
+            }
+        }
+        else
+        {
+            copy_data( dst
+                     , src
+                     , y
+                     , mpl::false_()
+                     );
+        }
+    }
+
+    template< typename View_Dst
+            , typename View_Src
+            >
+    void copy_data( const View_Dst&              view
+                  , const View_Src&              src
+                  , typename View_Dst::y_coord_t y
+                  , mpl::false_ // is gray1_view
+                  )
+    {
+        typename View_Src::x_iterator beg = src.row_begin( 0 ) + this->_settings._top_left.x;
+        typename View_Src::x_iterator end = beg + this->_settings._dim.x;
+
+        this->_cc_policy.read( beg
+                             , end
+                             , view.row_begin( y )
+                             );
+    }
+
+
+    template< typename View_Src
+            , typename View_Dst
+            >
+    void read_bin_data( const View_Dst& view )
+    {
+        typedef typename View_Dst::y_coord_t y_t;
+        typedef typename is_bit_aligned<
+                    typename View_Src::value_type >::type is_bit_aligned_t;
+
+        typedef detail::row_buffer_helper_view< View_Src > rh_t;
+        rh_t rh( this->_scanline_length, true );
+
+        typename rh_t::iterator_t beg = rh.begin() + this->_settings._top_left.x;
+        typename rh_t::iterator_t end = beg + this->_settings._dim.x;
+
+        // For bit_aligned images we need to negate all bytes in the row_buffer
+        // to make sure that 0 is black and 255 is white.
+        detail::negate_bits< typename rh_t::buffer_t
+                           , is_bit_aligned_t
+                           > neg;
+
+        detail::swap_half_bytes< typename rh_t::buffer_t
+                               , is_bit_aligned_t
+                               > swhb;
+
+        //Skip scanlines if necessary.
+        for( y_t y = 0; y < this->_settings._top_left.y; ++y )
+        {
+            this->_io_dev.read( reinterpret_cast< byte_t* >( rh.data() )
+                        , this->_scanline_length
+                        );
+        }
+
+        for( y_t y = 0; y < view.height(); ++y )
+        {
+            this->_io_dev.read( reinterpret_cast< byte_t* >( rh.data() )
+                        , this->_scanline_length
+                        );
+
+            neg( rh.buffer() );
+            swhb( rh.buffer() );
+
+            this->_cc_policy.read( beg
+                                 , end
+                                 , view.row_begin( y )
+                                 );
+        }
+    }
+
+private:
+
+    char buf[16];
+
+};
+
+
+namespace detail { 
+
+struct pnm_type_format_checker
+{
+    pnm_type_format_checker( pnm_image_type::type type )
+    : _type( type )
+    {}
+
+    template< typename Image >
+    bool apply()
+    {
+        typedef is_read_supported< typename get_pixel_type< typename Image::view_t >::type
+                                 , pnm_tag
+                                 > is_supported_t;
+
+        return is_supported_t::_asc_type == _type
+            || is_supported_t::_bin_type == _type;
+    }
+
+private:
+
+    pnm_image_type::type _type;
+};
+
+struct pnm_read_is_supported
+{
+    template< typename View >
+    struct apply : public is_read_supported< typename get_pixel_type< View >::type
+                                           , pnm_tag
+                                           >
+    {};
+};
+
+} // namespace detail
+
+///
+/// PNM Dynamic Image Reader
+///
+template< typename Device
+        >
+class dynamic_image_reader< Device
+                          , pnm_tag
+                          >
+    : public reader< Device
+                   , pnm_tag
+                   , detail::read_and_no_convert
+                   >
+{
+    typedef reader< Device
+                  , pnm_tag
+                  , detail::read_and_no_convert
+                  > parent_t;
+
+public:
+
+    dynamic_image_reader( const Device&                         io_dev
+                        , const image_read_settings< pnm_tag >& settings
+                        )
+    : parent_t( io_dev
+              , settings
+              )
+    {}
+
+    template< typename Images >
+    void apply( any_image< Images >& images )
+    {
+        detail::pnm_type_format_checker format_checker( this->_info._type );
+
+        if( !construct_matched( images
+                              , format_checker
+                              ))
+        {
+            io_error( "No matching image type between those of the given any_image and that of the file" );
+        }
+        else
+        {
+            init_image( images
+                      , this->_settings
+                      );
+
+            detail::dynamic_io_fnobj< detail::pnm_read_is_supported
+                                    , parent_t
+                                    > op( this );
+
+            apply_operation( view( images )
+                           , op
+                           );
+        }
+    }
+};
+
+} // gil
+} // boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNM_IO_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/reader_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/reader_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,161 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_IO_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_IO_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/pnm_tags.hpp>
+
+namespace boost { namespace gil {
+
+///
+/// PNM Backend
+///
+template< typename Device >
+struct reader_backend< Device
+                     , pnm_tag
+                     >
+{
+public:
+
+    typedef pnm_tag format_tag_t;
+
+public:
+
+    reader_backend( const Device&                         io_dev
+                  , const image_read_settings< pnm_tag >& settings
+                  )
+    : _io_dev  ( io_dev   )
+    , _settings( settings )
+    , _info()
+
+    , _scanline_length( 0 )
+    {
+        read_header();    
+
+        if( _settings._dim.x == 0 )
+        {
+            _settings._dim.x = _info._width;
+        }
+
+        if( _settings._dim.y == 0 )
+        {
+            _settings._dim.y = _info._height;
+        }
+    }
+
+    void read_header()
+    {
+        // read signature
+        io_error_if( read_char() != 'P', "Invalid PNM signature" );
+
+        _info._type = read_char() - '0';
+
+		io_error_if( _info._type < pnm_image_type::mono_asc_t::value || _info._type > pnm_image_type::color_bin_t::value
+		           , "Invalid PNM file (supports P1 to P6)"
+		           );
+
+        _info._width  = read_int();
+        _info._height = read_int();
+
+        if( _info._type == pnm_image_type::mono_asc_t::value || _info._type == pnm_image_type::mono_bin_t::value )
+        {
+            _info._max_value = 1;
+        }
+        else
+        {
+            _info._max_value = read_int();
+
+		    io_error_if( _info._max_value > 255
+		               , "Unsupported PNM format (supports maximum value 255)"
+		               );
+        }
+    }
+
+private:
+
+    // Read a character and skip a comment if necessary.
+    char read_char()
+    {
+        char ch;
+
+        if(( ch = _io_dev.getc() ) == '#' )
+        {
+            // skip comment to EOL
+            do
+            {
+                ch = _io_dev.getc();
+            }
+            while (ch != '\n' && ch != '\r');
+        }
+
+        return ch;
+    }
+
+	unsigned int read_int()
+	{
+		char ch;
+
+        // skip whitespaces, tabs, and new lines
+		do
+		{
+			ch = read_char();
+		}
+		while (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r');
+
+		if( ch < '0' || ch > '9' )
+		{
+			io_error( "Unexpected characters reading decimal digits" );
+		}
+
+		unsigned val = 0;
+
+        do
+        {
+			unsigned dig = ch - '0';
+
+			if( val > INT_MAX / 10 - dig )
+			{
+				io_error( "Integer too large" );
+			}
+
+			val = val * 10 + dig;
+
+			ch = read_char();
+		}
+		while( '0' <= ch && ch <= '9' );
+
+		return val;
+	}
+
+
+public:
+
+    Device _io_dev;
+
+    image_read_settings< pnm_tag > _settings;
+    image_read_info< pnm_tag >     _info;
+
+    std::size_t _scanline_length;
+};
+
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNM_IO_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/scanline_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/scanline_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,260 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_IO_SCANLINE_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_IO_SCANLINE_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <vector>
+#include <boost/bind.hpp>
+#include <boost/function.hpp>
+
+#include <boost/gil/gil_all.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+#include <boost/gil/extension/io_new/detail/bit_operations.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+
+#include "reader_backend.hpp"
+#include "is_allowed.hpp"
+
+namespace boost { namespace gil {
+
+///
+/// PNM Reader
+///
+template< typename Device >
+class scanline_reader< Device
+                     , pnm_tag
+                     >
+    : public reader_backend< Device
+                           , pnm_tag
+                           >
+{
+private:
+
+    typedef scanline_reader< Device
+                           , pnm_tag
+                           > this_t;
+
+public:
+
+    typedef reader_backend< Device
+                          , pnm_tag
+                          > backend_t;
+
+
+public:
+    scanline_reader( Device&                                device
+                   , const image_read_settings< pnm_tag >& settings
+                   )
+    : backend_t( device
+               , settings
+               )
+    {
+        initialize();
+    }
+
+    void clean_up() {}
+
+    /// Read part of image defined by View and return the data.
+    void read( byte_t* dst, int pos )
+    {
+        _read_function( this, dst );
+    }
+
+    /// Skip over a scanline.
+    void skip( byte_t*, int )
+    {
+        _skip_function( this );
+    }
+
+private:
+
+    void initialize()
+    {
+        switch( this->_info._type )
+		{
+            // reading mono text is reading grayscale but with only two values
+			case pnm_image_type::mono_asc_t::value:  
+			case pnm_image_type::gray_asc_t::value:
+            {
+                this->_scanline_length = this->_info._width;
+
+                _read_function = boost::mem_fn( &this_t::read_text_row );
+                _skip_function = boost::mem_fn( &this_t::skip_text_row );
+
+                break;
+            }
+
+			case pnm_image_type::color_asc_t::value:
+            {
+                this->_scanline_length = this->_info._width * num_channels< rgb8_view_t >::value;
+
+                _read_function = boost::mem_fn( &this_t::read_text_row ); 
+                _skip_function = boost::mem_fn( &this_t::skip_text_row );
+
+                break;
+            }
+
+
+			case pnm_image_type::mono_bin_t::value:
+            {
+                //gray1_image_t
+                this->_scanline_length = ( this->_info._width + 7 ) >> 3;
+
+                _read_function = boost::mem_fn( &this_t::read_binary_bit_row );
+                _skip_function = boost::mem_fn( &this_t::skip_binary_row     );
+
+                break;
+            }
+
+			case pnm_image_type::gray_bin_t::value:
+            {
+                // gray8_image_t
+                this->_scanline_length = this->_info._width;
+
+                _read_function = boost::mem_fn( &this_t::read_binary_byte_row ); 
+                _skip_function = boost::mem_fn( &this_t::skip_binary_row      ); 
+
+                break;
+            }
+
+			case pnm_image_type::color_bin_t::value:
+            {
+                // rgb8_image_t
+                this->_scanline_length = this->_info._width * num_channels< rgb8_view_t >::value;
+
+                _read_function = boost::mem_fn( &this_t::read_binary_byte_row ); 
+                _skip_function = boost::mem_fn( &this_t::skip_binary_row      );
+
+                break;
+            }
+
+            default: { io_error( "Unsupported pnm file." ); break; }
+		}
+    }
+
+    void read_text_row( byte_t* dst )
+    {
+        for( std::size_t x = 0; x < this->_scanline_length; ++x )
+        {
+            for( uint32_t k = 0; ; )
+            {
+				int ch = this->_io_dev.getc_unchecked();
+
+				if( isdigit( ch ))
+				{
+                    _text_buffer[ k++ ] = static_cast< char >( ch );
+				}
+				else if( k )
+				{
+					_text_buffer[ k ] = 0;
+					break;
+				}
+				else if( ch == EOF || !isspace( ch ))
+				{
+					return;
+				}
+            }
+
+            int value = atoi( _text_buffer );
+
+            if( this->_info._max_value == 1 )
+            {
+                // for pnm format 0 is white
+                dst[x] = ( value != 0 )
+                            ? 0
+                            : 255;
+            }
+            else
+            {
+                dst[x] = static_cast< byte_t >( value );
+            }
+        }
+    }
+
+    void skip_text_row()
+    {
+        for( std::size_t x = 0; x < this->_scanline_length; ++x )
+        {
+            for( uint32_t k = 0; ; )
+            {
+				int ch = this->_io_dev.getc_unchecked();
+
+				if( isdigit( ch ))
+				{
+                    k++;
+				}
+				else if( k )
+				{
+					break;
+				}
+				else if( ch == EOF || !isspace( ch ))
+				{
+					return;
+				}
+            }
+        }
+    }
+
+
+    void read_binary_bit_row( byte_t* dst )
+    {
+        this->_io_dev.read( dst
+                    , this->_scanline_length
+                    );
+
+        _negate_bits    ( dst, this->_scanline_length );
+        _swap_half_bytes( dst, this->_scanline_length );
+
+    }
+
+    void read_binary_byte_row( byte_t* dst )
+    {
+        this->_io_dev.read( dst
+                    , this->_scanline_length
+                    );
+    }
+
+    void skip_binary_row()
+    {
+        this->_io_dev.seek( static_cast<long>( this->_scanline_length ), SEEK_CUR );
+    }
+
+private:
+
+    char _text_buffer[16];
+
+    // For bit_aligned images we need to negate all bytes in the row_buffer
+    // to make sure that 0 is black and 255 is white.
+    detail::negate_bits    < std::vector< byte_t >, mpl::true_ > _negate_bits;
+    detail::swap_half_bytes< std::vector< byte_t >, mpl::true_ > _swap_half_bytes;
+
+    boost::function< void ( this_t*, byte_t* ) > _read_function;
+    boost::function< void ( this_t* )          > _skip_function;
+};
+
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNM_IO_SCANLINE_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/supported_types.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/supported_types.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,146 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_SUPPORTED_TYPES_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_SUPPORTED_TYPES_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/mpl/not.hpp>
+#include <boost/type_traits/is_same.hpp>
+
+#include <boost/gil/channel.hpp>
+#include <boost/gil/color_base.hpp>
+
+namespace boost { namespace gil { namespace detail {
+
+// Read Support
+
+template< pnm_image_type::type ASCII_Type
+        , pnm_image_type::type Binary_Type
+        >
+struct pnm_rw_support_base
+{
+    static const pnm_image_type::type _asc_type = ASCII_Type;
+    static const pnm_image_type::type _bin_type = Binary_Type;
+};
+
+template< typename Channel
+        , typename ColorSpace
+        >
+struct pnm_read_support : read_support_false
+                        , pnm_rw_support_base< 0
+                                             , 0
+                                             > {};
+
+template< typename BitField, bool Mutable >
+struct pnm_read_support< packed_dynamic_channel_reference< BitField
+                                                         , 1
+                                                         , Mutable
+                                                         >
+                       , gray_t
+                       > : read_support_true
+                         , pnm_rw_support_base< pnm_image_type::mono_asc_t::value
+                                              , pnm_image_type::mono_bin_t::value
+                                              > {};
+
+template<>
+struct pnm_read_support< bits8
+                       , gray_t
+                       > : read_support_true
+                         , pnm_rw_support_base< pnm_image_type::gray_asc_t::value
+                                              , pnm_image_type::gray_bin_t::value
+                                              > {};
+
+
+template<>
+struct pnm_read_support< bits8
+                       , rgb_t
+                       > : read_support_true
+                         , pnm_rw_support_base< pnm_image_type::color_asc_t::value
+                                              , pnm_image_type::color_bin_t::value
+                                              > {};
+
+// Write support
+
+template< typename Channel
+        , typename ColorSpace
+        >
+struct pnm_write_support : write_support_false
+{};
+
+template< typename BitField, bool Mutable >
+struct pnm_write_support< packed_dynamic_channel_reference< BitField
+                                                          , 1
+                                                          , Mutable
+                                                          >
+                        , gray_t
+                        > : write_support_true
+                          , pnm_rw_support_base< pnm_image_type::mono_asc_t::value
+                                               , pnm_image_type::mono_bin_t::value
+                                               > {};
+
+
+template<>
+struct pnm_write_support< bits8
+                        , gray_t
+                        > : write_support_true
+                          , pnm_rw_support_base< pnm_image_type::gray_asc_t::value
+                                               , pnm_image_type::gray_bin_t::value
+                                               > {};
+
+
+template<>
+struct pnm_write_support< bits8
+                        , rgb_t
+                        > : write_support_true
+                          , pnm_rw_support_base< pnm_image_type::color_asc_t::value
+                                               , pnm_image_type::color_bin_t::value
+                                               > {};
+
+} // namespace detail
+
+template< typename Pixel >
+struct is_read_supported< Pixel
+                        , pnm_tag
+                        >
+    : mpl::bool_< detail::pnm_read_support< typename channel_type    < Pixel >::type
+                                          , typename color_space_type< Pixel >::type
+                                          >::is_supported
+                >
+{
+    typedef detail::pnm_read_support< typename channel_type    < Pixel >::type
+                                    , typename color_space_type< Pixel >::type
+                                    > parent_t;
+
+    static const pnm_image_type::type _asc_type = parent_t::_asc_type;
+    static const pnm_image_type::type _bin_type = parent_t::_bin_type;
+};
+
+template< typename Pixel >
+struct is_write_supported< Pixel
+                         , pnm_tag
+                         >
+    : mpl::bool_< detail::pnm_write_support< typename channel_type    < Pixel >::type
+                                           , typename color_space_type< Pixel >::type
+                                           >::is_supported
+                > {};
+
+} // namespace gil
+} // namespace boost
+
+
+#endif // BOOST_GIL_EXTENSION_IO_PNM_SUPPORTED_TYPES_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,257 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_IO_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_IO_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <stdlib.h>
+
+#include <boost/lexical_cast.hpp>
+
+#include <boost/gil/extension/io_new/pnm_tags.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+
+#include "writer_backend.hpp"
+
+namespace boost { namespace gil { 
+
+namespace detail {
+
+struct pnm_write_is_supported
+{
+    template< typename View >
+    struct apply 
+        : public is_write_supported< typename get_pixel_type< View >::type
+                                   , pnm_tag
+                                   >
+    {};
+};
+
+} // namespace detail
+
+///
+/// PNM Writer
+///
+template< typename Device >
+class writer< Device
+            , pnm_tag
+            >
+    : public writer_backend< Device
+                           , pnm_tag
+                           >
+{
+private:
+    typedef writer_backend< Device, pnm_tag > backend_t;
+
+public:
+
+    writer( const Device&                      io_dev
+          , const image_write_info< pnm_tag >& info
+          )
+    : backend_t( io_dev
+                , info
+                )
+    {}
+
+    template< typename View >
+    void apply( const View& view )
+    {
+        typedef typename get_pixel_type< View >::type pixel_t;
+
+        std::size_t width  = view.width();
+        std::size_t height = view.height();
+
+        std::size_t chn    = num_channels< View >::value;
+        std::size_t pitch  = chn * width;
+
+        unsigned int type;
+        if( num_channels< View >::value == 1 )
+        {
+            if( is_bit_aligned< pixel_t >::value )
+            {
+                type = pnm_image_type::mono_bin_t::value;
+            }
+            else
+            {
+                type = pnm_image_type::gray_bin_t::value;
+            }
+        }
+        else
+        {
+            type = pnm_image_type::color_bin_t::value;
+        }
+
+        // write header
+
+        // Add a white space at each string so read_int() can decide when a numbers ends.
+
+        std::string str( "P" );
+        str += lexical_cast< std::string >( type ) + std::string( " " );
+        this->_io_dev.print_line( str );
+
+        str.clear();
+        str += lexical_cast< std::string >( width ) + std::string( " " );
+        this->_io_dev.print_line( str );
+
+        str.clear();
+        str += lexical_cast< std::string >( height ) + std::string( " " );
+        this->_io_dev.print_line( str );
+
+        if( type != pnm_image_type::mono_bin_t::value )
+        {
+            this->_io_dev.print_line( "255 ");
+        }
+
+        // write data
+        write_data( view
+                  , pitch
+                  , typename is_bit_aligned< pixel_t >::type()
+                  );
+    }
+
+private:
+
+    template< typename View >
+    void write_data( const View&   src
+                   , std::size_t   pitch
+                   , const mpl::true_&    // bit_aligned
+                   )
+    {
+        BOOST_STATIC_ASSERT(( is_same< View
+                                     , typename gray1_image_t::view_t
+                                     >::value
+                           ));
+
+        byte_vector_t row( pitch / 8 );
+
+        typedef typename View::x_iterator x_it_t;
+        x_it_t row_it = x_it_t( &( *row.begin() ));
+
+        detail::negate_bits< byte_vector_t
+                           , mpl::true_
+                           > neg;
+
+        detail::mirror_bits< byte_vector_t
+                           , mpl::true_
+                           > mirror;
+
+
+        for( typename View::y_coord_t y = 0; y < src.height(); ++y )
+        {
+            std::copy( src.row_begin( y )
+                     , src.row_end( y )
+                     , row_it
+                     );
+
+            mirror( row );
+            neg   ( row );
+
+            this->_io_dev.write( &row.front()
+                               , pitch / 8
+                               );
+        }
+    }
+
+    template< typename View >
+    void write_data( const View&   src
+                   , std::size_t   pitch
+                   , const mpl::false_&    // bit_aligned
+                   )
+    {
+        std::vector< pixel< typename channel_type< View >::type
+                          , layout<typename color_space_type< View >::type >
+                          >
+                   > buf( src.width() );
+
+        typedef typename View::value_type pixel_t;
+        typedef typename view_type_from_pixel< pixel_t >::type view_t;
+
+        //view_t row = interleaved_view( src.width()
+        //                             , 1
+        //                             , reinterpret_cast< pixel_t* >( &buf.front() )
+        //                             , pitch
+        //                             );
+
+        byte_t* row_addr = reinterpret_cast< byte_t* >( &buf.front() );
+
+        for( typename View::y_coord_t y = 0
+           ; y < src.height()
+           ; ++y
+           )
+		{
+            //copy_pixels( subimage_view( src
+            //                          , 0
+            //                          , (int) y
+            //                          , (int) src.width()
+            //                          , 1
+            //                          )
+            //           , row
+            //           );
+
+            std::copy( src.row_begin( y )
+                     , src.row_end  ( y )
+                     , buf.begin()
+                     );
+
+            this->_io_dev.write( row_addr, pitch );
+		}
+    }
+};
+
+///
+/// PNM Writer
+///
+template< typename Device >
+class dynamic_image_writer< Device
+                          , pnm_tag
+                          >
+    : public writer< Device
+                   , pnm_tag
+                   >
+{
+    typedef writer< Device
+                  , pnm_tag
+                  > parent_t;
+
+public:
+
+    dynamic_image_writer( const Device&                      io_dev
+                        , const image_write_info< pnm_tag >& info
+                        )
+    : parent_t( io_dev
+              , info
+              )
+    {}
+
+    template< typename Views >
+    void apply( const any_image_view< Views >& views )
+    {
+        detail::dynamic_io_fnobj< detail::pnm_write_is_supported
+                                , parent_t
+                                > op( this );
+
+        apply_operation( views, op );
+    }
+};
+
+} // gil
+} // boost
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_IO_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/writer_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/pnm/writer_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,57 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_IO_WRITER_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_IO_WRITER_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/pnm_tags.hpp>
+
+namespace boost { namespace gil {
+
+///
+/// PNM Writer Backend
+///
+template< typename Device >
+struct writer_backend< Device
+                     , pnm_tag
+                     >
+{
+public:
+
+    typedef pnm_tag format_tag_t;
+
+public:
+
+    writer_backend( const Device&                      io_dev
+                  , const image_write_info< pnm_tag >& info
+                  )
+    : _io_dev( io_dev )
+    , _info( info )
+    {}
+
+public:
+
+    Device _io_dev;
+
+    image_write_info< pnm_tag > _info;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNM_IO_WRITER_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/raw/device.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/raw/device.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,142 @@
+/*
+    Copyright 2007-2012 Olivier Tournaire, Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_RAW_IO_DEVICE_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_IO_DETAIL_RAW_IO_DEVICE_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Olivier Tournaire \n
+///
+/// \date   2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/shared_ptr.hpp>
+#include <boost/utility/enable_if.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+
+namespace boost { namespace gil { namespace detail {
+
+class raw_device_base
+{
+public:
+
+    ///
+    /// Constructor
+    ///
+    raw_device_base()
+    : _processor_ptr( new LibRaw )
+    {}
+
+    // iparams getters
+    std::string get_camera_manufacturer() { return std::string(_processor_ptr.get()->imgdata.idata.make);  }
+    std::string get_camera_model()        { return std::string(_processor_ptr.get()->imgdata.idata.model); }
+    unsigned get_raw_count()              { return _processor_ptr.get()->imgdata.idata.raw_count; }
+    unsigned get_dng_version()            { return _processor_ptr.get()->imgdata.idata.dng_version; }
+    int get_colors()                      { return _processor_ptr.get()->imgdata.idata.colors; }
+    unsigned get_filters()                { return _processor_ptr.get()->imgdata.idata.filters; }
+    std::string get_cdesc()               { return std::string(_processor_ptr.get()->imgdata.idata.cdesc); }
+
+    // image_sizes getters
+    unsigned short get_raw_width()    { return _processor_ptr.get()->imgdata.sizes.raw_width;  }
+    unsigned short get_raw_height()   { return _processor_ptr.get()->imgdata.sizes.raw_height; }
+    unsigned short get_image_width()  { return _processor_ptr.get()->imgdata.sizes.width;  }
+    unsigned short get_image_height() { return _processor_ptr.get()->imgdata.sizes.height; }
+    unsigned short get_top_margin()   { return _processor_ptr.get()->imgdata.sizes.top_margin;  }
+    unsigned short get_left_margin()  { return _processor_ptr.get()->imgdata.sizes.left_margin; }
+    unsigned short get_iwidth()       { return _processor_ptr.get()->imgdata.sizes.iwidth;  }
+    unsigned short get_iheight()      { return _processor_ptr.get()->imgdata.sizes.iheight; }
+    double get_pixel_aspect()         { return _processor_ptr.get()->imgdata.sizes.pixel_aspect;  }
+    int get_flip()                    { return _processor_ptr.get()->imgdata.sizes.flip; }
+
+    // colordata getters
+    // TODO
+
+    // imgother getters
+    float get_iso_speed()     { return _processor_ptr.get()->imgdata.other.iso_speed; }
+    float get_shutter()       { return _processor_ptr.get()->imgdata.other.shutter; }
+    float get_aperture()      { return _processor_ptr.get()->imgdata.other.aperture; }
+    float get_focal_len()     { return _processor_ptr.get()->imgdata.other.focal_len; }
+    time_t get_timestamp()    { return _processor_ptr.get()->imgdata.other.timestamp; }
+    unsigned get_shot_order() { return _processor_ptr.get()->imgdata.other.shot_order; }
+    unsigned* get_gpsdata()   { return _processor_ptr.get()->imgdata.other.gpsdata; }
+    std::string get_desc()    { return std::string(_processor_ptr.get()->imgdata.other.desc); }
+    std::string get_artist()  { return std::string(_processor_ptr.get()->imgdata.other.artist); }
+
+    std::string get_version()               { return std::string(_processor_ptr.get()->version()); }
+    std::string get_unpack_function_name()  { return std::string(_processor_ptr.get()->unpack_function_name()); }
+
+    void get_mem_image_format(int *widthp, int *heightp, int *colorsp, int *bpp) { _processor_ptr.get()->get_mem_image_format(widthp, heightp, colorsp, bpp); }
+
+    int unpack()                                                         { return _processor_ptr.get()->unpack(); }
+    int dcraw_process()                                                  { return _processor_ptr.get()->dcraw_process(); }
+    libraw_processed_image_t* dcraw_make_mem_image(int* error_code=NULL) { return _processor_ptr.get()->dcraw_make_mem_image(error_code); }
+
+protected:
+
+    typedef boost::shared_ptr< LibRaw > libraw_ptr_t;
+    libraw_ptr_t _processor_ptr;
+};
+
+/*!
+ *
+ * file_stream_device specialization for raw images
+ */
+template<>
+class file_stream_device< raw_tag > : public raw_device_base
+{
+public:
+
+    struct read_tag {};
+
+    ///
+    /// Constructor
+    ///
+    file_stream_device( std::string const& file_name
+                      , read_tag   = read_tag()
+                      )
+    {
+        io_error_if( _processor_ptr.get()->open_file( file_name.c_str() ) != LIBRAW_SUCCESS 
+                   , "file_stream_device: failed to open file"
+                   );
+    }
+
+    ///
+    /// Constructor
+    ///
+    file_stream_device( const char* file_name
+                      , read_tag   = read_tag()
+                      )
+    {
+        io_error_if( _processor_ptr.get()->open_file( file_name ) != LIBRAW_SUCCESS 
+                   , "file_stream_device: failed to open file"
+                   );
+    }
+};
+
+template< typename FormatTag >
+struct is_adaptable_input_device< FormatTag
+                                , LibRaw
+                                , void
+                                >
+    : mpl::true_
+{
+    typedef file_stream_device< FormatTag > device_type;
+};
+
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_RAW_IO_DEVICE_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/raw/is_allowed.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/raw/is_allowed.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,57 @@
+/*
+    Copyright 2009 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_RAW_IO_IS_ALLOWED_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_IO_RAW_IO_IS_ALLOWED_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Olivier Tournaire \n
+///
+/// \date 2011 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <iostream>
+
+namespace boost { namespace gil { namespace detail {
+
+template< typename View >
+bool is_allowed( const image_read_info< raw_tag >& info
+               , mpl::true_   // is read_and_no_convert
+               )
+{
+    typedef typename get_pixel_type< View >::type pixel_t;
+    typedef typename num_channels< pixel_t >::value_type num_channel_t;
+    typedef typename channel_traits< typename element_type< typename View::value_type >::type >::value_type channel_t;
+
+    const num_channel_t dst_samples_per_pixel = num_channels< pixel_t >::value;
+    const unsigned int  dst_bits_per_pixel    = detail::unsigned_integral_num_bits< channel_t >::value;
+    const bool          is_type_signed        = boost::is_signed< channel_t >::value;
+
+    return( dst_samples_per_pixel == info._samples_per_pixel &&
+            dst_bits_per_pixel    == static_cast<unsigned int>(info._bits_per_pixel) &&
+            !is_type_signed );
+}
+
+template< typename View >
+bool is_allowed( const image_read_info< raw_tag >& /* info */
+               , mpl::false_  // is read_and_convert
+               )
+{
+    return true;
+}
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_RAW_IO_IS_ALLOWED_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/raw/read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/raw/read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,254 @@
+/*
+    Copyright 2012 Olivier Tournaire, Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_RAW_IO_READ_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_IO_RAW_IO_READ_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Olivier Tournaire, Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <cstdio>
+#include <vector>
+#include <boost/gil/extension/io_new/raw_tags.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/bit_operations.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+
+#include "is_allowed.hpp"
+#include "device.hpp"
+#include "reader_backend.hpp"
+
+namespace boost { namespace gil {
+
+#define BUILD_INTERLEAVED_VIEW(color_layout, bits_per_pixel) \
+{ \
+    color_layout##bits_per_pixel##_view_t build = boost::gil::interleaved_view(processed_image->width, \
+                                                                             processed_image->height, \
+                                                                             (color_layout##bits_per_pixel##_pixel_t*)processed_image->data, \
+                                                                             processed_image->colors*processed_image->width*processed_image->bits/8); \
+    this->_cc_policy.read( build.begin(), build.end(), dst_view.begin() ); \
+} \
+
+
+template< typename Device
+        , typename ConversionPolicy
+        >
+class reader< Device
+            , raw_tag
+            , ConversionPolicy
+            >
+    : public reader_base< raw_tag
+                        , ConversionPolicy
+                        >
+    , public reader_backend< Device
+                           , raw_tag
+                           >
+{
+private:
+
+    typedef reader< Device
+                  , raw_tag
+                  , ConversionPolicy
+                  > this_t;
+
+    typedef typename ConversionPolicy::color_converter_type cc_t;
+
+public:
+
+    typedef reader_backend< Device, raw_tag > backend_t;
+
+public:
+
+    //
+    // Constructor
+    //
+    reader( const Device&                         io_dev
+          , const image_read_settings< raw_tag >& settings
+          )
+    : backend_t( io_dev
+               , settings
+               )
+    {}
+
+    //
+    // Constructor
+    //
+    reader( const Device&                         io_dev
+          , const cc_t&                           cc
+          , const image_read_settings< raw_tag >& settings
+          )
+    : reader_base< raw_tag
+                 , ConversionPolicy
+                 >( cc )
+    , backend_t( io_dev
+               , settings
+               )
+    {}
+
+    template< typename View >
+    void apply( const View& dst_view )
+    {
+        if( this->_info._valid == false )
+        {
+            io_error( "Image header was not read." );
+        }
+
+        typedef typename is_same< ConversionPolicy
+                                , detail::read_and_no_convert
+                                >::type is_read_and_convert_t;
+
+        io_error_if( !detail::is_allowed< View >( this->_info
+                                                , is_read_and_convert_t()
+                                                )
+                   , "Image types aren't compatible."
+                   );
+
+        // TODO: better error handling based on return code
+        int return_code = this->_io_dev.unpack();
+        io_error_if( return_code != LIBRAW_SUCCESS, "Unable to unpack image" );
+        _info._unpack_function_name = _io_dev.get_unpack_function_name();
+
+        return_code = this->_io_dev.dcraw_process();
+        io_error_if( return_code != LIBRAW_SUCCESS, "Unable to emulate dcraw behavior to process image" );
+
+        libraw_processed_image_t* processed_image = this->_io_dev.dcraw_make_mem_image(&return_code);
+        io_error_if( return_code != LIBRAW_SUCCESS, "Unable to dcraw_make_mem_image" );
+
+        if(processed_image->colors!=1 && processed_image->colors!=3)
+            io_error( "Image is neither gray nor RGB" );
+
+        if(processed_image->bits!=8 && processed_image->bits!=16)
+            io_error( "Image is neither 8bit nor 16bit" );
+
+        // TODO Olivier Tournaire
+        // Here, we should use a metafunction to reduce code size and avoid a (compile time) macro
+        if(processed_image->bits==8)
+        {
+            if(processed_image->colors==1){ BUILD_INTERLEAVED_VIEW(gray, 8); }
+            else                          { BUILD_INTERLEAVED_VIEW(rgb,  8); }
+        }
+        else if(processed_image->bits==16)
+        {
+            if(processed_image->colors==1){ BUILD_INTERLEAVED_VIEW(gray, 16); }
+            else                          { BUILD_INTERLEAVED_VIEW(rgb,  16); }
+        }
+    }
+};
+
+namespace detail {
+
+struct raw_read_is_supported
+{
+    template< typename View >
+    struct apply : public is_read_supported< typename get_pixel_type< View >::type
+                                           , raw_tag
+                                           >
+    {};
+};
+
+struct raw_type_format_checker
+{
+    raw_type_format_checker( const image_read_info< raw_tag >& info )
+    : _info( info )
+    {}
+
+    template< typename Image >
+    bool apply()
+    {
+        typedef typename Image::view_t view_t;
+
+        return is_allowed< view_t >( _info
+                                   , mpl::true_()
+                                   );
+    }
+
+private:
+    ///todo: do we need this here. Should be part of reader_backend
+    const image_read_info< raw_tag >& _info;
+};
+
+} // namespace detail
+
+///
+/// RAW Dynamic Reader
+///
+template< typename Device >
+class dynamic_image_reader< Device
+                          , raw_tag
+                          >
+    : public reader< Device
+                   , raw_tag
+                   , detail::read_and_no_convert
+                   >
+{
+    typedef reader< Device
+                  , raw_tag
+                  , detail::read_and_no_convert
+                  > parent_t;
+
+public:
+
+    dynamic_image_reader( const Device&                         io_dev
+                        , const image_read_settings< raw_tag >& settings
+                        )
+    : parent_t( io_dev
+              , settings
+              )
+    {}
+
+    template< typename Images >
+    void apply( any_image< Images >& images )
+    {
+        detail::raw_type_format_checker format_checker( this->_info );
+
+        if( !construct_matched( images
+                               , format_checker
+                               ))
+        {
+            std::ostringstream error_message;
+            error_message << "No matching image type between those of the given any_image and that of the file.\n";
+            error_message << "Image type must be {gray||rgb}{8||16} unsigned for RAW image files.";
+            io_error( error_message.str() );
+        }
+        else
+        {
+            if( !this->_info._valid )
+            {
+                this->get_info();
+            }
+            init_image( images
+                       , this->_settings
+                       );
+
+            detail::dynamic_io_fnobj< detail::raw_read_is_supported
+                                    , parent_t
+                                    > op( this );
+
+            apply_operation( view( images )
+                            , op
+                            );
+        }
+    }
+};
+
+} // gil
+} // boost
+
+#endif // BOOST_GIL_EXTENSION_IO_RAW_IO_READ_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/raw/reader_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/raw/reader_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,119 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_RAW_IO_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_RAW_IO_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/raw_tags.hpp>
+
+namespace boost { namespace gil {
+
+///
+/// RAW Backend
+///
+template< typename Device >
+struct reader_backend< Device
+                     , raw_tag
+                     >
+{
+public:
+
+    typedef raw_tag format_tag_t;
+
+public:
+
+    reader_backend( const Device&                         io_dev
+                  , const image_read_settings< raw_tag >& settings
+                  )
+    : _io_dev  ( io_dev   )
+    , _settings( settings )
+    , _info()
+    , _scanline_length( 0 )
+    {
+        read_header();    
+
+        if( _settings._dim.x == 0 )
+        {
+            _settings._dim.x = _info._width;
+        }
+
+        if( _settings._dim.y == 0 )
+        {
+            _settings._dim.y = _info._height;
+        }
+    }
+
+    void read_header()
+    {
+        _io_dev.get_mem_image_format( &_info._width
+                                    , &_info._height
+                                    , &_info._samples_per_pixel
+                                    , &_info._bits_per_pixel
+                                    );
+
+        // iparams
+        _info._camera_manufacturer = _io_dev.get_camera_manufacturer();
+        _info._camera_model        = _io_dev.get_camera_model();
+        _info._raw_images_count    = _io_dev.get_raw_count();
+        _info._dng_version         = _io_dev.get_dng_version();
+        _info._number_colors       = _io_dev.get_colors();
+        //_io_dev.get_filters();
+        _info._colors_description  = _io_dev.get_cdesc();
+
+        // image_sizes
+        _info._raw_width      = _io_dev.get_raw_width();
+        _info._raw_height     = _io_dev.get_raw_height();
+        _info._visible_width  = _io_dev.get_image_width();
+        _info._visible_height = _io_dev.get_image_height();
+        _info._top_margin     = _io_dev.get_top_margin();
+        _info._left_margin    = _io_dev.get_left_margin();
+        _info._output_width   = _io_dev.get_iwidth();
+        _info._output_height  = _io_dev.get_iheight();
+        _info._pixel_aspect   = _io_dev.get_pixel_aspect();
+        _info._flip           = _io_dev.get_flip();
+
+        // imgother
+        _info._iso_speed         = _io_dev.get_iso_speed();
+        _info._shutter           = _io_dev.get_shutter();
+        _info._aperture          = _io_dev.get_aperture();
+        _info._focal_length      = _io_dev.get_focal_len();
+        _info._timestamp         = _io_dev.get_timestamp();
+        _info._shot_order        = _io_dev.get_shot_order();
+        //_io_dev.get_gpsdata();
+        _info._image_description = _io_dev.get_desc();
+        _info._artist            = _io_dev.get_artist();
+
+        _info._libraw_version = _io_dev.get_version();
+
+        _info._valid = true;
+    }
+
+public:
+
+    Device _io_dev;
+
+    image_read_settings< raw_tag > _settings;
+    image_read_info< raw_tag >     _info;
+
+    std::size_t _scanline_length;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_RAW_IO_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/raw/supported_types.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/raw/supported_types.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,84 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_RAW_SUPPORTED_TYPES_HPP
+#define BOOST_GIL_EXTENSION_IO_RAW_SUPPORTED_TYPES_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief 
+/// \author Olivier Tournaire \n
+///
+/// \date   2011 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/mpl/not.hpp>
+#include <boost/type_traits/is_same.hpp>
+
+#include <boost/gil/channel.hpp>
+#include <boost/gil/color_base.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+
+namespace boost { namespace gil { namespace detail {
+
+// Read support
+
+template< typename Channel
+        , typename ColorSpace
+        >
+struct raw_read_support : read_support_false {};
+
+template<>
+struct raw_read_support< bits8
+                       , gray_t
+                       > : read_support_true {};
+
+template<>
+struct raw_read_support< bits16
+                       , gray_t
+                       > : read_support_true {};
+
+template<>
+struct raw_read_support< bits8
+                       , rgb_t
+                       > : read_support_true {};
+
+template<>
+struct raw_read_support< bits16
+                       , rgb_t
+                       > : read_support_true {};
+
+// Write support
+
+struct raw_write_support : write_support_false {};
+
+} // namespace detail
+
+template< typename Pixel >
+struct is_read_supported< Pixel,
+                        raw_tag
+                        >
+    : mpl::bool_< detail::raw_read_support< typename channel_type< Pixel >::type
+                                          , typename color_space_type< Pixel >::type
+                                          >::is_supported > {};
+
+template< typename Pixel >
+struct is_write_supported< Pixel
+                         , raw_tag
+                         >
+    : mpl::bool_< detail::raw_write_support::is_supported >
+{};
+
+} // namespace gil
+} // namespace boost
+
+
+#endif // BOOST_GIL_EXTENSION_IO_RAW_SUPPORTED_TYPES_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/is_allowed.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/is_allowed.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,64 @@
+/*
+    Copyright 2010 Kenneth Riddile
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TARGA_IO_IS_ALLOWED_HPP
+#define BOOST_GIL_EXTENSION_IO_TARGA_IO_IS_ALLOWED_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Kenneth Riddile \n
+///
+/// \date 2010 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost { namespace gil { namespace detail {
+
+template< typename View >
+bool is_allowed( const image_read_info< targa_tag >& info
+               , mpl::true_   // is read_and_no_convert
+               )
+{
+    targa_depth::type src_bits_per_pixel = 0;
+
+    switch( info._bits_per_pixel )
+    {
+        case 24:
+        case 32:
+        {
+            src_bits_per_pixel = info._bits_per_pixel;
+            break;
+        }
+        default:
+        {
+            io_error( "Pixel size not supported." );
+            break;
+        }
+    }
+
+    typedef typename channel_traits< typename element_type< typename View::value_type >::type >::value_type channel_t;
+    targa_depth::type dst_bits_per_pixel = detail::unsigned_integral_num_bits< channel_t >::value * num_channels< View >::value;
+
+    return ( dst_bits_per_pixel == src_bits_per_pixel );
+}
+
+template< typename View >
+bool is_allowed( const image_read_info< targa_tag >& /* info */
+               , mpl::false_  // is read_and_convert
+               )
+{
+    return true;
+}
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TARGA_IO_IS_ALLOWED_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,382 @@
+/*
+    Copyright 2012 Kenneth Riddile, Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TARGA_IO_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_TARGA_IO_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Kenneth Riddile, Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <vector>
+
+#include <boost/gil/extension/io_new/targa_tags.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/bit_operations.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+
+#include "reader_backend.hpp"
+#include "is_allowed.hpp"
+
+namespace boost { namespace gil {
+
+///
+/// Targa Reader
+///
+template< typename Device
+        , typename ConversionPolicy
+        >
+class reader< Device
+            , targa_tag
+            , ConversionPolicy
+            >
+    : public reader_base< targa_tag
+                        , ConversionPolicy
+                        >
+    , public reader_backend< Device
+                           , targa_tag
+                           >
+{
+private:
+
+    typedef reader< Device
+                  , targa_tag
+                  , ConversionPolicy
+                  > this_t;
+
+    typedef typename ConversionPolicy::color_converter_type cc_t;
+
+public:
+
+    typedef reader_backend< Device, targa_tag > backend_t;
+
+public:
+
+    reader( const Device&                           io_dev
+          , const image_read_settings< targa_tag >& settings
+          )
+    : reader_base< targa_tag
+                 , ConversionPolicy
+                 >()
+    , backend_t( io_dev
+               , settings 
+               )
+    {}
+
+    reader( const Device&                         io_dev
+          , const cc_t&                           cc
+          , const image_read_settings< targa_tag >& settings
+          )
+    : reader_base< targa_tag
+                 , ConversionPolicy
+                 >( cc )
+    , backend_t( io_dev
+               , settings
+               )
+    {}
+
+    template< typename View >
+    void apply( const View& dst_view )
+    {
+        typedef typename is_same< ConversionPolicy
+                                , detail::read_and_no_convert
+                                >::type is_read_and_convert_t;
+
+        io_error_if( !detail::is_allowed< View >( this->_info, is_read_and_convert_t() )
+                   , "Image types aren't compatible."
+                   );
+        
+        std::ptrdiff_t yend = this->_settings._dim.y;
+        
+        switch( this->_info._image_type )
+        {
+            case targa_image_type::_rgb:
+            {
+                if( this->_info._color_map_type != targa_color_map_type::_rgb )
+                {
+                    io_error( "Inconsistent color map type and image type in targa file." );
+                }
+                
+                if( this->_info._color_map_length != 0 )
+                {
+                    io_error( "Non-indexed targa files containing a palette are not supported." );
+                }
+                
+                switch( this->_info._bits_per_pixel )
+                {
+                    case 24:
+                    {
+                        this->_scanline_length = this->_info._width * ( this->_info._bits_per_pixel / 8 );
+
+                        read_data< bgr8_view_t >( dst_view );
+
+                        break;
+                    }
+                    case 32:
+                    {
+                        this->_scanline_length = this->_info._width * ( this->_info._bits_per_pixel / 8 );
+
+                        read_data< bgra8_view_t >( dst_view );
+
+                        break;
+                    }
+                    default:
+                    {
+                        io_error( "Unsupported bit depth in targa file." );
+                        break;
+                    }
+                }
+                
+                break;
+            }
+            case targa_image_type::_rle_rgb:
+            {
+                if( this->_info._color_map_type != targa_color_map_type::_rgb )
+                {
+                    io_error( "Inconsistent color map type and image type in targa file." );
+                }
+                
+                if( this->_info._color_map_length != 0 )
+                {
+                    io_error( "Non-indexed targa files containing a palette are not supported." );
+                }
+                
+                switch( this->_info._bits_per_pixel )
+                {
+                    case 24:
+                    {
+                        read_rle_data< bgr8_view_t >( dst_view );
+                        break;
+                    }
+                    case 32:
+                    {
+                        read_rle_data< bgra8_view_t >( dst_view );
+                        break;
+                    }
+                    default:
+                    {
+                        io_error( "Unsupported bit depth in targa file." );
+                        break;
+                    }
+                }
+                
+                break;
+            }
+            default:
+            {
+                io_error( "Unsupported image type in targa file." );
+                break;
+            }
+        }
+    }
+
+private:
+
+    // 8-8-8 BGR
+    // 8-8-8-8 BGRA
+    template< typename View_Src, typename View_Dst >
+    void read_data( const View_Dst& view )
+    {
+        byte_vector_t row( this->_info._width * (this->_info._bits_per_pixel / 8) );
+
+        // jump to first scanline
+        this->_io_dev.seek( static_cast< long >( this->_info._offset ));
+
+        View_Src v = interleaved_view( this->_info._width,
+                                       1,
+                                       reinterpret_cast<typename View_Src::value_type*>( &row.front() ),
+                                       this->_info._width * num_channels< View_Src >::value
+                                     );
+
+        typename View_Src::x_iterator beg = v.row_begin( 0 ) + this->_settings._top_left.x;
+        typename View_Src::x_iterator end = beg + this->_settings._dim.x;
+
+        // read bottom up since targa origin is bottom left
+        for( std::ptrdiff_t y = this->_settings._dim.y - 1; y > -1; --y )
+        {
+            // @todo: For now we're reading the whole scanline which is
+            // slightly inefficient. Later versions should try to read
+            // only the bytes which are necessary.
+            this->_io_dev.read( &row.front(), row.size() );
+            this->_cc_policy.read( beg, end, view.row_begin(y) );
+        }
+    }
+
+    // 8-8-8 BGR
+    // 8-8-8-8 BGRA
+    template< typename View_Src, typename View_Dst >
+    void read_rle_data( const View_Dst& view )
+    {
+        targa_depth::type bytes_per_pixel = this->_info._bits_per_pixel / 8;
+        size_t image_size = this->_info._width * this->_info._height * bytes_per_pixel;
+        byte_vector_t image_data( image_size );
+        
+        this->_io_dev.seek( static_cast< long >( this->_info._offset ));
+        
+        for( size_t pixel = 0; pixel < image_size; )
+        {
+            targa_offset::type current_byte = this->_io_dev.read_uint8();
+            
+            if( current_byte & 0x80 ) // run length chunk (high bit = 1)
+            {
+                uint8_t chunk_length = current_byte - 127;
+                uint8_t pixel_data[4];
+                for( size_t channel = 0; channel < bytes_per_pixel; ++channel )
+                {
+                    pixel_data[channel] = this->_io_dev.read_uint8();
+                }
+                
+                // Repeat the next pixel chunk_length times
+                for( uint8_t i = 0; i < chunk_length; ++i, pixel += bytes_per_pixel )
+                {
+                    memcpy( &image_data[pixel], pixel_data, bytes_per_pixel );
+                }
+            }
+            else // raw chunk
+            {
+                uint8_t chunk_length = current_byte + 1;
+                
+                // Write the next chunk_length pixels directly
+                size_t pixels_written = chunk_length * bytes_per_pixel;
+                this->_io_dev.read( &image_data[pixel], pixels_written );
+                pixel += pixels_written;
+            }
+        }
+
+        View_Src v = flipped_up_down_view( interleaved_view( this->_info._width,
+                                                             this->_info._height,
+                                                             reinterpret_cast<typename View_Src::value_type*>( &image_data.front() ),
+                                                             this->_info._width * num_channels< View_Src >::value ) );
+
+        for( std::ptrdiff_t y = 0; y != this->_settings._dim.y; ++y )
+        {
+            typename View_Src::x_iterator beg = v.row_begin( y ) + this->_settings._top_left.x;
+            typename View_Src::x_iterator end = beg + this->_settings._dim.x;
+            this->_cc_policy.read( beg, end, view.row_begin(y) );
+        }
+    }
+};
+
+namespace detail { 
+
+class targa_type_format_checker
+{
+public:
+
+    targa_type_format_checker( const targa_depth::type& bpp )
+    : _bpp( bpp )
+    {}
+
+    template< typename Image >
+    bool apply()
+    {
+        if( _bpp < 32 )
+        {
+            return pixels_are_compatible< typename Image::value_type, rgb8_pixel_t >::value
+                   ? true
+                   : false;
+        }
+        else
+        {
+            return pixels_are_compatible< typename Image::value_type, rgba8_pixel_t >::value
+                   ? true
+                   : false;
+        }
+    }
+
+private:
+
+    // to avoid C4512
+    targa_type_format_checker& operator=( const targa_type_format_checker& ) { return *this; }
+
+private:
+
+    const targa_depth::type _bpp;
+};
+
+struct targa_read_is_supported
+{
+    template< typename View >
+    struct apply : public is_read_supported< typename get_pixel_type< View >::type
+                                           , targa_tag
+                                           >
+    {};
+};
+
+} // namespace detail
+
+///
+/// Targa Dynamic Image Reader
+///
+template< typename Device >
+class dynamic_image_reader< Device
+                          , targa_tag
+                          >
+    : public reader< Device
+                   , targa_tag
+                   , detail::read_and_no_convert
+                   >
+{
+    typedef reader< Device
+                  , targa_tag
+                  , detail::read_and_no_convert
+                  > parent_t;
+
+public:
+
+    dynamic_image_reader( const Device&                           io_dev
+                        , const image_read_settings< targa_tag >& settings
+                        )
+    : parent_t( io_dev
+              , settings
+              )
+    {}
+
+    template< typename Images >
+    void apply( any_image< Images >& images )
+    {
+        detail::targa_type_format_checker format_checker( this->_info._bits_per_pixel );
+
+        if( !construct_matched( images
+                              , format_checker
+                              ))
+        {
+            io_error( "No matching image type between those of the given any_image and that of the file" );
+        }
+        else
+        {
+            init_image( images
+                      , this->_settings
+                      );
+
+            detail::dynamic_io_fnobj< detail::targa_read_is_supported
+                                    , parent_t
+                                    > op( this );
+
+            apply_operation( view( images )
+                           , op
+                           );
+        }
+    }
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TARGA_IO_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/reader_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/reader_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,117 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TARGA_IO_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_TARGA_IO_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/targa_tags.hpp>
+
+namespace boost { namespace gil {
+
+///
+/// Targa Backend
+///
+template< typename Device >
+struct reader_backend< Device
+                     , targa_tag
+                     >
+{
+public:
+
+    typedef targa_tag format_tag_t;
+
+public:
+
+    reader_backend( const Device&                           io_dev
+                  , const image_read_settings< targa_tag >& settings
+                  )
+    : _io_dev  ( io_dev   )
+    , _settings( settings )
+    , _info()
+    , _scanline_length(0)
+    {
+        read_header();    
+
+        if( _settings._dim.x == 0 )
+        {
+            _settings._dim.x = _info._width;
+        }
+
+        if( _settings._dim.y == 0 )
+        {
+            _settings._dim.y = _info._height;
+        }
+    }
+
+    void read_header()
+    {
+        _info._header_size = targa_header_size::_size;
+        
+        _info._offset = _io_dev.read_uint8() + _info._header_size;
+        
+        _info._color_map_type = _io_dev.read_uint8();
+        _info._image_type = _io_dev.read_uint8();
+        
+        _info._color_map_start  = _io_dev.read_uint16();
+        _info._color_map_length = _io_dev.read_uint16();
+        _info._color_map_depth  = _io_dev.read_uint8();
+        
+        _info._x_origin = _io_dev.read_uint16();
+        _info._y_origin = _io_dev.read_uint16();
+        
+        _info._width  = _io_dev.read_uint16();
+        _info._height = _io_dev.read_uint16();
+
+        if( _info._width < 1 || _info._height < 1 )
+        {
+            io_error( "Invalid dimension for targa file" );
+        }
+        
+        _info._bits_per_pixel = _io_dev.read_uint8();
+        if( _info._bits_per_pixel != 24 && _info._bits_per_pixel != 32 )
+        {
+            io_error( "Unsupported bit depth for targa file" );
+        }
+        
+        _info._descriptor = _io_dev.read_uint8();
+        if(    ( _info._bits_per_pixel == 24 && _info._descriptor != 0 ) 
+            || ( _info._bits_per_pixel == 32 && _info._descriptor != 8 )
+          )
+        {
+            io_error( "Unsupported descriptor for targa file" );
+        }
+        
+        _info._valid = true;
+    }
+
+
+public:
+
+    Device _io_dev;
+
+    std::size_t _scanline_length;
+
+    image_read_settings< targa_tag > _settings;
+    image_read_info< targa_tag >     _info;
+};
+
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TARGA_IO_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/scanline_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/scanline_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,164 @@
+/*
+    Copyright 2012 Kenneth Riddile and Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TARGA_IO_SCANLINE_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_TARGA_IO_SCANLINE_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Kenneth Riddile and Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <vector>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/bit_operations.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+
+#include "reader_backend.hpp"
+#include "is_allowed.hpp"
+
+namespace boost { namespace gil {
+
+///
+/// Targa Scanline Reader
+///
+template< typename Device >
+class scanline_reader< Device
+                     , targa_tag
+                     >
+    : public reader_backend< Device
+                           , targa_tag
+                           >
+{
+private:
+
+    typedef scanline_reader< Device
+                           , targa_tag
+                           > this_t;
+
+public:
+
+    typedef reader_backend< Device
+                          , targa_tag
+                          > backend_t;
+
+public:
+
+    //
+    // Constructor
+    //
+    scanline_reader( Device&                                 device
+                   , const image_read_settings< targa_tag >& settings
+                   )
+    : backend_t( device
+                    , settings
+                    )
+    {
+        initialize();
+    }
+
+    void clean_up() {}
+
+    /// Read part of image defined by View and return the data.
+    void read( byte_t* dst, int pos )
+    {
+        // jump to scanline
+        long offset = this->_info._offset
+                    + ( this->_info._height - 1 - pos ) * static_cast< long >( this->_scanline_length );
+        
+        this->_io_dev.seek( offset );
+        
+
+        read_row( dst );
+    }
+
+    /// Skip over a scanline.
+    void skip( byte_t*, int )
+    {
+        this->_io_dev.seek( static_cast<long>( this->_scanline_length ), SEEK_CUR );
+    }
+
+private:
+
+    void initialize()
+    {
+        if( this->_info._color_map_type != targa_color_map_type::_rgb )
+        {
+            io_error( "scanline reader cannot read indexed targa files." );
+        }
+        
+        if( this->_info._image_type != targa_image_type::_rgb )
+        {
+            io_error( "scanline reader cannot read this targa image type." );
+        }
+
+        std::ptrdiff_t yend = this->_settings._dim.y;
+        
+        switch( this->_info._image_type )
+        {
+            case targa_image_type::_rgb:
+            {
+                if( this->_info._color_map_type != targa_color_map_type::_rgb )
+                {
+                    io_error( "Inconsistent color map type and image type in targa file." );
+                }
+                
+                if( this->_info._color_map_length != 0 )
+                {
+                    io_error( "Non-indexed targa files containing a palette are not supported." );
+                }
+                
+                switch( this->_info._bits_per_pixel )
+                {
+                    case 24:
+                    case 32:
+                    {
+                        this->_scanline_length = this->_info._width * ( this->_info._bits_per_pixel / 8 );
+
+                        // jump to first scanline
+                        this->_io_dev.seek( static_cast< long >( this->_info._offset ));
+
+                        break;
+                    }
+                    default:
+                    {
+                        io_error( "Unsupported bit depth in targa file." );
+                        break;
+                    }
+                }
+                
+                break;
+            }
+            default:
+            {
+                io_error( "Unsupported image type in targa file." );
+                break;
+            }
+        }
+    }
+
+    void read_row( byte_t* dst )
+    {
+        this->_io_dev.read( dst, this->_scanline_length );
+    }
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TARGA_IO_SCANLINE_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/supported_types.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/supported_types.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,110 @@
+/*
+    Copyright 2010 Kenneth Riddile
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TARGA_SUPPORTED_TYPES_HPP
+#define BOOST_GIL_EXTENSION_IO_TARGA_SUPPORTED_TYPES_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief 
+/// \author Kenneth Riddile \n
+///
+/// \date   2010 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/mpl/not.hpp>
+#include <boost/type_traits/is_same.hpp>
+
+#include <boost/gil/channel.hpp>
+#include <boost/gil/color_base.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+
+namespace boost { namespace gil { namespace detail {
+
+// Read support
+
+template< typename Channel
+        , typename ColorSpace
+        >
+struct targa_read_support : read_support_false
+{
+    static const targa_depth::type bpp = 0;
+};
+
+template<>
+struct targa_read_support< bits8
+                         , rgb_t
+                         > : read_support_true
+{
+    static const targa_depth::type bpp = 24;
+};
+
+
+template<>
+struct targa_read_support< bits8
+                         , rgba_t
+                         > : read_support_true
+{
+    static const targa_depth::type bpp = 32;
+};
+
+
+// Write support
+
+template< typename Channel
+        , typename ColorSpace
+        >
+struct targa_write_support : write_support_false
+{};
+
+template<>
+struct targa_write_support< bits8
+                          , rgb_t
+                          > : write_support_true {};
+
+template<>
+struct targa_write_support< bits8
+                          , rgba_t
+                          > : write_support_true {};
+
+} // namespace detail
+
+
+template< typename Pixel >
+struct is_read_supported< Pixel
+                        , targa_tag
+                        >
+    : mpl::bool_< detail::targa_read_support< typename channel_type< Pixel >::type
+                                            , typename color_space_type< Pixel >::type
+                                            >::is_supported 
+                >
+{
+    typedef detail::targa_read_support< typename channel_type< Pixel >::type
+                                      , typename color_space_type< Pixel >::type
+                                      > parent_t;
+
+    static const typename targa_depth::type bpp = parent_t::bpp;
+};
+
+template< typename Pixel >
+struct is_write_supported< Pixel
+                         , targa_tag
+                         >
+    : mpl::bool_< detail::targa_write_support< typename channel_type< Pixel >::type
+                                             , typename color_space_type< Pixel >::type
+                                             >::is_supported
+                > {};
+
+} // namespace gil
+} // namespace boost
+
+
+#endif // BOOST_GIL_EXTENSION_IO_TARGA_SUPPORTED_TYPES_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,188 @@
+/*
+    Copyright 2010-2012 Kenneth Riddile, Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TARGA_IO_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_TARGA_IO_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Kenneth Riddile, Christian Henning \n
+///
+/// \date 2010-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <vector>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+
+#include <boost/gil/extension/io_new/targa_tags.hpp>
+
+#include "writer_backend.hpp"
+
+namespace boost { namespace gil {
+
+namespace detail {
+
+template < int N > struct get_targa_view_type {};
+template <> struct get_targa_view_type< 3 > { typedef bgr8_view_t type; };
+template <> struct get_targa_view_type< 4 > { typedef bgra8_view_t type; };
+
+struct targa_write_is_supported
+{
+    template< typename View >
+    struct apply
+        : public is_write_supported< typename get_pixel_type< View >::type
+                                   , targa_tag
+                                   >
+    {};
+};
+
+} // detail
+
+///
+/// TARGA Writer
+///
+template< typename Device >
+class writer< Device
+            , targa_tag
+            >
+    : public writer_backend< Device
+                           , targa_tag
+                           >
+{
+private:
+     typedef writer_backend< Device, targa_tag > backend_t;
+
+public:
+
+    writer( const Device&                        io_dev
+          , const image_write_info< targa_tag >& info
+          )
+    : backend_t( io_dev
+               , info
+               )
+    {}
+
+    template<typename View>
+    void apply( const View& view )
+    {
+        write( view );
+    }
+
+private:
+
+    template< typename View >
+    void write( const View& view )
+    {
+        uint8_t bit_depth = static_cast<uint8_t>( num_channels<View>::value * 8 );
+
+        // write the TGA header
+        this->_io_dev.write_uint8( 0 ); // offset
+        this->_io_dev.write_uint8( targa_color_map_type::_rgb );
+        this->_io_dev.write_uint8( targa_image_type::_rgb );
+        this->_io_dev.write_uint16( 0 ); // color map start
+        this->_io_dev.write_uint16( 0 ); // color map length
+        this->_io_dev.write_uint8( 0 ); // color map depth
+        this->_io_dev.write_uint16( 0 ); // x origin
+        this->_io_dev.write_uint16( 0 ); // y origin
+        this->_io_dev.write_uint16( static_cast<uint16_t>( view.width() ) ); // width in pixels
+        this->_io_dev.write_uint16( static_cast<uint16_t>( view.height() ) ); // height in pixels
+        this->_io_dev.write_uint8( bit_depth );
+
+        if( 32 == bit_depth )
+        {
+            this->_io_dev.write_uint8( 8 ); // 8-bit alpha channel descriptor
+        }
+        else
+        {
+            this->_io_dev.write_uint8( 0 );
+        }
+
+        write_image< View
+                   , typename detail::get_targa_view_type< num_channels< View >::value >::type
+                   >( view );
+    }
+
+
+    template< typename View
+            , typename TGA_View
+            >
+    void write_image( const View& view )
+    {
+        size_t row_size = view.width() * num_channels<View>::value;
+        byte_vector_t buffer( row_size );
+        std::fill( buffer.begin(), buffer.end(), 0 );
+
+
+        TGA_View row = interleaved_view( view.width()
+                                       , 1
+                                       , reinterpret_cast<typename TGA_View::value_type*>( &buffer.front() )
+                                       , row_size
+                                       );
+
+        for( typename View::y_coord_t y = view.height() - 1; y > -1; --y )
+        {
+            copy_pixels( subimage_view( view
+                                      , 0
+                                      , static_cast<int>( y )
+                                      , static_cast<int>( view.width() )
+                                      , 1
+                                      )
+                       , row
+                       );
+
+            this->_io_dev.write( &buffer.front(), row_size );
+        }
+
+    }
+};
+
+///
+/// TARGA Dynamic Image Writer
+///
+template< typename Device >
+class dynamic_image_writer< Device
+                          , targa_tag
+                          >
+    : public writer< Device
+                   , targa_tag
+                   >
+{
+    typedef writer< Device
+                  , targa_tag
+                  > parent_t;
+
+public:
+
+    dynamic_image_writer( const Device&                        io_dev
+                        , const image_write_info< targa_tag >& info
+                        )
+    : parent_t( io_dev
+              , info
+              )
+    {}
+
+    template< typename Views >
+    void apply( const any_image_view< Views >& views )
+    {
+        detail::dynamic_io_fnobj< detail::targa_write_is_supported
+                                , parent_t
+                                > op( this );
+
+        apply_operation( views, op );
+    }
+};
+
+} // gil
+} // boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TARGA_IO_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/writer_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/targa/writer_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,57 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TARGA_IO_WRITER_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_TARGA_IO_WRITER_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/targa_tags.hpp>
+
+namespace boost { namespace gil {
+
+///
+/// TARGA Writer Backend
+///
+template< typename Device >
+struct writer_backend< Device
+                     , targa_tag
+                     >
+{
+public:
+
+    typedef targa_tag format_tag_t;
+
+public:
+
+    writer_backend( const Device&                        io_dev
+                  , const image_write_info< targa_tag >& info
+                  )
+    : _io_dev( io_dev )
+    , _info( info )
+    {}
+
+public:
+
+    Device _io_dev;
+
+    image_write_info< targa_tag > _info;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TARGA_IO_WRITER_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/device.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/device.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,427 @@
+/*
+    Copyright 2007-2008 Andreas Pokorny, Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_DETAIL_TIFF_IO_DEVICE_HPP
+#define BOOST_GIL_EXTENSION_IO_DETAIL_TIFF_IO_DEVICE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Andreas Pokorny, Christian Henning \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+// taken from jpegxx - https://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/ijg_headers.hpp
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_C_LIB_COMPILED_AS_CPLUSPLUS
+    extern "C" {
+#else
+    // DONT_USE_EXTERN_C introduced in v7 of the IJG library.
+    // By default the v7 IJG headers check for __cplusplus being defined and
+    // wrap the content in an 'extern "C"' block if it's present.
+    // When DONT_USE_EXTERN_C is defined, this wrapping is not performed.
+    #ifndef DONT_USE_EXTERN_C
+        #define DONT_USE_EXTERN_C 1
+    #endif
+#endif
+
+#include <tiff.h>
+#include <tiffio.h>
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_C_LIB_COMPILED_AS_CPLUSPLUS
+    }
+#endif
+
+#include <tiffio.hxx>
+
+#include <boost/shared_ptr.hpp>
+#include <boost/utility/enable_if.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+
+namespace boost { namespace gil { namespace detail {
+
+class tiff_device_base
+{
+public:
+
+    tiff_device_base()
+    {}
+
+    tiff_device_base( TIFF* tiff_file )
+    : _tiff_file( tiff_file
+                , TIFFClose )
+    {}
+
+
+    template <typename Property>
+    bool get_property( typename Property::type& value  )
+    {
+        if( TIFFGetFieldDefaulted( _tiff_file.get()
+                                 , Property::tag
+                                 , &value ) == 1 )
+        {
+            return true;
+        }
+
+        return false;
+    }
+   
+
+    template <typename Property>
+    inline
+    bool set_property( const typename Property::type& value )
+    {
+       if( TIFFSetField( _tiff_file.get()
+                       , Property::tag
+                       , value  ) == 1 )
+       {
+          return true;
+       }
+
+       return false;
+    }
+
+    // TIFFIsByteSwapped returns a non-zero value if the image data was in a different 
+    // byte-order than the host machine. Zero is returned if the TIFF file and local 
+    // host byte-orders are the same. Note that TIFFReadTile(), TIFFReadStrip() and TIFFReadScanline() 
+    // functions already normally perform byte swapping to local host order if needed.
+    bool are_bytes_swapped()
+    {
+        return ( TIFFIsByteSwapped( _tiff_file.get() )) ? true : false;
+    }
+
+    bool is_tiled() const
+    {
+        return ( TIFFIsTiled( _tiff_file.get() )) ? true : false;
+    }
+
+    unsigned int get_default_strip_size()
+    {
+        return TIFFDefaultStripSize( _tiff_file.get()
+                                   , 0 );
+    }
+
+    std::size_t get_scanline_size()
+    {
+      return TIFFScanlineSize( _tiff_file.get() );
+    }
+
+    std::size_t get_tile_size()
+    {
+      return TIFFTileSize( _tiff_file.get() );
+    }
+
+
+    int get_field_defaulted( uint16_t*& red
+                           , uint16_t*& green
+                           , uint16_t*& blue
+                           )
+    {
+        return TIFFGetFieldDefaulted( _tiff_file.get()
+                                    , TIFFTAG_COLORMAP
+                                    , &red
+                                    , &green
+                                    , &blue
+                                    );
+    }
+
+    template< typename Buffer >
+    void read_scanline( Buffer&        buffer
+                      , std::ptrdiff_t row
+                      , tsample_t      plane
+                      )
+    {
+        io_error_if( TIFFReadScanline( _tiff_file.get()
+                                     , reinterpret_cast< tdata_t >( &buffer.front() )
+                                     , (uint32) row
+                                     , plane           ) == -1
+                   , "Read error."
+                   );
+    }
+
+    void read_scanline( byte_t*        buffer
+                      , std::ptrdiff_t row
+                      , tsample_t      plane
+                      )
+    {
+        io_error_if( TIFFReadScanline( _tiff_file.get()
+                                     , reinterpret_cast< tdata_t >( buffer )
+                                     , (uint32) row
+                                     , plane           ) == -1
+                   , "Read error."
+                   );
+    }
+
+    template< typename Buffer >
+    void read_tile( Buffer&        buffer
+                  , std::ptrdiff_t x
+                  , std::ptrdiff_t y
+                  , std::ptrdiff_t z
+                  , tsample_t      plane
+                  )
+    {
+        if( TIFFReadTile( _tiff_file.get()
+                        , reinterpret_cast< tdata_t >( &buffer.front() )
+                        , (uint32) x
+                        , (uint32) y
+                        , (uint32) z
+                        , plane
+                        ) == -1 )
+        {
+            std::ostringstream oss;
+            oss << "Read tile error (" << x << "," << y << "," << z << "," << plane << ").";
+            io_error(oss.str().c_str());
+        }
+    }
+
+    template< typename Buffer >
+    void write_scaline( Buffer&     buffer
+                      , uint32      row
+                      , tsample_t   plane
+                      )
+    {
+       io_error_if( TIFFWriteScanline( _tiff_file.get()
+                                     , &buffer.front()
+                                     , row
+                                     , plane 
+                                     ) == -1
+                   , "Write error"
+                   );
+    }
+
+    void write_scaline( byte_t*     buffer
+                      , uint32      row
+                      , tsample_t   plane
+                      )
+    {
+       io_error_if( TIFFWriteScanline( _tiff_file.get()
+                                     , buffer
+                                     , row
+                                     , plane 
+                                     ) == -1
+                   , "Write error"
+                   );
+    }
+
+    template< typename Buffer >
+    void write_tile( Buffer&     buffer
+                   , uint32      x
+                   , uint32      y
+                   , uint32      z
+                   , tsample_t   plane
+                   )
+    {
+       if( TIFFWriteTile( _tiff_file.get()
+                        , &buffer.front()
+                        , x
+                        , y
+                        , z
+                        , plane
+                        ) == -1 )
+           {
+               std::ostringstream oss;
+               oss << "Write tile error (" << x << "," << y << "," << z << "," << plane << ").";
+               io_error(oss.str().c_str());
+           }
+    }
+
+    void set_directory( tdir_t directory )
+    {
+        io_error_if( TIFFSetDirectory( _tiff_file.get()
+                                     , directory
+                                     ) != 1
+                   , "Failing to set directory"
+                   );
+    }
+
+    // return false if the given tile width or height is not TIFF compliant (multiple of 16) or larger than image size, true otherwise
+    bool check_tile_size( tiff_tile_width::type&  width
+                        , tiff_tile_length::type& height
+
+                        )
+    {
+        bool result = true;
+        uint32 tw = static_cast< uint32 >( width  );
+        uint32 th = static_cast< uint32 >( height );
+
+        TIFFDefaultTileSize( _tiff_file.get()
+                           , &tw
+                           , &th
+                           );
+
+        if(width==0 || width%16!=0)
+        {
+            width = tw;
+            result = false;
+        }
+        if(height==0 || height%16!=0)
+        {
+            height = th;
+            result = false;
+        }
+        return result;
+    }
+
+protected:
+
+   typedef shared_ptr<TIFF> tiff_file_t;
+   tiff_file_t _tiff_file;
+
+};
+
+/*!
+ *
+ * file_stream_device specialization for tiff images, which are based on TIFF*.
+ */
+template<>
+class file_stream_device< tiff_tag > : public tiff_device_base
+{
+public:
+
+    struct read_tag {};
+    struct write_tag {};
+
+    file_stream_device( std::string const& file_name, read_tag, bool close = true )
+    {
+        TIFF* tiff;
+
+        io_error_if( ( tiff = TIFFOpen( file_name.c_str(), "r" )) == NULL
+                   , "file_stream_device: failed to open file" );
+
+        _tiff_file = tiff_file_t( tiff, TIFFClose );
+    }
+
+    file_stream_device( std::string const& file_name, write_tag )
+    {
+        TIFF* tiff;
+
+        io_error_if( ( tiff = TIFFOpen( file_name.c_str(), "w" )) == NULL
+                   , "file_stream_device: failed to open file" );
+
+        _tiff_file = tiff_file_t( tiff, TIFFClose );
+    }
+
+    file_stream_device( TIFF* tiff_file )
+    : tiff_device_base( tiff_file )
+    {}
+};
+
+/*!
+ *
+ * ostream_device specialization for tiff images.
+ */
+template<>
+class ostream_device< tiff_tag > : public tiff_device_base
+{
+public:
+    ostream_device( std::ostream & out )
+    : _out( out )
+    {
+        TIFF* tiff;
+
+        io_error_if( ( tiff = TIFFStreamOpen( ""
+                                            , &_out
+                                            )
+                      ) == NULL
+                   , "ostream_device: failed to stream"
+                   );
+
+        _tiff_file = tiff_file_t( tiff, TIFFClose );
+    }
+
+private:
+    ostream_device& operator=( const ostream_device& ) { return *this; }
+
+private:
+
+    std::ostream& _out;
+};
+
+/*!
+ *
+ * ostream_device specialization for tiff images.
+ */
+template<>
+class istream_device< tiff_tag > : public tiff_device_base
+{
+public:
+    istream_device( std::istream & in )
+    : _in( in )
+    {
+        TIFF* tiff;
+
+        io_error_if( ( tiff = TIFFStreamOpen( ""
+                                            , &_in
+                                            )
+                     ) == NULL
+                   , "istream_device: failed to stream"
+                   );
+
+        _tiff_file = tiff_file_t( tiff, TIFFClose );
+    }
+
+private:
+    istream_device& operator=( const istream_device& ) { return *this; }
+
+private:
+
+    std::istream& _in;
+};
+
+/*
+template< typename T, typename D >
+struct is_adaptable_input_device< tiff_tag, T, D > : mpl::false_{};
+*/
+
+template< typename FormatTag >
+struct is_adaptable_input_device< FormatTag
+                                , TIFF*
+                                , void
+                                >
+    : mpl::true_
+{
+    typedef file_stream_device< FormatTag > device_type;
+};
+
+template< typename FormatTag >
+struct is_adaptable_output_device< FormatTag
+                                 , TIFF*
+                                 , void
+                                 >
+    : mpl::true_
+{
+    typedef file_stream_device< FormatTag > device_type;
+};
+
+
+template < typename Channel > struct sample_format : public mpl::int_<SAMPLEFORMAT_UINT> {};
+template<> struct sample_format<bits8>   : public mpl::int_<SAMPLEFORMAT_UINT> {};
+template<> struct sample_format<bits16>  : public mpl::int_<SAMPLEFORMAT_UINT> {};
+template<> struct sample_format<bits32>  : public mpl::int_<SAMPLEFORMAT_UINT> {};
+template<> struct sample_format<bits32f> : public mpl::int_<SAMPLEFORMAT_IEEEFP> {};
+template<> struct sample_format<double>  : public mpl::int_<SAMPLEFORMAT_IEEEFP> {};
+template<> struct sample_format<bits8s>  : public mpl::int_<SAMPLEFORMAT_INT> {};
+template<> struct sample_format<bits16s> : public mpl::int_<SAMPLEFORMAT_INT> {};
+template<> struct sample_format<bits32s> : public mpl::int_<SAMPLEFORMAT_INT> {};
+
+template <typename Channel> struct photometric_interpretation {};
+template<> struct photometric_interpretation< gray_t > : public mpl::int_< PHOTOMETRIC_MINISBLACK > {};
+template<> struct photometric_interpretation< rgb_t  > : public mpl::int_< PHOTOMETRIC_RGB        > {};
+template<> struct photometric_interpretation< rgba_t > : public mpl::int_< PHOTOMETRIC_RGB        > {};
+template<> struct photometric_interpretation< cmyk_t > : public mpl::int_< PHOTOMETRIC_SEPARATED  > {};
+
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_DETAIL_TIFF_IO_DEVICE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/is_allowed.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/is_allowed.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,174 @@
+/*
+    Copyright 2008 Christian Henning, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_IO_IS_ALLOWED_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_IO_IS_ALLOWED_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/mpl/for_each.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+
+namespace boost { namespace gil { namespace detail {
+
+typedef std::vector< tiff_bits_per_sample::type > channel_sizes_t;
+
+template< typename Channel >
+int format_value( mpl::true_ ) // is_bit_aligned
+{
+    return SAMPLEFORMAT_UINT;
+}
+
+template< typename Channel >
+int format_value( mpl::false_ ) // is_bit_aligned
+{
+    if( is_unsigned< Channel >::value )
+    {
+        return SAMPLEFORMAT_UINT;
+    }
+    if( is_signed< Channel >::value )
+    {
+        return SAMPLEFORMAT_INT;
+    }
+    else if( is_floating_point< Channel >::value )
+    {
+        return SAMPLEFORMAT_IEEEFP;
+    }
+
+    io_error( "Unkown channel format." );
+}
+
+// The following two functions look the same but are different since one is using
+// a pixel_t as template parameter whereas the other is using reference_t.
+template< typename View >
+bool compare_channel_sizes( const channel_sizes_t& channel_sizes // in bits
+                          , mpl::false_                          // is_bit_aligned
+                          , mpl::true_                           // is_homogeneous
+                          )
+{
+    typedef typename View::value_type pixel_t;
+    typedef typename channel_traits<
+                typename element_type< pixel_t >::type >::value_type channel_t;
+
+    unsigned int s = detail::unsigned_integral_num_bits< channel_t >::value;
+
+    return ( s == channel_sizes[0] );
+}
+
+
+template< typename View >
+bool compare_channel_sizes( const channel_sizes_t& channel_sizes // in bits
+                          , mpl::true_                           // is_bit_aligned
+                          , mpl::true_                           // is_homogeneous
+                          )
+{
+    typedef typename View::reference ref_t;
+
+    typedef typename channel_traits< typename element_type< ref_t >::type >::value_type channel_t;
+    channel_t c;
+
+    unsigned int s = detail::unsigned_integral_num_bits< channel_t >::value;
+
+    return ( s == channel_sizes[0] );
+}
+
+struct compare_channel_sizes_fn
+{
+    compare_channel_sizes_fn( uint16_t* a )
+    : _a( a )
+    , _b( true )
+    {}
+
+    template< typename ChannelSize >
+    void operator()( ChannelSize x)
+    {
+        if( x != *_a++ )
+        {
+            _b = false;
+        }
+    }
+
+    uint16_t* _a;
+    bool _b;
+};
+
+template< typename T >
+struct channel_sizes_type {};
+
+template< typename B, typename C, typename L, bool M >
+struct channel_sizes_type< bit_aligned_pixel_reference< B, C, L, M > > { typedef C type; };
+
+template< typename B, typename C, typename L, bool M >
+struct channel_sizes_type< const bit_aligned_pixel_reference< B, C, L, M > > { typedef C type; };
+
+template< typename View >
+bool compare_channel_sizes( channel_sizes_t& channel_sizes // in bits
+                          , mpl::true_                     // is_bit_aligned
+                          , mpl::false_                    // is_homogeneous
+                          )
+{
+    // loop through all channels and compare
+
+    typedef typename View::reference ref_t;
+    typedef typename channel_sizes_type< ref_t >::type cs_t;
+
+    compare_channel_sizes_fn fn( &channel_sizes.front() );
+    mpl::for_each< cs_t >( fn );
+
+    return fn._b;
+}
+
+template< typename View >
+bool is_allowed( const image_read_info< tiff_tag >& info
+               , mpl::true_ // is read_and_no_convert
+               )
+{
+    channel_sizes_t channel_sizes( info._samples_per_pixel
+                                 , info._bits_per_sample
+                                 );
+
+    typedef typename get_pixel_type< View >::type pixel_t;
+    typedef typename channel_traits<
+                typename element_type< pixel_t >::type >::value_type channel_t;
+
+    typedef typename num_channels< pixel_t >::value_type num_channel_t;
+
+    const num_channel_t dst_samples_per_pixel = num_channels< pixel_t >::value;
+    const num_channel_t dst_sample_format     = format_value< channel_t >( typename is_bit_aligned< pixel_t >::type() );
+
+    return (  dst_samples_per_pixel == info._samples_per_pixel
+           && compare_channel_sizes< View >( channel_sizes
+                                           , typename is_bit_aligned< pixel_t >::type()
+                                           , typename is_homogeneous< pixel_t >::type()
+                                           )
+           && dst_sample_format == info._sample_format
+           );
+}
+
+template< typename View >
+bool is_allowed( const image_read_info< tiff_tag >& /* info */
+               , mpl::false_ // is read_and_no_convert
+               )
+{
+    return true;
+}
+
+} // namespace detail
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_IO_IS_ALLOWED_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/log.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/log.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,66 @@
+/*
+    Copyright 2009 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_IO_LOG_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_IO_LOG_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date   2009 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+extern "C" {
+#include "tiffio.h"
+}
+
+#include <iostream>
+
+namespace boost { namespace gil {
+
+class console_log
+{
+public:
+
+    console_log()
+    {
+        TIFFSetErrorHandler  ( console_log::error   );
+        TIFFSetWarningHandler( console_log::warning );
+    }
+
+private:
+
+    static void error( const char* /* module */
+                     , const char* fmt
+                     , va_list ap
+                     )
+    {
+        char buf[1000];
+        sprintf(buf, fmt, ap);
+        std::cout << "error: " << buf << std::endl;
+    }
+
+    static void warning( char const* /* module */
+                       , char const* fmt
+                       , va_list ap
+                       )
+    {
+        char buf[1000];
+        sprintf(buf, fmt, ap);
+        std::cout << "warning: " << fmt << std::endl;
+    }
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_IO_LOG_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,794 @@
+/*
+    Copyright 2007-2012 Christian Henning, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_IO_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_IO_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+// taken from jpegxx - https://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/ijg_headers.hpp
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_C_LIB_COMPILED_AS_CPLUSPLUS
+    extern "C" {
+#else
+    // DONT_USE_EXTERN_C introduced in v7 of the IJG library.
+    // By default the v7 IJG headers check for __cplusplus being defined and
+    // wrap the content in an 'extern "C"' block if it's present.
+    // When DONT_USE_EXTERN_C is defined, this wrapping is not performed.
+    #ifndef DONT_USE_EXTERN_C
+        #define DONT_USE_EXTERN_C 1
+    #endif
+#endif
+
+#include <tiff.h>
+#include <tiffio.h>
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_C_LIB_COMPILED_AS_CPLUSPLUS
+    }
+#endif
+
+#include <algorithm>
+#include <string>
+#include <vector>
+
+#include <boost/static_assert.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/bit_operations.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+
+#include "reader_backend.hpp"
+#include "device.hpp"
+#include "is_allowed.hpp"
+
+
+namespace boost { namespace gil { 
+
+template < int K >
+struct plane_recursion
+{
+   template< typename View
+           , typename Device
+           , typename ConversionPolicy
+           >
+   static
+   void read_plane( const View& dst_view
+                  , reader< Device
+                          , tiff_tag
+                          , ConversionPolicy >* p
+                  )
+   {
+      typedef typename kth_channel_view_type< K, View >::type plane_t;
+      plane_t plane = kth_channel_view<K>( dst_view );
+
+      p->template read_data< detail::row_buffer_helper_view< plane_t > >( plane, K );
+
+      plane_recursion< K - 1 >::read_plane( dst_view, p );
+   }
+};
+
+template <>
+struct plane_recursion< -1 >
+{
+   template< typename View
+           , typename Device
+           , typename ConversionPolicy
+           >
+   static
+   void read_plane( const View&               /* dst_view */
+                  , reader< Device
+                          , tiff_tag
+                          , ConversionPolicy
+                          >*                  /* p         */
+                  )
+    {}
+};
+
+///
+/// Tiff Reader
+///
+template< typename Device
+        , typename ConversionPolicy
+        >
+class reader< Device
+            , tiff_tag
+            , ConversionPolicy
+            >
+    : public reader_base< tiff_tag
+                        , ConversionPolicy >
+
+    , public reader_backend< Device
+                           , tiff_tag
+                           >
+{
+private:
+
+    typedef reader< Device
+                  , tiff_tag
+                  , ConversionPolicy
+                  > this_t;
+
+    typedef typename ConversionPolicy::color_converter_type cc_t;
+
+public:
+
+    typedef reader_backend< Device, tiff_tag > backend_t;
+
+public:
+
+    reader( const Device&                          io_dev
+          , const image_read_settings< tiff_tag >& settings
+          )
+    : reader_base< tiff_tag
+                 , ConversionPolicy
+                 >()
+    , backend_t( io_dev
+               , settings
+               )
+    {}
+
+    reader( const Device&                                          io_dev
+          , const typename ConversionPolicy::color_converter_type& cc
+          , const image_read_settings< tiff_tag >&                 settings
+          )
+    : reader_base< tiff_tag
+                 , ConversionPolicy
+                 >( cc )
+    , backend_t( io_dev
+               , settings
+               )
+    {}
+
+    // only works for homogeneous image types
+    template< typename View >
+    void apply( View& dst_view )
+    {
+        if( this->_info._photometric_interpretation == PHOTOMETRIC_PALETTE )
+        {
+            this->_scanline_length = this->_info._width 
+                                   * num_channels< rgb16_view_t >::value 
+                                   * sizeof( channel_type<rgb16_view_t>::type );
+
+            // Steps:
+            // 1. Read indices. It's an array of grayX_pixel_t.
+            // 2. Read palette. It's an array of rgb16_pixel_t.
+            // 3. ??? Create virtual image or transform the two arrays
+            //    into a rgb16_image_t object. The latter might
+            //    be a good first solution.
+
+            switch( this->_info._bits_per_sample )
+            {
+                case 1:  { read_palette_image< gray1_image_t  >( dst_view ); break; }
+                case 2:  { read_palette_image< gray2_image_t  >( dst_view ); break; }
+                case 4:  { read_palette_image< gray4_image_t  >( dst_view ); break; }
+                case 8:  { read_palette_image< gray8_image_t  >( dst_view ); break; }
+                case 16: { read_palette_image< gray16_image_t >( dst_view ); break; }
+
+                default: { io_error( "Not supported palette " ); }
+            }
+
+            return;
+
+        }
+        else
+        {
+            this->_scanline_length = this->_io_dev.get_scanline_size();
+
+            // In case we only read the image the user's type and
+            // the tiff type need to compatible. Which means:
+            // color_spaces_are_compatible && channels_are_pairwise_compatible
+
+            typedef typename is_same< ConversionPolicy
+                                    , detail::read_and_no_convert
+                                    >::type is_read_only;
+
+            io_error_if( !detail::is_allowed< View >( this->_info
+                                                    , is_read_only()
+                                                    )
+                       , "Image types aren't compatible."
+                       );
+
+            if( this->_info._planar_configuration == PLANARCONFIG_SEPARATE )
+            {
+                plane_recursion< num_channels< View >::value - 1 >::read_plane( dst_view
+                                                                              , this
+                                                                              );
+            }
+            else if( this->_info._planar_configuration == PLANARCONFIG_CONTIG )
+            {
+
+                if( is_read_only::value == false )
+                {
+                    // the read_data function needs to know what gil type the source image is
+                    // to have the default color converter function correctly
+
+                    switch( this->_info._photometric_interpretation )
+                    {
+                        case PHOTOMETRIC_MINISWHITE:
+                        case PHOTOMETRIC_MINISBLACK:
+                        {
+                            switch( this->_info._bits_per_sample )
+                            {
+                                case  1: { read_data< detail::row_buffer_helper_view< gray1_image_t::view_t > >( dst_view, 0 );  break; }
+                                case  2: { read_data< detail::row_buffer_helper_view< gray2_image_t::view_t > >( dst_view, 0 );  break; }
+                                case  4: { read_data< detail::row_buffer_helper_view< gray4_image_t::view_t > >( dst_view, 0 );  break; }
+                                case  8: { read_data< detail::row_buffer_helper_view< gray8_view_t  > >( dst_view, 0 );  break; }
+                                case 16: { read_data< detail::row_buffer_helper_view< gray16_view_t > >( dst_view, 0 );  break; }
+                                case 32: { read_data< detail::row_buffer_helper_view< gray32_view_t > >( dst_view, 0 );  break; }
+                                default: { io_error( "Image type is not supported." ); }
+                            }
+
+                            break;
+                        }
+
+                        case PHOTOMETRIC_RGB:
+                        {
+                            switch( this->_info._samples_per_pixel )
+                            {
+                                case 3:
+                                {
+                                    switch( this->_info._bits_per_sample )
+                                    {
+                                        case  8: { read_data< detail::row_buffer_helper_view< rgb8_view_t  > >( dst_view, 0 );  break; }
+                                        case 16: { read_data< detail::row_buffer_helper_view< rgb16_view_t > >( dst_view, 0 );  break; }
+                                        case 32: { read_data< detail::row_buffer_helper_view< rgb32_view_t > >( dst_view, 0 );  break; }
+                                        default: { io_error( "Image type is not supported." ); }
+                                    }
+
+                                    break;
+                                }
+
+                                case 4:
+                                {
+                                    switch( this->_info._bits_per_sample )
+                                    {
+                                        case  8: { read_data< detail::row_buffer_helper_view< rgba8_view_t  > >( dst_view, 0 );  break; }
+                                        case 16: { read_data< detail::row_buffer_helper_view< rgba16_view_t > >( dst_view, 0 );  break; }
+                                        case 32: { read_data< detail::row_buffer_helper_view< rgba32_view_t > >( dst_view, 0 );  break; }
+                                        default: { io_error( "Image type is not supported." ); }
+                                    }
+
+                                    break;
+                                }
+
+                                default: { io_error( "Image type is not supported." ); }
+                            }
+
+                            break;
+                        }
+                        case PHOTOMETRIC_SEPARATED: // CYMK
+                        {
+                            switch( this->_info._bits_per_sample )
+                            {
+                                case  8: { read_data< detail::row_buffer_helper_view< cmyk8_view_t  > >( dst_view, 0 );  break; }
+                                case 16: { read_data< detail::row_buffer_helper_view< cmyk16_view_t > >( dst_view, 0 );  break; }
+                                case 32: { read_data< detail::row_buffer_helper_view< cmyk32_view_t > >( dst_view, 0 );  break; }
+                                default: { io_error( "Image type is not supported." ); }
+                            }
+
+                            break;
+                        }
+
+                        default: { io_error( "Image type is not supported." ); }
+                    }
+                }
+                else
+                {
+                    read_data< detail::row_buffer_helper_view< View > >( dst_view, 0 );
+                }
+            }
+            else
+            {
+                io_error( "Wrong planar configuration setting." );
+            }
+        }
+    }
+
+private:
+
+   template< typename PaletteImage
+           , typename View
+           >
+   void read_palette_image( const View& dst_view )
+   {
+      PaletteImage indices( this->_info._width  - this->_settings._top_left.x
+                          , this->_info._height - this->_settings._top_left.y );
+
+      // read the palette first
+      read_data< detail::row_buffer_helper_view< typename PaletteImage::view_t > >( view( indices ), 0 );
+
+      read_palette_image( dst_view
+                        , view( indices )
+                        , typename is_same< View, rgb16_view_t >::type() );
+   }
+
+   template< typename View
+           , typename Indices_View
+           >
+   void read_palette_image( const View&         dst_view
+                          , const Indices_View& indices_view
+                          , mpl::true_   // is View rgb16_view_t
+                          )
+   {
+      tiff_color_map::red_t   red   = NULL;
+      tiff_color_map::green_t green = NULL;
+      tiff_color_map::blue_t  blue  = NULL;
+
+      this->_io_dev.get_field_defaulted( red, green, blue );
+
+      typedef typename channel_traits<
+                    typename element_type<
+                            typename Indices_View::value_type >::type >::value_type channel_t;
+
+      int num_colors = channel_traits< channel_t >::max_value();
+
+      rgb16_planar_view_t palette = planar_rgb_view( num_colors
+                                                   , 1
+                                                   , red
+                                                   , green
+                                                   , blue
+                                                   , sizeof( bits16 ) * num_colors );
+
+      for( typename rgb16_view_t::y_coord_t y = 0; y < dst_view.height(); ++y )
+      {
+         typename rgb16_view_t::x_iterator it  = dst_view.row_begin( y );
+         typename rgb16_view_t::x_iterator end = dst_view.row_end( y );
+
+         typename Indices_View::x_iterator indices_it = indices_view.row_begin( y );
+
+         for( ; it != end; ++it, ++indices_it )
+         {
+            bits16 i = gil::at_c<0>( *indices_it );
+
+            *it = palette[i];
+         }
+      }
+   }
+
+   template< typename View
+           , typename Indices_View
+           >
+   inline
+   void read_palette_image( const View&         /* dst_view     */
+                          , const Indices_View& /* indices_view */
+                          , mpl::false_  // is View rgb16_view_t
+                          )
+   {
+      io_error( "User supplied image type must be rgb16_image_t." );
+   }
+
+   template< typename Buffer >
+   void skip_over_rows( Buffer& buffer
+                      , int     plane
+                      )
+   {
+      if( this->_info._compression != COMPRESSION_NONE )
+      {
+         // Skipping over rows is not possible for compressed images(  no random access ). See man
+         // page ( diagnostics section ) for more information.
+         for( std::ptrdiff_t row = 0; row < this->_settings._top_left.y; ++row )
+         {
+            this->_io_dev.read_scanline( buffer
+                                 , row
+                                 , static_cast< tsample_t >( plane ));
+         }
+      }
+   }
+
+   template< typename Buffer
+           , typename View
+           >
+   void read_data( const View& dst_view
+                 , int         plane     )
+    {
+        if( this->_io_dev.is_tiled() )
+        {
+            read_tiled_data< Buffer >( dst_view, 0 );
+        }
+        else
+        {
+            read_stripped_data< Buffer >( dst_view, 0 );
+        }
+    }
+
+
+   template< typename Buffer
+           , typename View
+           >
+   void read_tiled_data( const View& dst_view
+                       , int         plane
+                       )
+   {
+      if(  dst_view.width()  != this->_info._width
+        || dst_view.height() != this->_info._height
+        )
+      {
+          // read a subimage
+          read_tiled_data_subimage< Buffer >( dst_view, plane );
+      }
+      else
+      {
+          // read full image
+          read_tiled_data_full< Buffer >( dst_view, plane );
+      }
+   }
+
+   template< typename Buffer
+           , typename View
+           >
+   void read_tiled_data_subimage( const View& dst_view
+                                , int         plane
+                                )
+   {
+       ///@todo: why is 
+       /// typedef Buffer row_buffer_helper_t;
+       /// not working? I get compiler error with MSVC10.
+       /// read_stripped_data IS working.
+       typedef detail::row_buffer_helper_view< View > row_buffer_helper_t;
+
+       typedef typename row_buffer_helper_t::buffer_t   buffer_t;
+       typedef typename row_buffer_helper_t::iterator_t it_t;
+
+       tiff_image_width::type  image_width  = this->_info._width;
+       tiff_image_height::type image_height = this->_info._height;
+
+       tiff_tile_width::type  tile_width  = this->_info._tile_width;
+       tiff_tile_length::type tile_height = this->_info._tile_length;
+
+       std::ptrdiff_t subimage_x = this->_settings._top_left.x;
+       std::ptrdiff_t subimage_y = this->_settings._top_left.y;
+
+       std::ptrdiff_t subimage_width  = this->_settings._dim.x;
+       std::ptrdiff_t subimage_height = this->_settings._dim.y;
+
+       row_buffer_helper_t row_buffer_helper(this->_io_dev.get_tile_size(), true );
+
+       for( unsigned int y = 0; y < image_height; y += tile_height )
+       {
+           for( unsigned int x = 0; x < image_width; x += tile_width )
+           {
+               uint32_t current_tile_width  = ( x + tile_width  <  image_width ) ? tile_width  : image_width  - x;
+               uint32_t current_tile_length = ( y + tile_height < image_height ) ? tile_height : image_height - y;
+
+               this->_io_dev.read_tile( row_buffer_helper.buffer()
+                                , x
+                                , y
+                                , 0
+                                , static_cast< tsample_t >( plane )
+                                );
+
+               // these are all whole image coordinates
+               point_t tile_top_left   ( x, y );
+               point_t tile_lower_right( x + current_tile_width - 1, y + current_tile_length - 1 );
+
+               point_t view_top_left   ( subimage_x, subimage_y );
+               point_t view_lower_right( subimage_x + subimage_width  - 1
+                                       , subimage_y + subimage_height - 1 );
+
+               if(  tile_top_left.x    > view_lower_right.x
+                 || tile_top_left.y    > view_lower_right.y
+                 || tile_lower_right.x < view_top_left.x
+                 || tile_lower_right.y < view_top_left.y
+                 )
+               {
+                   // current tile and dst_view do not overlap
+                   continue;
+               }
+               else
+               {
+                   // dst_view is overlapping the current tile
+
+                   // next is to define the portion in the tile that needs to be copied
+
+                   // get the whole image coordinates
+                   std::ptrdiff_t img_x0 = ( tile_top_left.x >= view_top_left.x ) ? tile_top_left.x : view_top_left.x;
+                   std::ptrdiff_t img_y0 = ( tile_top_left.y >= view_top_left.y ) ? tile_top_left.y : view_top_left.y;
+
+                   std::ptrdiff_t img_x1 = ( tile_lower_right.x <= view_lower_right.x ) ? tile_lower_right.x : view_lower_right.x;
+                   std::ptrdiff_t img_y1 = ( tile_lower_right.y <= view_lower_right.y ) ? tile_lower_right.y : view_lower_right.y;
+
+                   // convert to tile coordinates
+                   std::ptrdiff_t tile_x0 = img_x0 - x;
+                   std::ptrdiff_t tile_y0 = img_y0 - y;
+                   std::ptrdiff_t tile_x1 = img_x1 - x;
+                   std::ptrdiff_t tile_y1 = img_y1 - y;
+
+                   assert( tile_x0 >= 0 && tile_y0 >= 0 && tile_x1 >= 0 && tile_y1 >= 0 );
+                   assert( tile_x0 <= img_x1 && tile_y0 <= img_y1 );
+                   assert( tile_x0 < tile_width && tile_y0 < tile_height && tile_x1 < tile_width && tile_y1 < tile_height );
+
+                   std::ptrdiff_t tile_subimage_view_width  = tile_x1 - tile_x0 + 1;
+                   std::ptrdiff_t tile_subimage_view_height = tile_y1 - tile_y0 + 1;
+
+                   // convert to dst_view coordinates
+                   std::ptrdiff_t dst_x0 = img_x0 - subimage_x;
+                   std::ptrdiff_t dst_y0 = img_y0 - subimage_y;
+                   assert( dst_x0 >= 0 && dst_y0 >= 0 );
+
+                   View dst_subimage_view = subimage_view( dst_view
+                                                         , (int) dst_x0
+                                                         , (int) dst_y0
+                                                         , (int) tile_subimage_view_width
+                                                         , (int) tile_subimage_view_height
+                                                         );
+
+                   // the row_buffer is a 1D array which represents a 2D image. We cannot
+                   // use interleaved_view here, since row_buffer could be bit_aligned.
+                   // Interleaved_view's fourth parameter "rowsize_in_bytes" doesn't work
+                   // for bit_aligned pixels.
+
+                   for( std::ptrdiff_t dst_row = 0; dst_row < dst_subimage_view.height(); ++dst_row )
+                   {
+                       std::ptrdiff_t tile_row = dst_row + tile_y0;
+
+                       // jump to the beginning of the current tile row
+                       it_t begin = row_buffer_helper.begin() + tile_row * tile_width;
+
+                       begin    += tile_x0;
+                       it_t end  = begin + dst_subimage_view.width();
+
+                       this->_cc_policy.read( begin
+                                            , end
+                                            , dst_subimage_view.row_begin( dst_row )
+                                            );
+                    } //for
+               }
+           } // for
+       } // for
+   }
+
+   template< typename Buffer
+           , typename View
+           >
+   void read_tiled_data_full( const View& dst_view
+                            , int         plane
+                            )
+   {
+       ///@todo: why is 
+       /// typedef Buffer row_buffer_helper_t;
+       /// not working? I get compiler error with MSVC10.
+       /// read_stripped_data IS working.
+       typedef detail::row_buffer_helper_view< View > row_buffer_helper_t;
+
+       typedef typename row_buffer_helper_t::buffer_t   buffer_t;
+       typedef typename row_buffer_helper_t::iterator_t it_t;
+
+       tiff_image_width::type  image_width  = this->_info._width;
+       tiff_image_height::type image_height = this->_info._height;
+
+       tiff_tile_width::type  tile_width  = this->_info._tile_width;
+       tiff_tile_length::type tile_height = this->_info._tile_length;
+
+       row_buffer_helper_t row_buffer_helper(this->_io_dev.get_tile_size(), true );
+
+       for( unsigned int y = 0; y < image_height; y += tile_height )
+       {
+           for( unsigned int x = 0; x < image_width; x += tile_width )
+           {
+               uint32_t current_tile_width  = ( x + tile_width  <  image_width ) ? tile_width  : image_width  - x;
+               uint32_t current_tile_length = ( y + tile_height < image_height ) ? tile_height : image_height - y;
+
+               this->_io_dev.read_tile( row_buffer_helper.buffer()
+                                , x
+                                , y
+                                , 0
+                                , static_cast< tsample_t >( plane )
+                                );
+
+               View dst_subimage_view = subimage_view( dst_view
+                                                     , x
+                                                     , y
+                                                     , current_tile_width
+                                                     , current_tile_length
+                                                     );
+
+               // the row_buffer is a 1D array which represents a 2D image. We cannot
+               // use interleaved_view here, since row_buffer could be bit_aligned.
+               // Interleaved_view's fourth parameter "rowsize_in_bytes" doesn't work
+               // for bit_aligned pixels.
+
+               for( int row = 0; row < dst_subimage_view.height(); ++row )
+               {
+                   it_t begin = row_buffer_helper.begin() + row * tile_width;
+                   it_t end   = begin + dst_subimage_view.width();
+
+                   this->_cc_policy.read( begin
+                                        , end
+                                        , dst_subimage_view.row_begin( row )
+                                        );
+                } //for
+           } // for
+       } // for
+   }
+
+   template< typename Buffer
+           , typename View
+           >
+   void read_stripped_data( const View& dst_view
+                          , int         plane     )
+   {
+      typedef typename is_bit_aligned< typename View::value_type >::type is_view_bit_aligned_t;
+
+      //typedef detail::row_buffer_helper_view< View > row_buffer_helper_t;
+      typedef Buffer row_buffer_helper_t;
+
+      typedef typename row_buffer_helper_t::buffer_t   buffer_t;
+      typedef typename row_buffer_helper_t::iterator_t it_t;
+
+      std::size_t size_to_allocate = buffer_size< typename View::value_type >( dst_view.width()
+                                                                             , is_view_bit_aligned_t() );
+	  row_buffer_helper_t row_buffer_helper( size_to_allocate, true );
+
+      it_t begin = row_buffer_helper.begin();
+
+      it_t first = begin + this->_settings._top_left.x;
+      it_t last  = first + this->_settings._dim.x; // one after last element
+
+      // I don't think tiff allows for random access of row, that's why we need 
+      // to read and discard rows when reading subimages.
+      skip_over_rows( row_buffer_helper.buffer()
+                    , plane
+                    );
+
+      std::ptrdiff_t row     = this->_settings._top_left.y;
+      std::ptrdiff_t row_end = row + this->_settings._dim.y;
+      std::ptrdiff_t dst_row = 0;
+
+      for( 
+         ; row < row_end
+         ; ++row, ++dst_row
+         )
+      {
+         this->_io_dev.read_scanline( row_buffer_helper.buffer()
+                              , row
+                              , static_cast< tsample_t >( plane )
+                              );
+
+         this->_cc_policy.read( first
+                              , last
+                              , dst_view.row_begin( dst_row ));
+      }
+   }
+
+    template< typename Pixel >
+    std::size_t buffer_size( std::size_t width
+                           , mpl::false_ // is_bit_aligned
+                           )
+    {
+        std::size_t scanline_size_in_bytes = this->_io_dev.get_scanline_size();
+
+        std::size_t element_size = sizeof( Pixel );
+
+        std::size_t ret = std::max( width
+                      , (( scanline_size_in_bytes + element_size - 1 ) / element_size ));
+
+        //assert( this->_scanline_length == ret );
+
+        return ret;
+    }
+
+    template< typename Pixel >
+    std::size_t buffer_size( std::size_t /* width */
+                            , mpl::true_  // is_bit_aligned
+                            )
+    {
+        return this->_io_dev.get_scanline_size();
+    }
+
+private:
+
+   template < int K > friend struct plane_recursion;
+};
+
+namespace detail {
+
+struct tiff_type_format_checker
+{
+    tiff_type_format_checker( const image_read_info< tiff_tag >& info )
+    : _info( info )
+    {}
+
+    template< typename Image >
+    bool apply()
+    {
+        typedef typename Image::view_t view_t;
+
+        return is_allowed< view_t >( _info
+                                   , mpl::true_()
+                                   );
+    }
+
+private:
+    tiff_type_format_checker& operator=( const tiff_type_format_checker& ) { return *this; }
+
+private:
+
+    const image_read_info< tiff_tag > _info;
+};
+
+struct tiff_read_is_supported
+{
+    template< typename View >
+    struct apply : public is_read_supported< typename get_pixel_type< View >::type
+                                           , tiff_tag
+                                           >
+    {};
+};
+
+} // namespace detail
+
+
+///
+/// Tiff Dynamic Image Reader
+///
+template< typename Device >
+class dynamic_image_reader< Device
+                          , tiff_tag
+                          >
+    : public reader< Device
+                   , tiff_tag
+                   , detail::read_and_no_convert
+                   >
+{
+    typedef reader< Device
+                  , tiff_tag
+                  , detail::read_and_no_convert
+                  > parent_t;
+
+public:
+
+    dynamic_image_reader( const Device&                          io_dev
+                        , const image_read_settings< tiff_tag >& settings
+                        )
+    : parent_t( io_dev
+              , settings
+              )
+    {}
+
+    template< typename Images >
+    void apply( any_image< Images >& images )
+    {
+        detail::tiff_type_format_checker format_checker( this->_info );
+
+        if( !construct_matched( images
+                              , format_checker
+                              ))
+        {
+            io_error( "No matching image type between those of the given any_image and that of the file" );
+        }
+        else
+        {
+            init_image( images
+                      , this->_settings
+                      );
+
+            detail::dynamic_io_fnobj< detail::tiff_read_is_supported
+                                    , parent_t
+                                    > op( this );
+
+            apply_operation( view( images )
+                           , op
+                           );
+        }
+    }
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_IO_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/reader_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/reader_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,131 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_IO_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_IO_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/tiff_tags.hpp>
+
+namespace boost { namespace gil {
+
+///
+/// TIFF Backend
+///
+template< typename Device >
+struct reader_backend< Device
+                     , tiff_tag
+                     >
+{
+public:
+
+    typedef tiff_tag format_tag_t;
+
+public:
+
+    reader_backend( const Device&                          io_dev
+                  , const image_read_settings< tiff_tag >& settings
+                  )
+    : _io_dev  ( io_dev   )
+    , _settings( settings )
+    , _info()
+
+    , _scanline_length( 0 )
+
+    , _red  ( NULL )
+    , _green( NULL )
+    , _blue ( NULL )
+    {
+        init_multipage_read( settings );
+
+        read_header();
+
+        if( _settings._dim.x == 0 )
+        {
+            _settings._dim.x = _info._width;
+        }
+
+        if( _settings._dim.y == 0 )
+        {
+            _settings._dim.y = _info._height;
+        }
+    }
+
+    void read_header()
+    {
+        io_error_if( _io_dev.template get_property<tiff_image_width>               ( _info._width ) == false
+                    , "cannot read tiff tag." );
+        io_error_if( _io_dev.template get_property<tiff_image_height>              ( _info._height ) == false
+                    , "cannot read tiff tag." );
+        io_error_if( _io_dev.template get_property<tiff_compression>               ( _info._compression ) == false
+                    , "cannot read tiff tag." );
+        io_error_if( _io_dev.template get_property<tiff_samples_per_pixel>         ( _info._samples_per_pixel ) == false
+                    , "cannot read tiff tag." );
+        io_error_if( _io_dev.template get_property<tiff_bits_per_sample>           ( _info._bits_per_sample ) == false
+                    , "cannot read tiff tag." );
+        io_error_if( _io_dev.template get_property<tiff_sample_format>             ( _info._sample_format ) == false
+                    , "cannot read tiff tag." );
+        io_error_if( _io_dev.template get_property<tiff_planar_configuration>      ( _info._planar_configuration ) == false
+                    , "cannot read tiff tag." );
+        io_error_if( _io_dev.template get_property<tiff_photometric_interpretation>( _info._photometric_interpretation  ) == false
+                    , "cannot read tiff tag." );
+
+        _info._is_tiled = false;
+
+        // Tile tags
+        if( _io_dev.is_tiled() )
+        {
+            _info._is_tiled = true;
+
+            io_error_if( !_io_dev.template get_property< tiff_tile_width  >( _info._tile_width )
+                        , "cannot read tiff_tile_width tag." );
+            io_error_if( !_io_dev.template get_property< tiff_tile_length >( _info._tile_length )
+                        , "cannot read tiff_tile_length tag." );
+        }
+    }
+
+private:
+
+    void init_multipage_read( const image_read_settings< tiff_tag >& settings )
+    {
+        if( settings._directory > 0 )
+        {
+            _io_dev.set_directory( settings._directory );
+        }
+    } 
+
+public:
+
+    Device _io_dev;
+
+    image_read_settings< tiff_tag > _settings;
+    image_read_info< tiff_tag >     _info;
+
+    std::size_t _scanline_length;
+
+    // palette
+    tiff_color_map::red_t   _red;
+    tiff_color_map::green_t _green;
+    tiff_color_map::blue_t  _blue;
+
+    rgb16_planar_view_t _palette;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_IO_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/scanline_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/scanline_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,477 @@
+/*
+    Copyright 2007-2012 Christian Henning, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_IO_SCANLINE_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_IO_SCANLINE_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+// taken from jpegxx - https://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/ijg_headers.hpp
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_C_LIB_COMPILED_AS_CPLUSPLUS
+    extern "C" {
+#else
+    // DONT_USE_EXTERN_C introduced in v7 of the IJG library.
+    // By default the v7 IJG headers check for __cplusplus being defined and
+    // wrap the content in an 'extern "C"' block if it's present.
+    // When DONT_USE_EXTERN_C is defined, this wrapping is not performed.
+    #ifndef DONT_USE_EXTERN_C
+        #define DONT_USE_EXTERN_C 1
+    #endif
+#endif
+
+#include <tiff.h>
+#include <tiffio.h>
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_C_LIB_COMPILED_AS_CPLUSPLUS
+    }
+#endif
+
+#include <algorithm>
+#include <string>
+#include <vector>
+
+#include <boost/function.hpp>
+#include <boost/static_assert.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/conversion_policies.hpp>
+#include <boost/gil/extension/io_new/detail/bit_operations.hpp>
+#include <boost/gil/extension/io_new/detail/row_buffer_helper.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+#include <boost/gil/extension/io_new/detail/reader_base.hpp>
+
+#include "reader_backend.hpp"
+#include "device.hpp"
+#include "is_allowed.hpp"
+
+
+namespace boost { namespace gil {
+
+///
+/// TIFF scanline reader
+///
+template< typename Device >
+class scanline_reader< Device
+                     , tiff_tag
+                     >
+    : public reader_backend< Device
+                           , tiff_tag
+                           >
+{
+private:
+
+    typedef scanline_reader< Device
+                           , tiff_tag
+                           > this_t;
+public:
+
+    typedef reader_backend< Device
+                          , tiff_tag
+                          > backend_t;
+
+public:
+
+    scanline_reader( Device&                                device
+                   , const image_read_settings< tiff_tag >& settings
+                   )
+    : backend_t( device
+               , settings
+               )
+    {
+        initialize();
+    }
+
+    /// Read part of image defined by View and return the data.
+    void read( byte_t* dst, int pos )
+    {
+        _read_function( this, dst, pos );
+    }    
+
+    /// Skip over a scanline.
+    void skip( byte_t* dst, int pos )
+    {
+        this->_read_function( this, dst, pos );
+    }
+
+    void clean_up()
+    {
+        ///@todo
+    }
+
+private:
+
+    void initialize()
+    {
+        io_error_if( this->_info._is_tiled
+                   , "scanline_reader doesn't support tiled tiff images."
+                   );
+
+        if( this->_info._photometric_interpretation == PHOTOMETRIC_PALETTE )
+        {
+
+            this->_scanline_length = this->_info._width 
+                                   * num_channels< rgb16_view_t >::value 
+                                   * sizeof( channel_type<rgb16_view_t>::type );
+
+            this->_io_dev.get_field_defaulted( this->_red
+                                        , this->_green
+                                        , this->_blue
+                                        );
+
+            _buffer = std::vector< byte_t >( this->_io_dev.get_scanline_size() );
+
+            switch( this->_info._bits_per_sample )
+            {
+                case 1:
+                {
+                    typedef channel_type< get_pixel_type< gray1_image_t::view_t >::type >::type channel_t;
+
+                    int num_colors = channel_traits< channel_t >::max_value() + 1;
+
+                    this->_palette = planar_rgb_view( num_colors
+                                              , 1
+                                              , this->_red
+                                              , this->_green
+                                              , this->_blue
+                                              , sizeof( bits16 ) * num_colors
+                                              );
+
+                    _read_function = boost::mem_fn( &this_t::read_1_bit_index_image );
+
+                    break;
+                }
+
+                case 2:
+                {
+                    typedef channel_type< get_pixel_type< gray2_image_t::view_t >::type >::type channel_t;
+
+                    int num_colors = channel_traits< channel_t >::max_value() + 1;
+
+                    this->_palette = planar_rgb_view( num_colors
+                                              , 1
+                                              , this->_red
+                                              , this->_green
+                                              , this->_blue
+                                              , sizeof( bits16 ) * num_colors
+                                              );
+
+                    _read_function = boost::mem_fn( &this_t::read_2_bits_index_image );
+
+                    break;
+                }
+                case 4:
+                {
+                    typedef channel_type< get_pixel_type< gray4_image_t::view_t >::type >::type channel_t;
+
+                    int num_colors = channel_traits< channel_t >::max_value() + 1;
+
+                    this->_palette = planar_rgb_view( num_colors
+                                              , 1
+                                              , this->_red
+                                              , this->_green
+                                              , this->_blue
+                                              , sizeof( bits16 ) * num_colors
+                                              );
+
+                    _read_function = boost::mem_fn( &this_t::read_4_bits_index_image );
+
+                    break;
+                }
+
+                case 8:  
+                {
+                    typedef channel_type< get_pixel_type< gray8_image_t::view_t >::type >::type channel_t;
+
+                    int num_colors = channel_traits< channel_t >::max_value() + 1;
+
+                    this->_palette = planar_rgb_view( num_colors
+                                              , 1
+                                              , this->_red
+                                              , this->_green
+                                              , this->_blue
+                                              , sizeof( bits16 ) * num_colors
+                                              );
+
+                    _read_function = boost::mem_fn( &this_t::read_8_bits_index_image );
+
+                    break;
+                }
+
+                case 16:
+                {
+                    typedef channel_type< get_pixel_type< gray16_image_t::view_t >::type >::type channel_t;
+
+                    int num_colors = channel_traits< channel_t >::max_value() + 1;
+
+                    this->_palette = planar_rgb_view( num_colors
+                                              , 1
+                                              , this->_red
+                                              , this->_green
+                                              , this->_blue
+                                              , sizeof( bits16 ) * num_colors
+                                              );
+
+                    _read_function = boost::mem_fn( &this_t::read_16_bits_index_image );
+
+                    break;
+                }
+
+                case 24:
+                {
+                    typedef channel_type< get_pixel_type< gray24_image_t::view_t >::type >::type channel_t;
+
+                    int num_colors = channel_traits< channel_t >::max_value() + 1;
+
+                    this->_palette = planar_rgb_view( num_colors
+                                              , 1
+                                              , this->_red
+                                              , this->_green
+                                              , this->_blue
+                                              , sizeof( bits16 ) * num_colors
+                                              );
+
+                    _read_function = boost::mem_fn( &this_t::read_24_bits_index_image );
+
+                    break;
+                }
+
+                case 32:
+                {
+                    typedef channel_type< get_pixel_type< gray32_image_t::view_t >::type >::type channel_t;
+
+                    int num_colors = channel_traits< channel_t >::max_value() + 1;
+
+                    this->_palette = planar_rgb_view( num_colors
+                                              , 1
+                                              , this->_red
+                                              , this->_green
+                                              , this->_blue
+                                              , sizeof( bits16 ) * num_colors
+                                              );
+
+                    _read_function = boost::mem_fn( &this_t::read_32_bits_index_image );
+
+                    break;
+                }
+                default: { io_error( "Not supported palette " ); }
+            }
+        }
+        else
+        {
+            this->_scanline_length = this->_io_dev.get_scanline_size();
+
+            if( this->_info._planar_configuration == PLANARCONFIG_SEPARATE )
+            {
+                io_error( "scanline_reader doesn't support planar tiff images." );
+            }
+            else if( this->_info._planar_configuration == PLANARCONFIG_CONTIG )
+            {
+
+                // the read_data function needs to know what gil type the source image is
+                // to have the default color converter function correctly
+
+                switch( this->_info._photometric_interpretation )
+                {
+                    case PHOTOMETRIC_MINISWHITE:
+                    case PHOTOMETRIC_MINISBLACK:
+                    {
+                        switch( this->_info._bits_per_sample )
+                        {
+                            case  1: 
+                            case  2: 
+                            case  4:
+                            case  6: 
+                            case  8: 
+                            case 10: 
+                            case 12: 
+                            case 14: 
+                            case 16: 
+                            case 24: 
+                            case 32: { _read_function = boost::mem_fn( &this_t::read_row ); break; }
+                            default: { io_error( "Image type is not supported." ); }
+                        }
+
+                        break;
+                    }
+
+                    case PHOTOMETRIC_RGB:
+                    {
+                        switch( this->_info._samples_per_pixel )
+                        {
+                            case 3:
+                            {
+                                switch( this->_info._bits_per_sample )
+                                {
+                                    case  2: 
+                                    case  4: 
+                                    case  8: 
+                                    case 10: 
+                                    case 12: 
+                                    case 14: 
+                                    case 16: 
+                                    case 24: 
+                                    case 32: { _read_function = boost::mem_fn( &this_t::read_row );  break; }
+                                    default: { io_error( "Image type is not supported." ); }
+                                }
+
+                                break;
+                            }
+
+                            case 4:
+                            {
+                                switch( this->_info._bits_per_sample )
+                                {
+                                    case  2: 
+                                    case  4: 
+                                    case  8: 
+                                    case 10: 
+                                    case 12: 
+                                    case 14: 
+                                    case 16: 
+                                    case 24: 
+                                    case 32: { _read_function = boost::mem_fn( &this_t::read_row );  break; }
+                                    default: { io_error( "Image type is not supported." ); }
+                                }
+
+                                break;
+                            }
+
+                            default: { io_error( "Image type is not supported." ); }
+                        }
+
+                        break;
+                    }
+                    case PHOTOMETRIC_SEPARATED: // CYMK
+                    {
+                        switch( this->_info._bits_per_sample )
+                        {
+                            case  2: 
+                            case  4: 
+                            case  8: 
+                            case 10: 
+                            case 12: 
+                            case 14: 
+                            case 16: 
+                            case 24: 
+                            case 32: { _read_function = boost::mem_fn( &this_t::read_row );  break; }
+                            default: { io_error( "Image type is not supported." ); }
+                        }
+
+                        break;
+                    }
+
+                    default: { io_error( "Image type is not supported." ); }
+                }
+            }
+            else
+            {
+                io_error( "Wrong planar configuration setting." );
+            }
+        }
+    }
+
+    template< typename Src_View >
+    void read_n_bits_row( byte_t* dst, int pos )
+    {
+        typedef rgb16_view_t dst_view_t;
+
+        this->_io_dev.read_scanline( _buffer
+                                   , pos
+                                   , 0
+                                   );
+
+        Src_View src_view = interleaved_view( this->_info._width
+                                            , 1
+                                            , (typename Src_View::x_iterator) &_buffer.front()
+                                            , this->_scanline_length
+                                            );
+
+        dst_view_t dst_view = interleaved_view( this->_info._width
+                                              , 1
+                                              , (typename dst_view_t::value_type*) dst
+                                              , num_channels< dst_view_t >::value * 2 * this->_info._width
+                                              );
+
+
+        typename Src_View::x_iterator   src_it = src_view.row_begin( 0 );
+        typename dst_view_t::x_iterator dst_it = dst_view.row_begin( 0 );
+
+        for( dst_view_t::x_coord_t i = 0
+           ; i < this->_info._width
+           ; ++i, src_it++, dst_it++
+           )
+        {
+            boost::uint16_t c = get_color( *src_it, gray_color_t() );
+            *dst_it = this->_palette[c];
+        }
+    }
+
+    void read_1_bit_index_image( byte_t* dst, int pos )
+    {
+        read_n_bits_row< gray1_image_t::view_t >( dst, pos );
+    }
+
+    void read_2_bits_index_image( byte_t* dst, int pos )
+    {
+        read_n_bits_row< gray2_image_t::view_t >( dst, pos );
+    }
+
+    void read_4_bits_index_image( byte_t* dst, int pos )
+    {
+        read_n_bits_row< gray4_image_t::view_t >( dst, pos );
+    }
+
+    void read_8_bits_index_image( byte_t* dst, int pos )
+    {
+        read_n_bits_row< gray8_image_t::view_t >( dst, pos );
+    }
+    
+    void read_16_bits_index_image( byte_t* dst, int pos )
+    {
+        read_n_bits_row< gray16_image_t::view_t >( dst, pos );
+    }
+
+    void read_24_bits_index_image( byte_t* dst, int pos )
+    {
+        read_n_bits_row< gray24_image_t::view_t >( dst, pos );
+    }
+
+    void read_32_bits_index_image( byte_t* dst, int pos )
+    {
+        read_n_bits_row< gray32_image_t::view_t >( dst, pos );
+    }
+
+    void read_row(byte_t* dst, int pos )
+    {
+         this->_io_dev.read_scanline( dst
+                                    , pos
+                                    , 0
+                                    );
+    }
+
+private:
+
+    std::vector< byte_t > _buffer;
+
+    detail::mirror_bits< std::vector< byte_t >, mpl::true_ > _mirror_bites;
+
+    boost::function< void ( this_t*, byte_t*, int ) > _read_function;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_IO_SCANLINE_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/supported_types.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/supported_types.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,62 @@
+/*
+    Copyright 2007-2008 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_IO_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_IO_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/mpl/not.hpp>
+#include <boost/type_traits/is_same.hpp>
+
+#include <boost/gil/channel.hpp>
+#include <boost/gil/color_base.hpp>
+
+namespace boost{ namespace gil {
+
+namespace detail {
+
+// Read support
+
+// TIFF virtually supports everything 
+struct tiff_read_support : read_support_true
+{};
+
+
+// Write support
+
+struct tiff_write_support : write_support_true
+{};
+
+} // namespace detail
+
+template< typename Pixel >
+struct is_read_supported< Pixel
+                        , tiff_tag
+                        > 
+    : mpl::bool_< detail::tiff_read_support::is_supported > {};
+
+template< typename Pixel >
+struct is_write_supported< Pixel
+                         , tiff_tag
+                         > 
+    : mpl::bool_< detail::tiff_write_support::is_supported >
+{};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_IO_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,363 @@
+/*
+    Copyright 2007-2012 Christian Henning, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_IO_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_IO_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning, Lubomir Bourdev \n
+///
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+extern "C" {
+#include "tiff.h"
+#include "tiffio.h"
+}
+
+#include <algorithm>
+#include <string>
+#include <vector>
+#include <boost/static_assert.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include <boost/gil/extension/io_new/tiff_tags.hpp>
+
+#include <boost/gil/extension/io_new/detail/base.hpp>
+#include <boost/gil/extension/io_new/detail/io_device.hpp>
+
+#include "writer_backend.hpp"
+#include "device.hpp"
+
+namespace boost { namespace gil {
+
+namespace detail {
+
+template <typename PixelReference>
+struct my_interleaved_pixel_iterator_type_from_pixel_reference
+{
+private:
+	typedef typename remove_reference< PixelReference >::type::value_type pixel_t;
+public:
+	typedef typename iterator_type_from_pixel< pixel_t
+	                                         , false
+	                                         , false
+	                                         , true
+	                                         >::type type;
+};
+
+
+template< typename Channel
+        , typename Layout
+        , bool Mutable
+        >
+struct my_interleaved_pixel_iterator_type_from_pixel_reference< const bit_aligned_pixel_reference< byte_t
+                                                                                                 , Channel
+                                                                                                 , Layout
+                                                                                                 , Mutable
+                                                                                                 >
+                                                              >
+	: public iterator_type_from_pixel< const bit_aligned_pixel_reference< uint8_t
+	                                                                    , Channel
+	                                                                    , Layout
+	                                                                    , Mutable
+	                                                                    >
+	                                 ,false
+	                                 ,false
+	                                 ,true
+	                                 > {};
+
+struct tiff_write_is_supported
+{
+    template< typename View >
+    struct apply 
+        : public is_write_supported< typename get_pixel_type< View >::type
+                                   , tiff_tag
+                                   >
+    {};
+};
+
+} // namespace detail
+
+///
+/// TIFF Writer
+///
+template < typename Device, typename Log >
+class writer< Device
+            , tiff_tag
+            , Log
+            >
+    : public writer_backend< Device
+                           , tiff_tag
+                           >
+{
+private:
+    typedef writer_backend< Device, tiff_tag > backend_t;
+public:
+
+    writer( const Device&                       io_dev
+          , const image_write_info< tiff_tag >& info
+          )
+    : backend_t( io_dev
+               , info
+               )
+    {}
+
+    template<typename View>
+    void apply( const View& view )
+    {
+        write_view( view );
+    }
+
+private:
+
+    template< typename View >
+    void write_view( const View& view )
+    {
+        typedef typename View::value_type pixel_t;
+        // get the type of the first channel (heterogeneous pixels might be broken for now!)
+        typedef typename channel_traits< typename element_type< pixel_t >::type >::value_type channel_t;
+        tiff_bits_per_sample::type bits_per_sample = detail::unsigned_integral_num_bits< channel_t >::value;
+
+        tiff_samples_per_pixel::type samples_per_pixel = num_channels< pixel_t >::value;
+
+        write_header( view );
+
+        if( this->_info._is_tiled == false )
+        {
+            write_data( view
+                      , (view.width() * samples_per_pixel * bits_per_sample + 7) / 8
+                      , typename is_bit_aligned< pixel_t >::type()
+                      );
+        }
+        else
+        {
+            tiff_tile_width::type  tw = this->_info._tile_width;
+            tiff_tile_length::type th = this->_info._tile_length;
+
+            if(!this->_io_dev.check_tile_size( tw, th ))
+            {
+                io_error( "Tile sizes need to be multiples of 16." );
+            }
+
+            // tile related tags
+            this->_io_dev.template set_property<tiff_tile_width> ( tw );
+            this->_io_dev.template set_property<tiff_tile_length>( th );
+
+            write_tiled_data( view
+                            , tw
+                            , th
+                            , typename is_bit_aligned< pixel_t >::type()
+                            );
+        }
+    }
+
+    template< typename View >
+    void write_data( const View&   view
+                   , std::size_t   row_size_in_bytes
+                   , const mpl::true_&    // bit_aligned
+                   )
+    {
+        byte_vector_t row( row_size_in_bytes );
+
+        typedef typename View::x_iterator x_it_t;
+        x_it_t row_it = x_it_t( &(*row.begin()));
+
+        for( typename View::y_coord_t y = 0; y < view.height(); ++y )
+        {
+            std::copy( view.row_begin( y )
+                     , view.row_end( y )
+                     , row_it
+                     );
+
+            this->_io_dev.write_scaline( row
+                                       , (uint32) y
+                                       , 0
+                                       );
+
+            // @todo: do optional bit swapping here if you need to...
+        }
+    }
+
+    template< typename View >
+    void write_tiled_data( const View&            view
+                         , tiff_tile_width::type  tw
+                         , tiff_tile_length::type th
+                         , const mpl::true_&    // bit_aligned
+                         )
+    {
+        byte_vector_t row( this->_io_dev.get_tile_size() );
+
+        typedef typename View::x_iterator x_it_t;
+        x_it_t row_it = x_it_t( &(*row.begin()));
+
+        internal_write_tiled_data(view, tw, th, row, row_it);
+    }
+
+    template< typename View >
+    void write_data( const View&   view
+                   , std::size_t   row_size_in_bytes
+                   , const mpl::false_&    // bit_aligned
+                   )
+    {
+        std::vector< pixel< typename channel_type< View >::type
+                          , layout<typename color_space_type< View >::type >
+                          >
+                   > row( view.size() );
+
+        byte_t* row_addr = reinterpret_cast< byte_t* >( &row.front() );
+
+        for( typename View::y_coord_t y = 0; y < view.height(); ++y )
+        {
+            std::copy( view.row_begin( y )
+                     , view.row_end  ( y )
+                     , row.begin()
+                     );
+
+            this->_io_dev.write_scaline( row_addr
+                                       , (uint32) y
+                                       , 0
+                                       );
+
+            // @todo: do optional bit swapping here if you need to...
+        }
+    }
+
+    template< typename View >
+    void write_tiled_data( const View&            view
+                         , tiff_tile_width::type  tw
+                         , tiff_tile_length::type th
+                         , const mpl::false_&    // bit_aligned
+                         )
+    {
+        byte_vector_t row( this->_io_dev.get_tile_size() );
+
+        typedef typename detail::my_interleaved_pixel_iterator_type_from_pixel_reference< typename View::reference
+                                                                                >::type x_iterator;
+        x_iterator row_it = x_iterator( &(*row.begin()));
+
+        internal_write_tiled_data(view, tw, th, row, row_it);
+    }
+
+    template< typename View,
+              typename IteratorType
+            >
+    void internal_write_tiled_data( const View&            view
+                                  , tiff_tile_width::type  tw
+                                  , tiff_tile_length::type th
+                                  , byte_vector_t&         row
+                                  , IteratorType           it
+                                  )
+    {
+        std::ptrdiff_t i = 0, j = 0;
+        View tile_subimage_view;
+        while( i < view.height() )
+        {
+            while( j < view.width() )
+            {
+                if( j + tw < view.width() && i + th < view.height() )
+                {
+                    // a tile is fully included in the image: just copy values
+                    tile_subimage_view = subimage_view( view
+                                                      , static_cast< int >( j  )
+                                                      , static_cast< int >( i  )
+                                                      , static_cast< int >( tw )
+                                                      , static_cast< int >( th )
+                                                      );
+
+                    std::copy( tile_subimage_view.begin()
+                             , tile_subimage_view.end()
+                             , it
+                             );
+                }
+                else
+                {
+                    std::ptrdiff_t width  = view.width();
+                    std::ptrdiff_t height = view.height();
+
+                    std::ptrdiff_t current_tile_width  = ( j + tw < width ) ? tw : width  - j;
+                    std::ptrdiff_t current_tile_length = ( i + th < height) ? th : height - i;
+
+                    tile_subimage_view = subimage_view( view
+                                                      , static_cast< int >( j )
+                                                      , static_cast< int >( i )
+                                                      , static_cast< int >( current_tile_width )
+                                                      , static_cast< int >( current_tile_length )
+                                                      );
+
+                    for( typename View::y_coord_t y = 0; y < tile_subimage_view.height(); ++y )
+                    {
+                        std::copy( tile_subimage_view.row_begin( y )
+                                 , tile_subimage_view.row_end( y )
+                                 , it
+                                 );
+                        std::advance(it, tw);
+                    }
+
+                    it = IteratorType( &(*row.begin()));
+                }
+
+                this->_io_dev.write_tile( row
+                                        , static_cast< uint32 >( j )
+                                        , static_cast< uint32 >( i )
+                                        , 0
+                                        , 0
+                                        );
+                j += tw;
+            }
+            j = 0;
+            i += th;
+        }
+        // @todo: do optional bit swapping here if you need to...
+    }
+};
+
+///
+/// TIFF Dynamic Image Writer
+///
+template< typename Device >
+class dynamic_image_writer< Device
+                          , tiff_tag
+                          >
+    : public writer< Device
+                   , tiff_tag
+                   >
+{
+    typedef writer< Device
+                  , tiff_tag
+                  > parent_t;
+
+public:
+
+    dynamic_image_writer( const Device&                       io_dev
+                        , const image_write_info< tiff_tag >& info
+                        )
+    : parent_t( io_dev
+              , info
+              )
+    {}
+
+    template< typename Views >
+    void apply( const any_image_view< Views >& views )
+    {
+        detail::dynamic_io_fnobj< detail::tiff_write_is_supported
+                                , parent_t
+                                > op( this );
+
+        apply_operation( views, op );
+    }
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_IO_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/writer_backend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/formats/tiff/writer_backend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,121 @@
+/*
+    Copyright 2012 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_IO_WRITER_BACKEND_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_IO_WRITER_BACKEND_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/extension/io_new/tiff_tags.hpp>
+
+namespace boost { namespace gil {
+
+///
+/// TIFF Writer Backend
+///
+template< typename Device >
+struct writer_backend< Device
+                     , tiff_tag
+                     >
+{
+public:
+
+    typedef tiff_tag format_tag_t;
+
+public:
+
+    writer_backend( const Device&                       io_dev
+                  , const image_write_info< tiff_tag >& info
+                  )
+    : _io_dev( io_dev )
+    , _info( info )
+    {}
+
+protected:
+
+    template< typename View >
+    void write_header( const View& view )
+    {
+        typedef typename View::value_type pixel_t;
+
+        // get the type of the first channel (heterogeneous pixels might be broken for now!)
+        typedef typename channel_traits< typename element_type< pixel_t >::type >::value_type channel_t;
+
+        if( this->_info._photometric_interpretation_user_defined )
+        {
+            typedef typename color_space_type< View >::type color_space_t;
+
+            // write photometric interpretion - Warning: This value is rather subjective.
+            // The user should better set this value itself. There is no way to decide if
+            // a image is PHOTOMETRIC_MINISWHITE or PHOTOMETRIC_MINISBLACK. This writer
+            // will assume PHOTOMETRIC_MINISBLACK for gray_t images and PHOTOMETRIC_RGB
+            // for rgb_t images.
+            this->_info._photometric_interpretation = detail::photometric_interpretation< color_space_t >::value;
+        }
+
+        // write dimensions
+        tiff_image_width::type  width  = (tiff_image_width::type)  view.width();
+        tiff_image_height::type height = (tiff_image_height::type) view.height();
+
+        this->_io_dev.template set_property< tiff_image_width  >( width  );
+        this->_io_dev.template set_property< tiff_image_height >( height );
+
+        // write planar configuration
+        this->_io_dev.template set_property<tiff_planar_configuration>( this->_info._planar_configuration );
+
+        // write samples per pixel
+        tiff_samples_per_pixel::type samples_per_pixel = num_channels< pixel_t >::value;
+        this->_io_dev.template set_property<tiff_samples_per_pixel>( samples_per_pixel );
+
+        // write bits per sample
+        // @todo: Settings this value usually requires to write for each sample the bit
+        // value seperately in case they are different, like rgb556.
+        tiff_bits_per_sample::type bits_per_sample = detail::unsigned_integral_num_bits< channel_t >::value;
+        this->_io_dev.template set_property<tiff_bits_per_sample>( bits_per_sample );
+
+        // write sample format
+        tiff_sample_format::type sampl_format = detail::sample_format< channel_t >::type::value;
+        this->_io_dev.template set_property<tiff_sample_format>( sampl_format );
+
+        // write photometric format
+        this->_io_dev.template set_property<tiff_photometric_interpretation>( this->_info._photometric_interpretation );
+
+        // write compression
+        this->_io_dev.template set_property<tiff_compression>( this->_info._compression );
+
+        // write orientation
+        this->_io_dev.template set_property<tiff_orientation>( this->_info._orientation );
+
+        // write rows per strip
+        this->_io_dev.template set_property<tiff_rows_per_strip>( this->_io_dev.get_default_strip_size() );
+
+        // x, y resolution
+        this->_io_dev.template set_property<tiff_x_resolution>( this->_info._x_resolution );
+        this->_io_dev.template set_property<tiff_y_resolution>( this->_info._y_resolution );
+    }
+
+
+public:
+
+    Device _io_dev;
+
+    image_write_info< tiff_tag > _info;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_IO_WRITER_BACKEND_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/jpeg_all.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/jpeg_all.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,25 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_ALL_HPP
+#define BOOST_GIL_EXTENSION_IO_JPEG_ALL_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning, Andreas Pokorny \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "jpeg_read.hpp"
+#include "jpeg_write.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_ALL_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/jpeg_io_old.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/jpeg_io_old.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,182 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_IO_OLD_HPP
+#define BOOST_GIL_EXTENSION_IO_JPEG_IO_OLD_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "jpeg_all.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup JPEG_IO
+/// \brief Returns the width and height of the JPEG file at the specified location.
+/// Throws std::ios_base::failure if the location does not correspond to a valid JPEG file
+template< typename String >
+inline
+point2< std::ptrdiff_t > jpeg_read_dimensions( const String& filename )
+{
+    typedef typename get_reader_backend< String
+                                       , jpeg_tag
+                                       >::type backend_t;
+
+    backend_t backend = read_image_info( filename
+                                       , jpeg_tag()
+                                       );
+
+    return point2< std::ptrdiff_t >( backend._info._width
+                                   , backend._info._height
+                                   );
+}
+
+
+/// \ingroup JPEG_IO
+/// \brief Loads the image specified by the given jpeg image file name into the given view.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the JPEG library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid JPEG file, or if its color space or channel depth are not 
+/// compatible with the ones specified by View, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline 
+void jpeg_read_view( const String& filename
+                   , const View&   view
+                   )
+{
+    read_view( filename
+             , view
+             , jpeg_tag()
+             );
+}
+
+/// \ingroup JPEG_IO
+/// \brief Allocates a new image whose dimensions are determined by the given jpeg image file, and loads the pixels into it.
+/// Triggers a compile assert if the image color space or channel depth are not supported by the JPEG library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid JPEG file, or if its color space or channel depth are not 
+/// compatible with the ones specified by Image
+template< typename String
+        , typename Image
+        >
+inline 
+void jpeg_read_image( const String& filename
+                    , Image&        img
+                    )
+{
+    read_image( filename
+              , img
+              , jpeg_tag()
+              );
+}
+
+/// \ingroup JPEG_IO
+/// \brief Loads and color-converts the image specified by the given jpeg image file name into the given view.
+/// Throws std::ios_base::failure if the file is not a valid JPEG file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        , typename CC
+        >
+inline 
+void jpeg_read_and_convert_view( const String& filename
+                               , const View&   view
+                               , CC            cc
+                               )
+{
+    read_and_convert_view( filename
+                         , view
+                         , cc
+                         , jpeg_tag()
+                         );
+}
+
+/// \ingroup JPEG_IO
+/// \brief Loads and color-converts the image specified by the given jpeg image file name into the given view.
+/// Throws std::ios_base::failure if the file is not a valid JPEG file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline 
+void jpeg_read_and_convert_view( const String& filename
+                               , const View&   view
+                               )
+{
+    read_and_convert_view( filename
+                         , view
+                         , jpeg_tag()
+                         );
+}
+
+/// \ingroup JPEG_IO
+/// \brief Allocates a new image whose dimensions are determined by the given jpeg image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid JPEG file
+template< typename String
+        , typename Image
+        , typename CC
+        >
+inline 
+void jpeg_read_and_convert_image( const String& filename
+                                , Image& img
+                                , CC     cc
+                                )
+{
+    read_and_convert_image( filename
+                          , img
+                          , cc
+                          , jpeg_tag()
+                          );
+}
+
+/// \ingroup JPEG_IO
+/// \brief Allocates a new image whose dimensions are determined by the given jpeg image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid JPEG file
+template< typename String
+        , typename Image
+        >
+inline 
+void jpeg_read_and_convert_image( const String filename
+                                , Image&       img
+                                )
+{
+    read_and_convert_image( filename
+                          , img
+                          , jpeg_tag()
+                          );
+}
+
+
+/// \ingroup JPEG_IO
+/// \brief Saves the view to a jpeg file specified by the given jpeg image file name.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the JPEG library or by the I/O extension.
+/// Throws std::ios_base::failure if it fails to create the file.
+template< typename String
+        , typename View
+        >
+inline
+void jpeg_write_view( const String& filename
+                    , const View&   view
+                    , int   quality = jpeg_quality::default_value
+                    )
+{
+    write_view( filename
+              , view
+              , image_write_info< jpeg_tag >( quality )
+              );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_IO_OLD_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/jpeg_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/jpeg_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,43 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_JPEG_READ_HPP
+
+#define BOOST_GIL_EXTENSION_IO_JPEG_READ_ENABLED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning, Andreas Pokorny \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "jpeg_tags.hpp"
+#include "formats/jpeg/supported_types.hpp"
+#include "formats/jpeg/read.hpp"
+#include "formats/jpeg/scanline_read.hpp"
+
+#include "detail/get_reader.hpp"
+#include "detail/make_backend.hpp"
+#include "detail/make_reader.hpp"
+#include "detail/make_dynamic_image_reader.hpp"
+#include "detail/make_scanline_reader.hpp"
+
+#include "detail/read_image.hpp"
+#include "detail/read_view.hpp"
+#include "detail/read_image_info.hpp"
+#include "detail/read_and_convert_image.hpp"
+#include "detail/read_and_convert_view.hpp"
+
+#include "detail/image_read_iterator.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/jpeg_tags.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/jpeg_tags.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,244 @@
+/*
+    Copyright 2007-2012 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_TAGS_HPP 
+#define BOOST_GIL_EXTENSION_IO_JPEG_TAGS_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief All supported jpeg tags by the gil io extension.
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///         
+/// \date   2007-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+// taken from jpegxx - https://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/ijg_headers.hpp
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_C_LIB_COMPILED_AS_CPLUSPLUS
+    extern "C" {
+#else
+    // DONT_USE_EXTERN_C introduced in v7 of the IJG library.
+    // By default the v7 IJG headers check for __cplusplus being defined and
+    // wrap the content in an 'extern "C"' block if it's present.
+    // When DONT_USE_EXTERN_C is defined, this wrapping is not performed.
+    #ifndef DONT_USE_EXTERN_C
+        #define DONT_USE_EXTERN_C 1
+    #endif
+#endif
+
+//jpeglib doesn't know about FILE
+#include <stdio.h>
+
+#include <jpeglib.h>
+#include <jerror.h>
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_C_LIB_COMPILED_AS_CPLUSPLUS
+    }
+#endif
+
+#include "detail/base.hpp"
+
+namespace boost { namespace gil {
+
+/// Defines jpeg tag.
+struct jpeg_tag : format_tag {};
+
+/// see http://en.wikipedia.org/wiki/JPEG for reference
+
+/// Defines type for image width property.
+struct jpeg_image_width : property_base< JDIMENSION > {};
+
+/// Defines type for image height property.
+struct jpeg_image_height : property_base< JDIMENSION > {};
+
+/// Defines type for number of components property.
+struct jpeg_num_components : property_base< int > {};
+
+/// Defines type for color space property.
+struct jpeg_color_space : property_base< J_COLOR_SPACE > {};
+
+/// Defines type for jpeg quality property.
+struct jpeg_quality : property_base< int >
+{
+    static const type default_value = 100;
+};
+
+/// Defines type for data precision property.
+struct jpeg_data_precision : property_base< int > {};
+
+/// JFIF code for pixel size units
+struct jpeg_density_unit : property_base< UINT8 >
+{
+    static const type default_value = 0;
+};
+
+/// pixel density
+struct jpeg_pixel_density : property_base< UINT16 >
+{
+    static const type default_value = 0;
+};
+
+/// Defines type for dct ( discrete cosine transformation ) method property.
+struct jpeg_dct_method : property_base< J_DCT_METHOD >
+{
+    static const type slow        = JDCT_ISLOW;
+    static const type fast        = JDCT_IFAST;
+    static const type floating_pt = JDCT_FLOAT;
+    static const type fastest     = JDCT_FASTEST;
+
+    static const type default_value = slow;
+};
+
+/// Read information for jpeg images.
+///
+/// The structure is returned when using read_image_info.
+template<>
+struct image_read_info< jpeg_tag >
+{
+    image_read_info()
+    : _width ( 0 )
+    , _height( 0 )
+
+    , _num_components( 0 )
+
+    , _color_space( J_COLOR_SPACE( 0 ))
+
+    , _data_precision( 0 )
+
+    , _density_unit ( 0 )
+    , _x_density    ( 0 )
+    , _y_density    ( 0 )
+
+    , _pixel_width_mm ( 0.0 )
+    , _pixel_height_mm( 0.0 )
+    {}
+
+    /// The image width.
+    jpeg_image_width::type _width;
+
+    /// The image height.
+    jpeg_image_height::type _height;
+
+    /// The number of channels.
+    jpeg_num_components::type _num_components;
+
+    /// The color space.
+    jpeg_color_space::type _color_space;
+
+    /// The width of channel.
+    /// I believe this number is always 8 in the case libjpeg is built with 8.
+    /// see: http://www.asmail.be/msg0055405033.html
+    jpeg_data_precision::type _data_precision;
+
+    /// Density conversion unit.
+    jpeg_density_unit::type  _density_unit;
+    jpeg_pixel_density::type _x_density;
+    jpeg_pixel_density::type _y_density;
+
+    /// Real-world dimensions
+    double _pixel_width_mm;
+    double _pixel_height_mm;
+};
+
+/// Read settings for jpeg images.
+///
+/// The structure can be used for all read_xxx functions, except read_image_info.
+template<>
+struct image_read_settings< jpeg_tag > : public image_read_settings_base
+{
+    /// Default constructor
+    image_read_settings<jpeg_tag>()
+    : image_read_settings_base()
+    , _dct_method( jpeg_dct_method::default_value )
+    {}
+
+    /// Constructor
+    /// \param top_left   Top left coordinate for reading partial image.
+    /// \param dim        Dimensions for reading partial image.
+    /// \param dct_method Specifies dct method.
+    image_read_settings( const point_t&        top_left
+                       , const point_t&        dim
+                       , jpeg_dct_method::type dct_method = jpeg_dct_method::default_value
+                       )
+    : image_read_settings_base( top_left
+                              , dim
+                              )
+    , _dct_method( dct_method )
+    {}
+
+    /// The dct ( discrete cosine transformation ) method. 
+    jpeg_dct_method::type _dct_method;
+};
+
+/// Write information for jpeg images.
+///
+/// The structure can be used for write_view() function.
+template<>
+struct image_write_info< jpeg_tag >
+{
+    /// Constructor
+    /// \param quality      Defines the jpeg quality.
+    /// \param dct_method   Defines the DCT method.
+    /// \param density_unit Defines the density unit.
+    /// \param x_density    Defines the x density.
+    /// \param y_density    Defines the y density.
+    image_write_info( const jpeg_quality::type    quality        = jpeg_quality::default_value
+                    , const jpeg_dct_method::type dct_method     = jpeg_dct_method::default_value
+                    , const jpeg_density_unit::type density_unit = jpeg_density_unit::default_value
+                    , const jpeg_pixel_density::type x_density   = jpeg_pixel_density::default_value
+                    , const jpeg_pixel_density::type y_density   = jpeg_pixel_density::default_value
+                    )
+    : _quality   ( quality    )
+    , _dct_method( dct_method )
+
+    , _density_unit( density_unit )
+    , _x_density   ( x_density    )
+    , _y_density   ( y_density    )
+    {}
+
+    /// The jpeg quality.
+    jpeg_quality::type _quality;
+
+    /// The dct ( discrete cosine transformation ) method. 
+    jpeg_dct_method::type _dct_method;
+
+    /// Density conversion unit.
+    jpeg_density_unit::type _density_unit;
+
+    /// Pixel density dimensions.
+    jpeg_pixel_density::type _x_density;
+    jpeg_pixel_density::type _y_density;
+
+    /// Sets the pixel dimensions.
+    void set_pixel_dimensions( int    image_width   // in pixels
+                             , int    image_height  // in pixels
+                             , double pixel_width   // in mm
+                             , double pixel_height  // in mm
+                             )
+    {
+        _density_unit = 2; // dots per cm
+
+        _x_density = round( image_width  / ( pixel_width  / 10 ));
+        _y_density = round( image_height / ( pixel_height / 10 ));
+    }
+
+private:
+
+    UINT16 round( double d )
+    {
+        return static_cast< UINT16 >( d + 0.5 );
+    }
+
+};
+
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_TAGS_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/jpeg_write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/jpeg_write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_JPEG_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "jpeg_tags.hpp"
+#include "formats/jpeg/supported_types.hpp"
+#include "formats/jpeg/write.hpp"
+
+#include "detail/make_writer.hpp"
+#include "detail/make_dynamic_image_writer.hpp"
+
+#include "detail/write_view.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_JPEG_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/png_all.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/png_all.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,25 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_ALL_HPP
+#define BOOST_GIL_EXTENSION_IO_PNG_ALL_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "png_read.hpp"
+#include "png_write.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_PNG_ALL_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/png_io_old.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/png_io_old.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,179 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_IO_OLD_HPP
+#define BOOST_GIL_EXTENSION_IO_PNG_IO_OLD_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "png_all.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup PNG_IO
+/// \brief Returns the width and height of the PNG file at the specified location.
+/// Throws std::ios_base::failure if the location does not correspond to a valid PNG file
+template< typename String >
+inline
+point2< std::ptrdiff_t > png_read_dimensions( const String& filename )
+{
+    typedef typename get_reader_backend< String
+                                       , png_tag
+                                       >::type backend_t;
+
+    backend_t backend = read_image_info( filename
+                                       , png_tag()
+                                       );
+
+    return point2< std::ptrdiff_t >( backend._info._width
+                                   , backend._info._height
+                                   );
+}
+
+/// \ingroup PNG_IO
+/// \brief Loads the image specified by the given png image file name into the given view.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the PNG library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid PNG file, or if its color space or channel depth are not 
+/// compatible with the ones specified by View, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline 
+void png_read_view( const String& filename
+                   , const View&   view
+                   )
+{
+    read_view( filename
+             , view
+             , png_tag()
+             );
+}
+
+/// \ingroup PNG_IO
+/// \brief Allocates a new image whose dimensions are determined by the given png image file, and loads the pixels into it.
+/// Triggers a compile assert if the image color space or channel depth are not supported by the PNG library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid PNG file, or if its color space or channel depth are not 
+/// compatible with the ones specified by Image
+template< typename String
+        , typename Image
+        >
+inline 
+void png_read_image( const String& filename
+                   , Image&        img
+                   )
+{
+    read_image( filename
+              , img
+              , png_tag()
+              );
+}
+
+/// \ingroup PNG_IO
+/// \brief Loads the image specified by the given png image file name and color-converts it into the given view.
+/// Throws std::ios_base::failure if the file is not a valid PNG file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        , typename CC
+        >
+inline 
+void png_read_and_convert_view( const String& filename
+                               , const View&   view
+                               , CC            cc
+                               )
+{
+    read_and_convert_view( filename
+                         , view
+                         , cc
+                         , png_tag()
+                         );
+}
+
+/// \ingroup PNG_IO
+/// \brief Loads the image specified by the given png image file name and color-converts it into the given view.
+/// Throws std::ios_base::failure if the file is not a valid PNG file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline 
+void png_read_and_convert_view( const String& filename
+                               , const View&   view
+                               )
+{
+    read_and_convert_view( filename
+                         , view
+                         , png_tag()
+                         );
+}
+
+/// \ingroup PNG_IO
+/// \brief Allocates a new image whose dimensions are determined by the given png image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid PNG file
+template< typename String
+        , typename Image
+        , typename CC
+        >
+inline 
+void png_read_and_convert_image( const String& filename
+                                , Image& img
+                                , CC     cc
+                                )
+{
+    read_and_convert_image( filename
+                          , img
+                          , cc
+                          , png_tag()
+                          );
+}
+
+/// \ingroup PNG_IO
+/// \brief Allocates a new image whose dimensions are determined by the given png image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid PNG file
+template< typename String
+        , typename Image
+        >
+inline 
+void png_read_and_convert_image( const String filename
+                                , Image&       img
+                                )
+{
+    read_and_convert_image( filename
+                          , img
+                          , png_tag()
+                          );
+}
+
+/// \ingroup PNG_IO
+/// \brief Saves the view to a png file specified by the given png image file name.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the PNG library or by the I/O extension.
+/// Throws std::ios_base::failure if it fails to create the file.
+template< typename String
+        , typename View
+        >
+inline
+void png_write_view( const String& filename
+                    , const View&   view
+                    )
+{
+    write_view( filename
+              , view
+              , png_tag()
+              );
+}
+
+}  // namespace gil
+}  // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNG_IO_OLD_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/png_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/png_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,43 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_PNG_READ_HPP
+
+#define BOOST_GIL_EXTENSION_IO_PNG_READ_ENABLED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "png_tags.hpp"
+#include "formats/png/supported_types.hpp"
+#include "formats/png/read.hpp"
+#include "formats/png/scanline_read.hpp"
+
+#include "detail/get_reader.hpp"
+#include "detail/make_backend.hpp"
+#include "detail/make_reader.hpp"
+#include "detail/make_dynamic_image_reader.hpp"
+#include "detail/make_scanline_reader.hpp"
+
+#include "detail/read_image.hpp"
+#include "detail/read_view.hpp"
+#include "detail/read_image_info.hpp"
+#include "detail/read_and_convert_image.hpp"
+#include "detail/read_and_convert_view.hpp"
+
+#include "detail/image_read_iterator.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_PNG_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/png_tags.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/png_tags.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,642 @@
+/*
+    Copyright 2007-2008 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_TAGS_HPP
+#define BOOST_GIL_EXTENSION_IO_PNG_TAGS_HPP 
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+// taken from jpegxx - https://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/ijg_headers.hpp
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_C_LIB_COMPILED_AS_CPLUSPLUS
+    extern "C" {
+#else
+    // DONT_USE_EXTERN_C introduced in v7 of the IJG library.
+    // By default the v7 IJG headers check for __cplusplus being defined and
+    // wrap the content in an 'extern "C"' block if it's present.
+    // When DONT_USE_EXTERN_C is defined, this wrapping is not performed.
+    #ifndef DONT_USE_EXTERN_C
+        #define DONT_USE_EXTERN_C 1
+    #endif
+#endif
+
+#include <png.h>
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_C_LIB_COMPILED_AS_CPLUSPLUS
+    }
+#endif
+
+#include <string>
+#include <vector>
+
+#include "detail/base.hpp"
+
+namespace boost { namespace gil {
+
+/// Defines png tag.
+struct png_tag : format_tag {};
+
+/// see http://en.wikipedia.org/wiki/Portable_Network_Graphics for reference
+
+/// Defines type for image width property.
+struct png_image_width : property_base< png_uint_32 > {};
+
+/// Defines type for image height property.
+struct png_image_height : property_base< png_uint_32 > {};
+
+/// Defines type for interlace method property.
+struct png_interlace_method : property_base< int > {};
+
+/// Defines type for compression method property.
+struct png_compression_method : property_base< int > {};
+
+/// Defines type for filter method property.
+struct png_filter_method : property_base< int > {};
+
+/// Defines type for bit depth method property.
+struct png_bitdepth : property_base< int > {};
+
+/// Defines type for bit depth method property.
+struct png_color_type : property_base< int > {};
+
+/// Defines type for number of channels property.
+struct png_num_channels : property_base< png_byte > {};
+
+#ifdef BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+
+    /// Defines type for CIE chromacities property.
+    struct png_chromacities_type : property_base< double > {};
+
+    /// Defines type for gamma correction property.
+    struct png_gamma : property_base< double > {};
+
+    /// Defines type for physical scale unit property.
+    struct png_unit  : property_base< int > {};
+
+    /// Defines type for physical scale property.
+    struct png_scale : property_base< double > {};
+
+#else 
+    /// Defines type for CIE chromacities property.
+    struct png_chromacities_type : property_base< png_fixed_point > {};
+
+    /// Defines type for gamma correction property.
+    struct png_gamma : property_base< png_fixed_point > {};
+
+    /// Defines type for physical scale unit property.
+    struct png_unit  : property_base< int > {};
+
+    /// Defines type for physical scale property.
+    struct png_scale : property_base< std::string > {};
+
+#endif // BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+
+/// Returns image resolution in pixels per meter, from pHYs chunk data.
+struct png_pixels_per_meter : property_base< png_uint_32 > {};
+
+/// Defines type for ICC profile name property.
+struct png_ICC_name             : property_base< std::string > {};
+/// Defines type for ICC profile property.
+struct png_ICC_profile          : property_base< std::string > {};
+/// Defines type for ICC profile length property.
+struct png_ICC_profile_length   : property_base< png_uint_32 > {};
+/// Defines type for ICC compression property.
+struct png_ICC_compression_type : property_base< int         > {};
+
+/// Defines type for rendering intent property.
+struct png_intent : property_base< int > {};
+
+/// Defines type for color palette property.
+struct png_color_palette : property_base< std::vector< png_color > > {};
+/// Defines type for number of colors property.
+struct png_num_palette   : property_base< int > {};
+
+/// Defines type for background property.
+struct png_background : property_base< png_color_16 > {};
+
+/// Defines type for histogram property.
+struct png_histrogram : property_base< std::vector< png_uint_16 > > {};
+
+/// Defines type for screen offset property.
+struct png_offset      : property_base< png_int_32 > {};
+/// Defines type for screen offset type property.
+struct png_offset_type : property_base< int > {};
+
+/// Defines type pixel calibration for property.
+struct png_CAL        : property_base< std::string > {};
+/// Defines type for pixel calibration parameters property.
+struct png_CAL_params : property_base< std::vector< std::string > > {};
+/// Defines type for pixel calibration x property.
+struct png_CAL_X      : property_base< png_int_32 > {};
+/// Defines type for pixel calibration type property.
+struct png_CAL_type   : property_base< int > {};
+/// Defines type for number of pixel calibration properties.
+struct png_CAL_nparam : property_base< int > {};
+
+/// Defines type for physical resolution property.
+struct png_resolution : property_base< png_uint_32 > {};
+/// Defines type for physical resolution unit property.
+struct png_unit_type  : property_base< int > {};
+
+/// Defines type for significant bits property.
+struct png_significant_bits : property_base< png_color_8 > {};
+
+/// Helper structure for reading text property.
+struct gil_io_png_text
+{
+    /// Compression type
+    int         _compression;
+    // Key
+    std::string _key;
+    /// Text
+    std::string _text;
+};
+
+/// Defines type for text property.
+struct png_text_    : property_base< std::vector< gil_io_png_text > > {};
+/// Defines type for number of text property.
+struct png_num_text : property_base< int > {};
+
+/// Defines type for modification time property.
+struct png_mod_time : property_base< png_time > {};
+
+/// Defines type for transparency data property.
+struct png_trans        : property_base< std::vector< png_byte > > {};
+/// Defines type for number of transparency data property.
+struct png_num_trans    : property_base< int > {};
+/// Defines type for transparency data values property.
+struct png_trans_values : property_base< std::vector< png_color_16 > > {};
+
+/// Defines type for png function return type.
+struct png_return_value : property_base< png_uint_32 > {};
+
+/// PNG info base class. Containing all header information both for reading and writing.
+///
+/// This base structure was created to avoid code doubling.
+struct png_info_base
+{
+    /// Default constructor
+    png_info_base()
+    : _width ( 0 )
+    , _height( 0 )
+
+    , _bit_depth         ( 0                            )
+    , _color_type        ( 0                            )
+    , _interlace_method  ( PNG_INTERLACE_NONE           )
+    , _compression_method( PNG_COMPRESSION_TYPE_DEFAULT )
+    , _filter_method     ( PNG_FILTER_TYPE_DEFAULT      )
+
+    , _num_channels( 0 )
+
+#ifdef BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+    , _valid_cie_colors( 0   )
+    , _white_x         ( 0.0 )
+    , _white_y         ( 0.0 )
+    , _red_x           ( 0.0 )
+    , _red_y           ( 0.0 )
+    , _green_x         ( 0.0 )
+    , _green_y         ( 0.0 )
+    , _blue_x          ( 0.0 )
+    , _blue_y          ( 0.0 )
+
+    , _valid_file_gamma( 0   )
+    , _file_gamma      ( 1.0 )
+#else 
+    , _valid_cie_colors( 0 )
+    , _white_x         ( 0 )
+    , _white_y         ( 0 )
+    , _red_x           ( 0 )
+    , _red_y           ( 0 )
+    , _green_x         ( 0 )
+    , _green_y         ( 0 )
+    , _blue_x          ( 0 )
+    , _blue_y          ( 0 )
+
+    , _valid_file_gamma( 0 )
+    , _file_gamma      ( 1 )
+#endif // BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+
+    , _valid_icc_profile    ( 0                         )
+    , _icc_name             (                           )
+    , _iccp_compression_type( PNG_COMPRESSION_TYPE_BASE )
+    , _profile              (                           )
+    , _profile_length       ( 0                         )
+
+    , _valid_intent( 0 )
+    , _intent      ( 0 )
+
+    , _valid_palette( 0 )
+    , _palette      (   )
+    , _num_palette  ( 0 )
+
+    , _valid_background( 0 )
+    , _background      (   )
+
+    , _valid_histogram( 0 )
+    , _histogram      (   )
+
+    , _valid_offset ( 0                )
+    , _offset_x     ( 0                )
+    , _offset_y     ( 0                )
+    , _off_unit_type( PNG_OFFSET_PIXEL )
+
+    , _valid_pixel_calibration( 0 )
+    , _purpose                (   )
+    , _X0                     ( 0 )
+    , _X1                     ( 0 )
+    , _cal_type               ( 0 )
+    , _num_params             ( 0 )
+    , _units                  (   )
+    , _params                 (   )
+
+    , _valid_resolution( 0                      )
+    , _res_x           ( 0                      )
+    , _res_y           ( 0                      )
+    , _phy_unit_type   ( PNG_RESOLUTION_UNKNOWN )
+
+    , _pixels_per_meter( 0 )
+
+    , _valid_significant_bits( 0 )
+    , _sig_bits              (   )
+
+    , _valid_scale_factors( 0                 )
+    , _scale_unit         ( PNG_SCALE_UNKNOWN )
+#ifdef BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+    , _scale_width ( 0.0 )
+    , _scale_height( 0.0 )
+#else
+    , _scale_width ()
+    , _scale_height()
+#endif // BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+
+    , _valid_text( 0 )
+    , _text      (   )
+    , _num_text  ( 0 )
+
+    , _valid_modification_time( 0 )
+    , _mod_time               (   )
+
+    , _valid_transparency_factors( 0 )
+    , _trans                     (   )
+    , _num_trans                 ( 0 )
+    , _trans_values              (   )
+    {}
+
+    /// The image width.
+    png_image_width::type  _width;
+    /// The image height.
+    png_image_height::type _height;
+
+    /// The bit depth per channel.
+    png_bitdepth::type           _bit_depth;
+    /// The color space type.
+    png_color_type::type         _color_type;
+    /// The interlace methos.
+    png_interlace_method::type   _interlace_method;
+    /// The compression method.
+    png_compression_method::type _compression_method;
+    /// The filer method.
+    png_filter_method::type      _filter_method;
+
+    /// The number of channels.
+    png_num_channels::type _num_channels;
+
+    // CIE chromacities
+    /// The return value when reading CIE chromacities.
+    png_return_value::type      _valid_cie_colors;
+    /// The white x value.
+    png_chromacities_type::type _white_x;
+    /// The white y value.
+    png_chromacities_type::type _white_y;
+    /// The red x value.
+    png_chromacities_type::type _red_x;
+    /// The red y value.
+    png_chromacities_type::type _red_y;
+    /// The green x value.
+    png_chromacities_type::type _green_x;
+    /// The green y value.
+    png_chromacities_type::type _green_y;
+    /// The blue x value.
+    png_chromacities_type::type _blue_x;
+    /// The blue y value.
+    png_chromacities_type::type _blue_y;
+
+    // Gamma Value
+    /// The return value when reading gamma value.
+    png_return_value::type _valid_file_gamma;
+    /// The file gamma value.
+    png_gamma::type        _file_gamma;
+
+    // Embedded ICC profile
+    /// The return value when reading ICC profile.
+    png_return_value::type         _valid_icc_profile;
+    /// The ICC name.
+    png_ICC_name::type             _icc_name;
+    /// The icc compression type.
+    png_ICC_compression_type::type _iccp_compression_type;
+    /// The ICC profile.
+    png_ICC_profile::type          _profile;
+    /// The ICC profile length.
+    png_ICC_profile_length::type   _profile_length;
+
+    // Rendering intent
+    /// The return value when reading rendering intent.
+    png_return_value::type _valid_intent;
+    /// The rendering intent value.
+    png_intent::type       _intent;
+
+    // Image palette
+    /// The return value when reading image palette.
+    png_return_value::type  _valid_palette;
+    /// The color palette.
+    png_color_palette::type _palette;
+    /// The number of colors in the palettes.
+    png_num_palette::type   _num_palette;
+
+    // Background
+    /// The return value when reading background.
+    png_return_value::type _valid_background;
+    /// The background color.
+    png_background::type   _background;
+
+    // Histogram
+    /// The return value when reading histogram.
+    png_return_value::type _valid_histogram;
+    /// The histogram.
+    png_histrogram::type   _histogram;
+
+    // Screen offsets
+    /// The return value when reading screen offsets.
+    png_return_value::type _valid_offset;
+    /// The x offset.
+    png_offset::type       _offset_x;
+    /// The y offset.
+    png_offset::type       _offset_y;
+    /// The offset unit.
+    png_offset_type::type  _off_unit_type;
+
+    // Pixel Calibration
+    /// The return value when reading pixel calibration.
+    png_return_value::type _valid_pixel_calibration;
+    /// The purpose.
+    png_CAL::type          _purpose;
+    /// The x_0 value.
+    png_CAL_X::type        _X0;
+    /// The x_1 value.
+    png_CAL_X::type        _X1;
+    /// The calibration type.
+    png_CAL_type::type     _cal_type;
+    /// The number of calibration parameters.
+    png_CAL_nparam::type   _num_params;
+    /// The calibration unit type.
+    png_CAL::type          _units;
+    /// The calibration parameters.
+    png_CAL_params::type   _params;
+
+    // Physical resolution
+    /// The return value when reading physical resolution properties.
+    png_return_value::type _valid_resolution;
+    /// The x physical resolution.
+    png_resolution::type   _res_x;
+    /// The y physical resolution.
+    png_resolution::type   _res_y;
+    /// The physical resolution unit.
+    png_unit_type::type    _phy_unit_type;
+
+    /// The Image resolution in pixels per meter.
+    png_pixels_per_meter::type _pixels_per_meter;
+
+    // Number of significant bits
+    /// The return value when reading significant bits.
+    png_return_value::type     _valid_significant_bits;
+    /// The significant bits.
+    png_significant_bits::type _sig_bits;
+
+    // Scale Factors
+    /// The return value when reading scale factors.
+    png_return_value::type _valid_scale_factors;
+    /// The scaling unit.
+    png_unit::type         _scale_unit;
+    /// The scaling width.
+    png_scale::type        _scale_width;
+    /// The scaling height.
+    png_scale::type        _scale_height;
+
+    // Comments information
+    /// The return value when reading image comments.
+    png_return_value::type _valid_text;
+    /// The comments.
+    png_text_::type        _text;
+    /// The number of comments.
+    png_num_text::type     _num_text;
+
+    // Last modification time
+    /// The return value when reading modification time.
+    png_return_value::type _valid_modification_time;
+    /// The modification time.
+    png_mod_time::type     _mod_time;
+
+    // Transparency data
+    /// The return value when reading transparency data.
+    png_return_value::type _valid_transparency_factors;
+    /// The transparency data.
+    png_trans::type        _trans;
+    /// The number of transparency data.
+    png_num_trans::type    _num_trans;
+    /// The transparency data values.
+    png_trans_values::type _trans_values;
+};
+
+/// Read information for png images.
+///
+/// The structure is returned when using read_image_info.
+template<>
+struct image_read_info< png_tag > : public png_info_base
+{
+    /// Default constructor.
+    image_read_info< png_tag >()
+    : png_info_base()
+    {}
+};
+
+/// PNG settings base class.
+///
+/// This base structure was created to avoid code doubling.
+struct png_read_settings_base
+{
+    /// Default Constructor.
+    png_read_settings_base()
+    {
+        _read_cie_chromacities           = false;
+        _read_file_gamma                 = false;
+        _read_icc_profile                = false;
+        _read_intent                     = false;
+        _read_palette                    = false;
+        _read_background                 = false;
+        _read_histogram                  = false;
+        _read_screen_offsets             = false;
+        _read_pixel_calibration          = false;
+        _read_physical_resolution        = false;
+        _read_pixels_per_meter           = false;
+        _read_number_of_significant_bits = false;
+        _read_scale_factors              = false;
+        _read_comments                   = false;
+        _read_last_modification_time     = false;
+        _read_transparency_data          = false;
+    }
+
+    /// Helper function to enabling reading all png properties.
+    void set_read_members_true()
+    {
+        _read_cie_chromacities           = true;
+        _read_file_gamma                 = true;
+        _read_icc_profile                = true;
+        _read_intent                     = true;
+        _read_palette                    = true;
+        _read_background                 = true;
+        _read_histogram                  = true;
+        _read_screen_offsets             = true;
+        _read_pixel_calibration          = true;
+        _read_physical_resolution        = true;
+        _read_pixels_per_meter           = true;
+        _read_number_of_significant_bits = true;
+        _read_scale_factors              = true;
+        _read_comments                   = true;
+        _read_last_modification_time     = true;
+        _read_transparency_data          = true;
+    }
+
+    /// Enable reading CIE chromacities.
+    bool _read_cie_chromacities;
+    /// Enable reading file gamma.
+    bool _read_file_gamma;
+    /// Enable reading ICC profile.
+    bool _read_icc_profile;
+    /// Enable reading rendering intent.
+    bool _read_intent;
+    /// Enable reading color palette.
+    bool _read_palette;
+    /// Enable reading background color.
+    bool _read_background;
+    /// Enable reading histogram.
+    bool _read_histogram;
+    /// Enable reading screen offsets.
+    bool _read_screen_offsets;
+    /// Enable reading pixel calibration.
+    bool _read_pixel_calibration;
+    /// Enable reading physical resolution.
+    bool _read_physical_resolution;
+    /// Enable reading pixels per meter information.
+    bool _read_pixels_per_meter;
+    /// Enable reading significant bits.
+    bool _read_number_of_significant_bits;
+    /// Enable reading scaling factors.
+    bool _read_scale_factors;
+    /// Enable reading comments.
+    bool _read_comments;
+    /// Enable reading modification time.
+    bool _read_last_modification_time;
+    /// Enable reading transparency data.
+    bool _read_transparency_data;
+};
+
+#ifdef BOOST_GIL_IO_PNG_FLOATING_POINT_SUPPORTED
+
+/// Read settings for png images.
+///
+/// The structure can be used for all read_xxx functions, except read_image_info.
+template<>
+struct image_read_settings< png_tag > : public image_read_settings_base
+                                      , public png_read_settings_base
+{
+    /// Default Constructor
+    image_read_settings< png_tag >()
+    : image_read_settings_base()
+    , png_read_settings_base()
+    , _screen_gamma( 1.0 )
+    {}
+
+    /// Constructor
+    /// \param top_left Top left coordinate for reading partial image.
+    /// \param dim      Dimensions for reading partial image.
+    /// \param gamma    Screen gamma value.
+    image_read_settings( const point_t& top_left
+                       , const point_t& dim
+                       , double         gamma = 1.0
+                       )
+    : image_read_settings_base( top_left
+                              , dim
+                              )
+    , png_read_settings_base()
+    , _apply_screen_gamma( false )
+    , _screen_gamma( screen_gamma )
+    {}
+
+    /// Apply screen gamma value.
+    bool            _apply_screen_gamma;
+    /// The screen gamma value.
+    png_gamma::type _screen_gamma;
+};
+
+#else
+
+/// Read settings for png images.
+///
+/// The structure can be used for all read_xxx functions, except read_image_info.
+template<>
+struct image_read_settings< png_tag > : public image_read_settings_base
+                                      , public png_read_settings_base
+{
+    /// Default Constructor.
+    image_read_settings< png_tag >()
+    : image_read_settings_base()
+    , png_read_settings_base()
+    , _apply_screen_gamma( false )
+    , _screen_gamma      ( 2     )
+    {}
+
+    image_read_settings( const point_t& top_left
+                       , const point_t& dim
+                       )
+    : image_read_settings_base( top_left
+                              , dim
+                              )
+    , png_read_settings_base()
+    , _apply_screen_gamma( false )
+    , _screen_gamma      ( 2     )
+    {}
+
+    /// Apply screen gamma value.
+    bool            _apply_screen_gamma;
+    /// The screen gamma value.
+    png_gamma::type _screen_gamma;
+};
+#endif
+
+/// Write information for png images.
+///
+/// The structure can be used for write_view() function.
+template<>
+struct image_write_info< png_tag >  : public png_info_base
+{
+    image_write_info()
+    : png_info_base()
+    {}
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNG_TAGS_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/png_write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/png_write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNG_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_PNG_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "png_tags.hpp"
+#include "formats/png/supported_types.hpp"
+#include "formats/png/write.hpp"
+
+#include "detail/make_writer.hpp"
+#include "detail/make_dynamic_image_writer.hpp"
+
+#include "detail/write_view.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_PNG_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/pnm_all.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/pnm_all.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,25 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_ALL_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_ALL_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "pnm_read.hpp"
+#include "pnm_write.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_PNM_ALL_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/pnm_io_old.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/pnm_io_old.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,181 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_IO_OLD_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_IO_OLD_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "pnm_all.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup PNM_IO
+/// \brief Returns the width and height of the PNM file at the specified location.
+/// Throws std::ios_base::failure if the location does not correspond to a valid PNM file
+template< typename String >
+inline
+point2< std::ptrdiff_t > pnm_read_dimensions( const String& filename )
+{
+    typedef typename get_reader_backend< String
+                                       , pnm_tag
+                                       >::type backend_t;
+
+    backend_t backend = read_image_info( filename
+                                       , pnm_tag()
+                                       );
+
+    return point2< std::ptrdiff_t >( backend._info._width
+                                   , backend._info._height
+                                   );
+}
+
+
+/// \ingroup PNM_IO
+/// \brief Loads the image specified by the given pnm image file name into the given view.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the PNM library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid PNM file, or if its color space or channel depth are not 
+/// compatible with the ones specified by View, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline 
+void pnm_read_view( const String& filename
+                  , const View&   view
+                  )
+{
+    read_view( filename
+             , view
+             , pnm_tag()
+             );
+}
+
+/// \ingroup PNM_IO
+/// \brief Allocates a new image whose dimensions are determined by the given pnm image file, and loads the pixels into it.
+/// Triggers a compile assert if the image color space or channel depth are not supported by the PNM library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid PNM file, or if its color space or channel depth are not 
+/// compatible with the ones specified by Image
+template< typename String
+        , typename Image
+        >
+inline 
+void pnm_read_image( const String& filename
+                   , Image&        img
+                   )
+{
+    read_image( filename
+              , img
+              , pnm_tag()
+              );
+}
+
+/// \ingroup PNM_IO
+/// \brief Loads and color-converts the image specified by the given pnm image file name into the given view.
+/// Throws std::ios_base::failure if the file is not a valid PNM file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        , typename CC
+        >
+inline 
+void pnm_read_and_convert_view( const String& filename
+                              , const View&   view
+                              , CC            cc
+                              )
+{
+    read_and_convert_view( filename
+                         , view
+                         , cc
+                         , pnm_tag()
+                         );
+}
+
+/// \ingroup PNM_IO
+/// \brief Loads and color-converts the image specified by the given pnm image file name into the given view.
+/// Throws std::ios_base::failure if the file is not a valid PNM file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline 
+void pnm_read_and_convert_view( const String& filename
+                              , const View&   view
+                              )
+{
+    read_and_convert_view( filename
+                         , view
+                         , pnm_tag()
+                         );
+}
+
+/// \ingroup PNM_IO
+/// \brief Allocates a new image whose dimensions are determined by the given pnm image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid PNM file
+template< typename String
+        , typename Image
+        , typename CC
+        >
+inline 
+void pnm_read_and_convert_image( const String& filename
+                               , Image& img
+                               , CC     cc
+                               )
+{
+    read_and_convert_image( filename
+                          , img
+                          , cc
+                          , pnm_tag()
+                          );
+}
+
+/// \ingroup PNM_IO
+/// \brief Allocates a new image whose dimensions are determined by the given pnm image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid PNM file
+template< typename String
+        , typename Image
+        >
+inline 
+void pnm_read_and_convert_image( const String filename
+                               , Image&       img
+                               )
+{
+    read_and_convert_image( filename
+                          , img
+                          , pnm_tag()
+                          );
+}
+
+
+/// \ingroup PNM_IO
+/// \brief Saves the view to a pnm file specified by the given pnm image file name.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the PNM library or by the I/O extension.
+/// Throws std::ios_base::failure if it fails to create the file.
+template< typename String
+        , typename View
+        >
+inline
+void pnm_write_view( const String& filename
+                   , const View&   view
+                   )
+{
+    write_view( filename
+              , view
+              , pnm_tag()
+              );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNM_IO_OLD_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/pnm_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/pnm_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "pnm_tags.hpp"
+#include "formats/pnm/supported_types.hpp"
+#include "formats/pnm/read.hpp"
+#include "formats/pnm/scanline_read.hpp"
+
+#include "detail/get_reader.hpp"
+#include "detail/make_backend.hpp"
+#include "detail/make_reader.hpp"
+#include "detail/make_dynamic_image_reader.hpp"
+#include "detail/make_scanline_reader.hpp"
+
+#include "detail/read_image.hpp"
+#include "detail/read_view.hpp"
+#include "detail/read_image_info.hpp"
+#include "detail/read_and_convert_image.hpp"
+#include "detail/read_and_convert_view.hpp"
+
+#include "detail/image_read_iterator.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_PNM_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/pnm_tags.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/pnm_tags.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,106 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_TAGS_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_TAGS_HPP
+
+#define BOOST_GIL_EXTENSION_IO_PNM_READ_ENABLED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief 
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/mpl/integral_c.hpp>
+
+#include "detail/base.hpp"
+
+namespace boost { namespace gil {
+
+/// Defines pnm tag.
+struct pnm_tag : format_tag {};
+
+/// see http://en.wikipedia.org/wiki/Portable_Bitmap_File_Format for reference
+
+/// Defines type for image type property.
+struct pnm_image_type : property_base< uint32_t >
+{
+    typedef boost::mpl::integral_c< type, 1 > mono_asc_t;
+    typedef boost::mpl::integral_c< type, 2 > gray_asc_t;
+    typedef boost::mpl::integral_c< type, 3 > color_asc_t;
+
+    typedef boost::mpl::integral_c< type, 4 > mono_bin_t;
+    typedef boost::mpl::integral_c< type, 5 > gray_bin_t;
+    typedef boost::mpl::integral_c< type, 6 > color_bin_t;
+};
+
+/// Defines type for image width property.
+struct pnm_image_width : property_base< uint32_t > {};
+
+/// Defines type for image height property.
+struct pnm_image_height : property_base< uint32_t > {};
+
+/// Defines type for image max value property.
+struct pnm_image_max_value : property_base< uint32_t > {};
+
+/// Read information for pnm images.
+///
+/// The structure is returned when using read_image_info.
+template<>
+struct image_read_info< pnm_tag >
+{
+    /// The image type.
+    pnm_image_type::type      _type;
+    /// The image width.
+    pnm_image_width::type     _width;
+    /// The image height.
+    pnm_image_height::type    _height;
+    /// The image max value.
+    pnm_image_max_value::type _max_value;
+};
+
+/// Read settings for pnm images.
+///
+/// The structure can be used for all read_xxx functions, except read_image_info.
+template<>
+struct image_read_settings< pnm_tag > : public image_read_settings_base
+{
+    /// Default constructor
+    image_read_settings< pnm_tag >()
+    : image_read_settings_base()
+    {}
+
+    /// Constructor
+    /// \param top_left   Top left coordinate for reading partial image.
+    /// \param dim        Dimensions for reading partial image.
+    image_read_settings( const point_t& top_left
+                       , const point_t& dim
+                       )
+    : image_read_settings_base( top_left
+                              , dim
+                              )
+    {}
+};
+
+/// Write information for pnm images.
+///
+/// The structure can be used for write_view() function.
+template<>
+struct image_write_info< pnm_tag >
+{
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_PNM_TAGS_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/pnm_write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/pnm_write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_PNM_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_PNM_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "pnm_tags.hpp"
+#include "formats/pnm/supported_types.hpp"
+#include "formats/pnm/write.hpp"
+
+#include "detail/make_writer.hpp"
+#include "detail/make_dynamic_image_writer.hpp"
+
+#include "detail/write_view.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_PNM_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/raw_all.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/raw_all.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,15 @@
+#ifndef BOOST_GIL_EXTENSION_IO_RAW_ALL_HPP
+#define BOOST_GIL_EXTENSION_IO_RAW_ALL_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Olivier tournaire \n
+///
+/// \date   2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "raw_read.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_RAW_ALL_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/raw_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/raw_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,31 @@
+#ifndef BOOST_GIL_EXTENSION_IO_RAW_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_RAW_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief
+/// \author Olivier Tournaire \n
+///
+/// \date   2011 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "raw_tags.hpp"
+#include "formats/raw/supported_types.hpp"
+#include "formats/raw/read.hpp"
+
+#include "detail/get_reader.hpp"
+#include "detail/make_backend.hpp"
+#include "detail/make_reader.hpp"
+#include "detail/make_dynamic_image_reader.hpp"
+#include "detail/make_scanline_reader.hpp"
+
+#include "detail/read_image_info.hpp"
+#include "detail/read_view.hpp"
+#include "detail/read_image.hpp"
+#include "detail/read_and_convert_image.hpp"
+#include "detail/read_and_convert_view.hpp"
+
+#include "detail/image_read_iterator.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_RAW_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/raw_tags.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/raw_tags.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,198 @@
+#ifndef BOOST_GIL_EXTENSION_IO_RAW_TAGS_HPP
+#define BOOST_GIL_EXTENSION_IO_RAW_TAGS_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief All supported raw tags by the gil io extension.
+/// \author Olivier Tournaire \n
+///
+/// \date   2011 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <libraw/libraw.h>
+
+#include "detail/base.hpp"
+
+namespace boost { namespace gil {
+
+/// Defines tiff tag.
+struct raw_tag : format_tag {};
+
+/// Defines type for image width property.
+struct raw_image_width : property_base< int32_t > {};
+
+/// Defines type for image height property.
+struct raw_image_height : property_base< int32_t > {};
+
+/// Defines type for samples per pixel property.
+struct raw_samples_per_pixel : property_base< int32_t > {};
+
+/// Defines type for bits per pixel property.
+struct raw_bits_per_pixel : property_base< int32_t > {};
+
+/// Defines type for camera manufacturer.
+struct raw_camera_manufacturer : property_base< std::string > {};
+
+/// Defines type for camera model.
+struct raw_camera_model : property_base< std::string > {};
+
+/// Defines type for raw images count.
+struct raw_raw_images_count : property_base< unsigned > {};
+
+/// Defines type for dng version.
+struct raw_dng_version : property_base< unsigned > {};
+
+/// Defines type for number of colors.
+struct raw_number_colors : property_base< int32_t > {};
+
+/// Defines type for colors description.
+struct raw_colors_description : property_base< std::string > {};
+
+/// Defines type for raw height.
+struct raw_raw_height : property_base< uint16_t > {};
+
+/// Defines type for raw width.
+struct raw_raw_width : property_base< uint16_t > {};
+
+/// Defines type for visible height.
+struct raw_visible_height : property_base< uint16_t > {};
+
+/// Defines type for visible width.
+struct raw_visible_width : property_base< uint16_t > {};
+
+/// Defines type for top margin.
+struct raw_top_margin : property_base< uint16_t > {};
+
+/// Defines type for left margin.
+struct raw_left_margin : property_base< uint16_t > {};
+
+/// Defines type for output height.
+struct raw_output_height : property_base< uint16_t > {};
+
+/// Defines type for output width.
+struct raw_output_width : property_base< uint16_t > {};
+
+/// Defines type for pixel aspect.
+struct raw_pixel_aspect : property_base< double > {};
+
+/// Defines type for image orientation.
+struct raw_flip : property_base< uint32_t > {};
+
+/// Defines type for iso speed.
+struct raw_iso_speed : property_base< float > {};
+
+/// Defines type for shutter.
+struct raw_shutter : property_base< float > {};
+
+/// Defines type for aperture.
+struct raw_aperture : property_base< float > {};
+
+/// Defines type for focal length.
+struct raw_focal_length : property_base< float > {};
+
+/// Defines type for timestamp.
+struct raw_timestamp : property_base< time_t > {};
+
+/// Defines type for shot order.
+struct raw_shot_order : property_base< uint16_t > {};
+
+/// Defines type for image description.
+struct raw_image_description : property_base< std::string > {};
+
+/// Defines type for artist.
+struct raw_artist : property_base< std::string > {};
+
+/// Defines type for libraw version.
+struct raw_libraw_version : property_base< std::string > {};
+
+/// Defines type for unpack function name.
+struct raw_unpack_function_name : property_base< std::string > {};
+
+/// Read information for raw images.
+///
+/// The structure is returned when using read_image_info.
+template<>
+struct image_read_info< raw_tag >
+{
+    /// Default contructor.
+    image_read_info< raw_tag >()
+    : _valid( false )
+    {}
+
+    // Here, width and height of the image are the ones of the output height (ie after having been processed by dcraw emulator)
+    raw_image_width::type       _width;
+    raw_image_height::type      _height;
+    raw_samples_per_pixel::type _samples_per_pixel;
+    raw_bits_per_pixel::type    _bits_per_pixel;
+
+    raw_camera_manufacturer::type _camera_manufacturer;
+    raw_camera_model::type        _camera_model;
+
+    raw_raw_images_count::type   _raw_images_count;
+    raw_dng_version::type        _dng_version;
+    raw_number_colors::type      _number_colors;
+    raw_colors_description::type _colors_description;
+
+    raw_raw_width::type      _raw_width;
+    raw_raw_height::type     _raw_height;
+    raw_visible_width::type  _visible_width;
+    raw_visible_height::type _visible_height;
+    raw_top_margin::type     _top_margin;
+    raw_left_margin::type    _left_margin;
+    raw_output_width::type   _output_width;
+    raw_output_height::type  _output_height;
+    raw_pixel_aspect::type   _pixel_aspect;
+    raw_flip::type           _flip;
+
+    raw_iso_speed::type         _iso_speed;
+    raw_shutter::type           _shutter;
+    raw_aperture::type          _aperture;
+    raw_focal_length::type      _focal_length;
+    raw_timestamp::type         _timestamp;
+    raw_shot_order::type        _shot_order;
+    raw_image_description::type _image_description;
+    raw_artist::type            _artist;
+
+    raw_libraw_version::type       _libraw_version;
+    raw_unpack_function_name::type _unpack_function_name;
+
+    /// Used internaly to identify if the header has been read.
+    bool _valid;
+};
+
+/// Read settings for raw images.
+///
+/// The structure can be used for all read_xxx functions, except read_image_info.
+template<>
+struct image_read_settings< raw_tag > : public image_read_settings_base
+{
+    /// Default constructor
+    image_read_settings()
+    : image_read_settings_base()
+    {}
+
+    /// Constructor
+    /// \param top_left Top left coordinate for reading partial image.
+    /// \param dim      Dimensions for reading partial image.
+    image_read_settings( const point_t& top_left
+                       , const point_t& dim
+                       )
+    : image_read_settings_base( top_left
+                              , dim
+                              )
+    {}
+};
+
+/// Write information for raw images.
+///
+/// The structure can be used for write_view() function.
+template<>
+struct image_write_info< raw_tag >
+{
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_RAW_TAGS_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/scanline_read_iterator.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/scanline_read_iterator.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,191 @@
+#pragma once
+
+namespace boost { namespace gil {
+
+/// Input iterator to read images.
+template< typename Reader >
+class scanline_read_iterator
+{
+public:
+
+    typedef typename Reader::backend_t backend_t;
+
+    typedef std::input_iterator_tag iterator_category;
+    typedef byte_t* value_type;
+    typedef value_type const* pointer;
+    typedef value_type const& reference;
+    
+    /// todo
+    //typedef ptrdiff_t difference_type;
+
+public:
+
+    /// Default Constructor, usually used to create an end iterator.
+    scanline_read_iterator()
+    : _pos( -1 )
+    , _reader( NULL )
+    , _buffer( NULL )
+    {}
+
+    /// Constructor with preallocated image. Reading starts at first scanline of source image.
+    scanline_read_iterator( Reader&       reader
+                          , const byte_t* buffer
+                          )
+    : _pos( 0 )
+    , _reader( &reader )
+    , _buffer( buffer  )
+    {
+        init();
+    }
+
+    /// Constructor with preallocated image. Reading starts at first scanline of source image.
+    scanline_read_iterator( Reader& reader )
+    : _pos( 0 )
+    , _reader( &reader )
+    , _buffer( NULL )
+    {
+        init();
+    }
+
+    /// Constructor with preallocated image. Reading starts at pos scanline of source image.
+    scanline_read_iterator( std::size_t pos
+                          , Reader&     reader
+                          , byte_t*     buffer
+                          )
+    : _pos( pos )
+    , _reader( &reader )
+    , _buffer( buffer  )
+    {
+        init();
+
+        if( _pos >= _reader._info._height )
+        {
+            std::runtime_error( "Trying to read past image." );
+        }
+
+        if( pos > 0 && _buffer == null )
+        {
+            std::runtime_error( "Cannot proceed without initializing read buffer." );
+        }
+
+        for( std::size_t i = 0; i < pos; ++i )
+        {
+            _skip();
+        }
+    }
+
+    //
+    // Destructor
+    //
+    ~scanline_read_iterator()
+    {
+        if( _reader )
+        {
+            _reader->clean_up();
+        }
+    }
+
+    /// Set reader. Do clean up before if necessary.
+    void set_reader( Reader& reader )
+    {
+        if( _reader )
+        {
+            _reader->clean_up();
+
+            _pos = 0;
+        }
+
+        _reader = &reader;
+
+        init();
+    }
+
+    /// Set reader. Do clean up before if necessary.
+    void set_buffer( byte_t* buffer )
+    {
+        _buffer = buffer;
+    }
+
+
+    /// Dereference Operator
+    reference operator*() const
+    {
+        if( _reader && _buffer )
+        {
+            _reader->read( _buffer, _pos );
+
+            ++_pos;
+
+            return _buffer;
+        }
+
+        throw std::runtime_error( "Reader cannot be null for this operation." );
+    }
+
+    /// Pointer-To-Memper Operator.
+    pointer operator->() const
+    {
+        return &(operator*());
+    }
+
+    /// Pre-Increment Operator
+    scanline_read_iterator< Reader >& operator++()
+    {
+        if( _buffer == NULL )
+        {
+            throw std::runtime_error( "Cannot proceed without initializing read buffer." );
+        }
+
+        _skip();
+
+        return (*this);
+    }
+
+    /// Compare passed iterator to this.
+    bool equal( const scanline_read_iterator< Reader >& rhs ) const
+    {
+        return (_reader == rhs._reader) && ( _buffer == rhs._buffer );
+    }
+
+    /// Return backend.
+    typename const backend_t& backend()
+    {
+        if( _reader )
+        {
+            return *_reader;
+        }
+
+        throw std::runtime_error( "Reader cannot be null for this operation." );
+    }
+
+private:
+
+    void init()
+    {
+        if( _reader )
+        {
+            _reader->read_header();
+            _reader->initialize();
+        }
+    }
+
+    void _skip()
+    {
+        if( _reader )
+        {
+            _reader->skip( _buffer, _pos );
+
+            ++_pos;
+        }
+    }
+
+private:
+
+    mutable int _pos;
+
+    Reader* _reader;
+    byte_t* _buffer;
+};
+
+} // namespace gil
+} // namespace boost
Index: boost-1.52.0/src/boost/gil/extension/io_new/targa_all.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/targa_all.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,25 @@
+/*
+    Copyright 2010 Kenneth Riddile
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TARGA_ALL_HPP
+#define BOOST_GIL_EXTENSION_IO_TARGA_ALL_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Kenneth Riddile \n
+///         
+/// \date   2010 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "targa_read.hpp"
+#include "targa_write.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_TARGA_ALL_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/targa_io_old.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/targa_io_old.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,181 @@
+/*
+    Copyright 2010 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_BMP_IO_OLD_HPP
+#define BOOST_GIL_EXTENSION_IO_BMP_IO_OLD_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2010 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "targa_all.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup BMP_IO
+/// \brief Returns the width and height of the BMP file at the specified location.
+/// Throws std::ios_base::failure if the location does not correspond to a valid BMP file
+template< typename String >
+inline
+point2< std::ptrdiff_t > targa_read_dimensions( const String& filename )
+{
+    typedef typename get_reader_backend< String
+                                       , targa_tag
+                                       >::type backend_t;
+
+    backend_t backend = read_image_info( filename
+                                       , targa_tag()
+                                       );
+
+    return point2< std::ptrdiff_t >( backend._info._width
+                                   , backend._info._height
+                                   );
+}
+
+
+/// \ingroup BMP_IO
+/// \brief Loads the image specified by the given targa image file name into the given view.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the BMP library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid BMP file, or if its color space or channel depth are not 
+/// compatible with the ones specified by View, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline 
+void targa_read_view( const String& filename
+                    , const View&   view
+                    )
+{
+    read_view( filename
+             , view
+             , targa_tag()
+             );
+}
+
+/// \ingroup BMP_IO
+/// \brief Allocates a new image whose dimensions are determined by the given bmp image file, and loads the pixels into it.
+/// Triggers a compile assert if the image color space or channel depth are not supported by the BMP library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid BMP file, or if its color space or channel depth are not 
+/// compatible with the ones specified by Image
+template< typename String
+        , typename Image
+        >
+inline 
+void targa_read_image( const String& filename
+                     , Image&        img
+                     )
+{
+    read_image( filename
+              , img
+              , targa_tag()
+              );
+}
+
+/// \ingroup BMP_IO
+/// \brief Loads and color-converts the image specified by the given targa image file name into the given view.
+/// Throws std::ios_base::failure if the file is not a valid BMP file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        , typename CC
+        >
+inline 
+void targa_read_and_convert_view( const String& filename
+                                , const View&   view
+                                , CC            cc
+                                )
+{
+    read_and_convert_view( filename
+                         , view
+                         , cc
+                         , targa_tag()
+                         );
+}
+
+/// \ingroup BMP_IO
+/// \brief Loads and color-converts the image specified by the given targa image file name into the given view.
+/// Throws std::ios_base::failure if the file is not a valid BMP file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline 
+void targa_read_and_convert_view( const String& filename
+                                , const View&   view
+                                )
+{
+    read_and_convert_view( filename
+                         , view
+                         , targa_tag()
+                         );
+}
+
+/// \ingroup BMP_IO
+/// \brief Allocates a new image whose dimensions are determined by the given targa image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid BMP file
+template< typename String
+        , typename Image
+        , typename CC
+        >
+inline 
+void targa_read_and_convert_image( const String& filename
+                                 , Image&        img
+                                 , CC            cc
+                                 )
+{
+    read_and_convert_image( filename
+                          , img
+                          , cc
+                          , targa_tag()
+                          );
+}
+
+/// \ingroup BMP_IO
+/// \brief Allocates a new image whose dimensions are determined by the given targa image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid BMP file
+template< typename String
+        , typename Image
+        >
+inline 
+void targa_read_and_convert_image( const String filename
+                                 , Image&       img
+                                 )
+{
+    read_and_convert_image( filename
+                          , img
+                          , targa_tag()
+                          );
+}
+
+
+/// \ingroup BMP_IO
+/// \brief Saves the view to a targa file specified by the given targa image file name.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the BMP library or by the I/O extension.
+/// Throws std::ios_base::failure if it fails to create the file.
+template< typename String
+        , typename View
+        >
+inline
+void targa_write_view( const String& filename
+                     , const View&   view
+                     )
+{
+    write_view( filename
+              , view
+              , targa_tag()
+              );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_BMP_IO_OLD_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/targa_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/targa_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+    Copyright 2010-2012 Kenneth Riddile and Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TARGA_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_TARGA_READ_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Kenneth Riddile and Christian Henning \n
+///         
+/// \date   2010-2012 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "targa_tags.hpp"
+#include "formats/targa/supported_types.hpp"
+#include "formats/targa/read.hpp"
+#include "formats/targa/scanline_read.hpp"
+
+#include "detail/get_reader.hpp"
+#include "detail/make_backend.hpp"
+#include "detail/make_reader.hpp"
+#include "detail/make_dynamic_image_reader.hpp"
+#include "detail/make_scanline_reader.hpp"
+
+#include "detail/read_image.hpp"
+#include "detail/read_view.hpp"
+#include "detail/read_image_info.hpp"
+#include "detail/read_and_convert_image.hpp"
+#include "detail/read_and_convert_view.hpp"
+
+#include "detail/image_read_iterator.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_TARGA_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/targa_tags.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/targa_tags.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,170 @@
+/*
+    Copyright 2010 Kenneth Riddile
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TARGA_TAGS_HPP 
+#define BOOST_GIL_EXTENSION_IO_TARGA_TAGS_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief 
+/// \author Kenneth Riddile \n
+///         
+/// \date 2010 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "detail/base.hpp"
+
+namespace boost { namespace gil {
+
+/// Defines targa tag.
+struct targa_tag : format_tag {};
+
+/// See http://en.wikipedia.org/wiki/Truevision_TGA#Header for reference.
+/// http://local.wasp.uwa.edu.au/~pbourke/dataformats/tga/
+
+
+/// Defines type for header sizes.
+struct targa_header_size : property_base< uint8_t >
+{
+    static const type _size = 18; /// Constant size for targa file header size.
+};
+
+/// Defines type for offset value.
+struct targa_offset : property_base< uint8_t > {};
+
+/// Defines type for color map type property.
+struct targa_color_map_type : property_base< uint8_t >
+{
+    static const type _rgb = 0;
+    static const type _indexed = 1;
+};
+
+/// Defines type for image type property.
+struct targa_image_type : property_base< uint8_t >
+{
+    static const type _none          = 0;  /// no image data
+    static const type _indexed       = 1;  /// indexed
+    static const type _rgb           = 2;  /// RGB
+    static const type _greyscale     = 3;  /// greyscale
+    static const type _rle_indexed   = 9;  /// indexed with RLE compression
+    static const type _rle_rgb       = 10; /// RGB with RLE compression
+    static const type _rle_greyscale = 11; /// greyscale with RLE compression
+};
+
+/// Defines type for color map start property.
+struct targa_color_map_start : property_base< uint16_t > {};
+
+/// Defines type for color map length property.
+struct targa_color_map_length : property_base< uint16_t > {};
+
+/// Defines type for color map bit depth property.
+struct targa_color_map_depth : property_base< uint8_t > {};
+
+/// Defines type for origin x and y value properties.
+struct targa_origin_element : property_base< uint16_t > {};
+
+/// Defines type for image dimension properties.
+struct targa_dimension : property_base< uint16_t > {};
+
+/// Defines type for image bit depth property.
+struct targa_depth : property_base< uint8_t > {};
+
+/// Defines type for image descriptor property.
+struct targa_descriptor : property_base< uint8_t > {};
+
+/// Read information for targa images.
+///
+/// The structure is returned when using read_image_info.
+template<>
+struct image_read_info< targa_tag >
+{
+    /// Default contructor.
+    image_read_info< targa_tag >()
+    : _valid( false )
+    {}
+
+    /// The size of this header:
+    targa_header_size::type _header_size;
+    
+    /// The offset, i.e. starting address, of the byte where the targa data can be found.
+    targa_offset::type _offset;
+    
+    /// The type of color map used by the image, i.e. RGB or indexed.
+    targa_color_map_type::type _color_map_type;
+    
+    /// The type of image data, i.e compressed, indexed, uncompressed RGB, etc.
+    targa_image_type::type _image_type;
+    
+    /// Index of first entry in the color map table.
+    targa_color_map_start::type _color_map_start;
+    
+    /// Number of entries in the color map table.
+    targa_color_map_length::type _color_map_length;
+    
+    /// Bit depth for each color map entry.
+    targa_color_map_depth::type _color_map_depth;
+    
+    /// X coordinate of the image origin.
+    targa_origin_element::type _x_origin;
+    
+    /// Y coordinate of the image origin.
+    targa_origin_element::type _y_origin;
+    
+    /// Width of the image in pixels.
+    targa_dimension::type _width;
+    
+    /// Height of the image in pixels.
+    targa_dimension::type _height;
+    
+    /// Bit depth of the image.
+    targa_depth::type _bits_per_pixel;
+    
+    /// The targa image descriptor.
+    targa_descriptor::type _descriptor;
+
+    /// Used internally to identify if the header has been read.
+    bool _valid;
+};
+
+/// Read settings for targa images.
+///
+/// The structure can be used for all read_xxx functions, except read_image_info.
+template<>
+struct image_read_settings< targa_tag > : public image_read_settings_base
+{
+    /// Default constructor
+    image_read_settings()
+    : image_read_settings_base()
+    {}
+
+    /// Constructor
+    /// \param top_left Top left coordinate for reading partial image.
+    /// \param dim      Dimensions for reading partial image.
+    image_read_settings( const point_t& top_left
+                       , const point_t& dim
+                       )
+    : image_read_settings_base( top_left
+                              , dim
+                              )
+    {}
+};
+
+/// Write information for targa images.
+///
+/// The structure can be used for write_view() function.
+template<>
+struct image_write_info< targa_tag >
+{
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TARGA_TAGS_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/targa_write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/targa_write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+    Copyright 2010 Kenneth Riddile
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TARGA_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_TARGA_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Kenneth Riddile \n
+///         
+/// \date   2010 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "targa_tags.hpp"
+#include "formats/targa/supported_types.hpp"
+#include "formats/targa/write.hpp"
+
+#include "detail/make_writer.hpp"
+#include "detail/make_dynamic_image_writer.hpp"
+
+#include "detail/write_view.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_TARGA_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/tiff_all.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/tiff_all.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,25 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_ALL_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_ALL_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "tiff_read.hpp"
+#include "tiff_write.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_ALL_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/tiff_io_old.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/tiff_io_old.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,180 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_IO_OLD_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_IO_OLD_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "tiff_all.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup TIFF_IO
+/// \brief Returns the width and height of the TIFF file at the specified location.
+/// Throws std::ios_base::failure if the location does not correspond to a valid TIFF file
+template< typename String >
+inline
+point2< std::ptrdiff_t > tiff_read_dimensions( const String& filename )
+{
+    typedef typename get_reader_backend< String
+                                       , tiff_tag
+                                       >::type backend_t;
+
+    backend_t backend = read_image_info( filename
+                                       , tiff_tag()
+                                       );
+
+    return point2< std::ptrdiff_t >( backend._info._width
+                                   , backend._info._height
+                                   );
+}
+
+/// \ingroup TIFF_IO
+/// \brief Loads the image specified by the given tiff image file name into the given view.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the TIFF library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid TIFF file, or if its color space or channel depth are not 
+/// compatible with the ones specified by View, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline 
+void tiff_read_view( const String& filename
+                   , const View&   view
+                   )
+{
+    read_view( filename
+             , view
+             , tiff_tag()
+             );
+}
+
+/// \ingroup TIFF_IO
+/// \brief Allocates a new image whose dimensions are determined by the given tiff image file, and loads the pixels into it.
+/// Triggers a compile assert if the image color space or channel depth are not supported by the TIFF library or by the I/O extension.
+/// Throws std::ios_base::failure if the file is not a valid TIFF file, or if its color space or channel depth are not 
+/// compatible with the ones specified by Image
+template< typename String
+        , typename Image
+        >
+inline 
+void tiff_read_image( const String& filename
+                    , Image&        img
+                    )
+{
+    read_image( filename
+              , img
+              , tiff_tag()
+              );
+}
+
+/// \ingroup TIFF_IO
+/// \brief Loads and color-converts the image specified by the given tiff image file name into the given view.
+/// Throws std::ios_base::failure if the file is not a valid TIFF file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        , typename CC
+        >
+inline 
+void tiff_read_and_convert_view( const String& filename
+                               , const View&   view
+                               , CC            cc
+                               )
+{
+    read_and_convert_view( filename
+                         , view
+                         , cc
+                         , tiff_tag()
+                         );
+}
+
+/// \ingroup TIFF_IO
+/// \brief Loads and color-converts the image specified by the given tiff image file name into the given view.
+/// Throws std::ios_base::failure if the file is not a valid TIFF file, or if its dimensions don't match the ones of the view.
+template< typename String
+        , typename View
+        >
+inline 
+void tiff_read_and_convert_view( const String& filename
+                               , const View&   view
+                               )
+{
+    read_and_convert_view( filename
+                         , view
+                         , tiff_tag()
+                         );
+}
+
+/// \ingroup TIFF_IO
+/// \brief Allocates a new image whose dimensions are determined by the given tiff image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid TIFF file
+template< typename String
+        , typename Image
+        , typename CC
+        >
+inline 
+void tiff_read_and_convert_image( const String& filename
+                                , Image& img
+                                , CC     cc
+                                )
+{
+    read_and_convert_image( filename
+                          , img
+                          , cc
+                          , tiff_tag()
+                          );
+}
+
+/// \ingroup TIFF_IO
+/// \brief Allocates a new image whose dimensions are determined by the given tiff image file, loads and color-converts the pixels into it.
+/// Throws std::ios_base::failure if the file is not a valid TIFF file
+template< typename String
+        , typename Image
+        >
+inline 
+void tiff_read_and_convert_image( const String filename
+                                , Image&       img
+                                )
+{
+    read_and_convert_image( filename
+                          , img
+                          , tiff_tag()
+                          );
+}
+
+
+/// \ingroup TIFF_IO
+/// \brief Saves the view to a tiff file specified by the given tiff image file name.
+/// Triggers a compile assert if the view color space and channel depth are not supported by the TIFF library or by the I/O extension.
+/// Throws std::ios_base::failure if it fails to create the file.
+template< typename String
+        , typename View
+        >
+inline
+void tiff_write_view( const String& filename
+                    , const View&   view
+                    )
+{
+    write_view( filename
+              , view
+              , tiff_tag()
+              );
+}
+
+}  // namespace gil
+}  // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_IO_OLD_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/tiff_read.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/tiff_read.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,43 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_READ_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_READ_HPP
+
+#define BOOST_GIL_EXTENSION_IO_TIFF_READ_ENABLED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "tiff_tags.hpp"
+#include "formats/tiff/supported_types.hpp"
+#include "formats/tiff/read.hpp"
+#include "formats/tiff/scanline_read.hpp"
+
+#include "detail/get_reader.hpp"
+#include "detail/make_backend.hpp"
+#include "detail/make_reader.hpp"
+#include "detail/make_dynamic_image_reader.hpp"
+#include "detail/make_scanline_reader.hpp"
+
+#include "detail/read_view.hpp"
+#include "detail/read_image.hpp"
+#include "detail/read_image_info.hpp"
+#include "detail/read_and_convert_image.hpp"
+#include "detail/read_and_convert_view.hpp"
+
+#include "detail/image_read_iterator.hpp"
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_READ_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/tiff_tags.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/tiff_tags.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,328 @@
+/*
+    Copyright 2007-2008 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_TAGS_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_TAGS_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief All supported tiff tags by the gil io extension.
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+// taken from jpegxx - https://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/ijg_headers.hpp
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_C_LIB_COMPILED_AS_CPLUSPLUS
+    extern "C" {
+#else
+    // DONT_USE_EXTERN_C introduced in v7 of the IJG library.
+    // By default the v7 IJG headers check for __cplusplus being defined and
+    // wrap the content in an 'extern "C"' block if it's present.
+    // When DONT_USE_EXTERN_C is defined, this wrapping is not performed.
+    #ifndef DONT_USE_EXTERN_C
+        #define DONT_USE_EXTERN_C 1
+    #endif
+#endif
+
+#include <tiff.h>
+
+#ifndef BOOST_GIL_EXTENSION_IO_JPEG_C_LIB_COMPILED_AS_CPLUSPLUS
+    }
+#endif
+
+#include "detail/base.hpp"
+#include "formats/tiff/log.hpp"
+
+namespace boost { namespace gil {
+
+/// Defines tiff tag.
+struct tiff_tag : format_tag {};
+
+/// http://www.awaresystems.be/imaging/tiff/tifftags/baseline.html
+/// http://www.remotesensing.org/libtiff/
+
+
+/// TIFF property base class
+template< typename T, int Value >
+struct tiff_property_base : property_base< T >
+{
+    /// Tag, needed when reading or writing image properties.
+    static const unsigned int tag = Value;
+};
+
+/// baseline tags
+
+/// Defines type for new subfile property.
+struct tiff_new_subfile_type : tiff_property_base< uint32_t, TIFFTAG_SUBFILETYPE > {};
+
+/// Defines type for subfile property.
+struct tiff_subfile_type : tiff_property_base< uint16_t, TIFFTAG_OSUBFILETYPE > {};
+
+/// Defines type for image width property.
+struct tiff_image_width : tiff_property_base< uint32_t, TIFFTAG_IMAGEWIDTH > {};
+
+/// Defines type for image height property.
+struct tiff_image_height : tiff_property_base< uint32_t, TIFFTAG_IMAGELENGTH > {};
+
+/// Defines type for bits per sample property.
+struct tiff_bits_per_sample : tiff_property_base< uint16_t, TIFFTAG_BITSPERSAMPLE > {};
+
+/// Defines type for compression property.
+struct tiff_compression : tiff_property_base< uint16_t, TIFFTAG_COMPRESSION > {};
+
+/// Defines type for photometric interpretation property.
+struct tiff_photometric_interpretation : tiff_property_base< uint16_t, TIFFTAG_PHOTOMETRIC > {};
+
+/// Defines type for threshold property.
+struct tiff_thresholding : tiff_property_base< uint16_t, TIFFTAG_THRESHHOLDING > {};
+
+/// Defines type for cell width property.
+struct tiff_cell_width : tiff_property_base< uint16_t, TIFFTAG_CELLWIDTH > {};
+
+/// Defines type for cell length property.
+struct tiff_cell_length : tiff_property_base< uint16_t, TIFFTAG_CELLLENGTH > {};
+
+/// Defines type for fill order property.
+struct tiff_fill_order : tiff_property_base< std::string, TIFFTAG_FILLORDER > {};
+
+/// Defines type for image description.
+struct tiff_image_description : tiff_property_base< std::string, TIFFTAG_IMAGEDESCRIPTION > {};
+
+/// Defines type for make property.
+struct tiff_make : tiff_property_base< std::string, TIFFTAG_MAKE > {};
+
+/// Defines type for model property.
+struct tiff_model : tiff_property_base< std::string, TIFFTAG_MODEL > {};
+
+/// Defines type for image orientation.
+struct tiff_orientation : tiff_property_base< uint16_t, TIFFTAG_ORIENTATION > {};
+
+/// Defines type for samples per pixel property.
+struct tiff_samples_per_pixel : tiff_property_base< uint16_t, TIFFTAG_SAMPLESPERPIXEL > {};
+
+/// Defines type for rows per strip property.
+struct tiff_rows_per_strip : tiff_property_base< uint32_t, TIFFTAG_ROWSPERSTRIP > {};
+
+/// Defines type for min sample property.
+struct tiff_min_sample_value : tiff_property_base< uint16_t, TIFFTAG_MINSAMPLEVALUE > {};
+
+/// Defines type for max sample property.
+struct tiff_max_sample_value : tiff_property_base< uint16_t, TIFFTAG_MAXSAMPLEVALUE > {};
+
+/// Defines type for x resolution property.
+struct tiff_x_resolution : tiff_property_base< float, TIFFTAG_XRESOLUTION > {};
+
+/// Defines type for y resolution property.
+struct tiff_y_resolution : tiff_property_base< float, TIFFTAG_YRESOLUTION > {};
+
+/// Defines type for resolution unit property.
+struct tiff_resolution_unit : tiff_property_base< uint16_t, TIFFTAG_RESOLUTIONUNIT > {};
+
+/// Defines type for planar configuration property.
+struct tiff_planar_configuration : tiff_property_base< uint16_t, TIFFTAG_PLANARCONFIG > {};
+
+/// Defines type for gray response unit property.
+struct tiff_gray_response_unit : tiff_property_base< uint16_t, TIFFTAG_GRAYRESPONSEUNIT > {};
+
+/// Defines type for gray response curve property.
+struct tiff_gray_response_curve : tiff_property_base< uint16_t*, TIFFTAG_GRAYRESPONSECURVE > {};
+
+/// Defines type for software vendor property.
+struct tiff_software : tiff_property_base< std::string, TIFFTAG_SOFTWARE > {};
+
+/// Defines type for date time property.
+struct tiff_date_time : tiff_property_base< std::string, TIFFTAG_DATETIME > {};
+
+/// Defines type for artist information property.
+struct tiff_artist : tiff_property_base< std::string, TIFFTAG_ARTIST > {};
+
+/// Defines type for host computer property.
+struct tiff_host_computer : tiff_property_base< std::string, TIFFTAG_HOSTCOMPUTER > {};
+
+/// Helper structure for reading a color mapper.
+struct tiff_color_map
+{
+   typedef uint16_t* red_t;
+   typedef uint16_t* green_t;
+   typedef uint16_t* blue_t;
+
+   static const unsigned int tag = TIFFTAG_COLORMAP;
+};
+
+/// Defines type for extra samples property.
+struct tiff_extra_samples : tiff_property_base< uint16_t*, TIFFTAG_EXTRASAMPLES > {};
+
+/// Defines type for copyright property.
+struct tiff_copyright : tiff_property_base< std::string, TIFFTAG_COPYRIGHT > {};
+
+/// non-baseline tags
+
+/// Defines type for sample format property.
+struct tiff_sample_format : tiff_property_base< uint16_t, TIFFTAG_SAMPLEFORMAT > {};
+
+/// Defines type for indexed property.
+/// Not supported yet
+//struct tiff_indexed : tiff_property_base< bool, TIFFTAG_INDEXED > {};
+
+/// Tile related tags
+
+/// Defines type for a (not) tiled tiff image
+struct tiff_is_tiled : tiff_property_base< bool, false > {};
+
+/// Defines type for tile width
+struct tiff_tile_width : tiff_property_base< long, TIFFTAG_TILEWIDTH > {};
+
+/// Defines type for tile length
+struct tiff_tile_length : tiff_property_base< long, TIFFTAG_TILELENGTH > {};
+
+/// Defines the page to read in a multipage tiff file.
+#include <boost/mpl/integral_c.hpp>
+struct tiff_directory : property_base< tdir_t >
+{
+    typedef boost::mpl::integral_c< type, 0 > default_value;
+};
+
+/// Read information for tiff images.
+///
+/// The structure is returned when using read_image_info.
+template<>
+struct image_read_info< tiff_tag >
+{
+    image_read_info()
+    : _width( 0 )
+    , _height( 0 )
+
+    , _compression( COMPRESSION_NONE )
+
+    , _bits_per_sample( 0 )
+    , _samples_per_pixel( 0 )
+    , _sample_format( SAMPLEFORMAT_UINT )
+
+    , _planar_configuration( PLANARCONFIG_CONTIG )
+
+    , _photometric_interpretation( PHOTOMETRIC_MINISWHITE )
+
+    , _is_tiled( false )
+
+    , _tile_width ( 0 )
+    , _tile_length( 0 )
+    {}
+
+    /// The number of rows of pixels in the image.
+    tiff_image_width::type  _width;
+    /// The number of columns in the image, i.e., the number of pixels per row.
+    tiff_image_height::type _height;
+
+    /// Compression scheme used on the image data.
+    tiff_compression::type _compression;
+
+    /// Number of bits per component.
+    tiff_bits_per_sample::type   _bits_per_sample;
+    /// The number of components per pixel.
+    tiff_samples_per_pixel::type _samples_per_pixel;
+    /// Specifies how to interpret each data sample in a pixel.
+    tiff_sample_format::type     _sample_format;
+
+    /// How the components of each pixel are stored.
+    tiff_planar_configuration::type _planar_configuration;
+
+    /// The color space of the image data.
+    tiff_photometric_interpretation::type _photometric_interpretation;
+
+    /// Is tiled?
+    tiff_is_tiled::type _is_tiled;
+    /// Tile width
+    tiff_tile_width::type _tile_width;
+    /// Tile length
+    tiff_tile_length::type _tile_length;
+};
+
+/// Read settings for tiff images.
+///
+/// The structure can be used for all read_xxx functions, except read_image_info.
+template<>
+struct image_read_settings< tiff_tag > : public image_read_settings_base
+{
+    /// Default constructor
+    image_read_settings< tiff_tag >()
+    : image_read_settings_base()
+    , _directory( tiff_directory::default_value::value )
+    {}
+
+    /// Constructor
+    /// \param top_left  Top left coordinate for reading partial image.
+    /// \param dim       Dimensions for reading partial image.
+    /// \param directory Defines the page to read in a multipage tiff file.
+    image_read_settings( const point_t&              top_left
+                       , const point_t&              dim
+                       , const tiff_directory::type& directory = tiff_directory::default_value::value
+                       )
+    : image_read_settings_base( top_left
+                              , dim
+                              )
+    , _directory( directory )
+    {}
+
+    /// Defines the page to read in a multipage tiff file.
+    tiff_directory::type _directory;
+};
+
+/// Read settings for tiff images.
+///
+/// The structure can be used for all read_xxx functions, except read_image_info.
+template< typename Log >
+struct image_write_info< tiff_tag, Log >
+{
+    /// Default constructor
+    image_write_info()
+    : _photometric_interpretation             ( PHOTOMETRIC_MINISBLACK )
+    , _photometric_interpretation_user_defined( false                  )
+
+    , _compression               ( COMPRESSION_NONE       )
+    , _orientation               ( ORIENTATION_TOPLEFT    )
+    , _planar_configuration      ( PLANARCONFIG_CONTIG    )
+    , _is_tiled                  ( false )
+    , _tile_width                ( 0 )
+    , _tile_length               ( 0 )
+    , _x_resolution              ( 0 )
+    , _y_resolution              ( 0 )
+    {}
+
+    /// The color space of the image data.
+    tiff_photometric_interpretation::type _photometric_interpretation;
+    bool                                  _photometric_interpretation_user_defined;
+
+    /// Compression scheme used on the image data.
+    tiff_compression::type                _compression;
+    /// The orientation of the image with respect to the rows and columns.
+    tiff_orientation::type                _orientation;
+    /// How the components of each pixel are stored.
+    tiff_planar_configuration::type       _planar_configuration;
+
+    /// Is the image tiled?
+    tiff_is_tiled::type                   _is_tiled;
+    /// Tiles width
+    tiff_tile_width::type                 _tile_width;
+    /// Tiles length
+    tiff_tile_length::type                _tile_length;
+
+    /// x, y resolution
+    tiff_x_resolution::type               _x_resolution;
+    tiff_y_resolution::type               _y_resolution;
+
+    /// A log to transcript error and warning messages issued by libtiff.
+    Log                                   _log;
+};
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_TAGS_HPP
Index: boost-1.52.0/src/boost/gil/extension/io_new/tiff_write.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/io_new/tiff_write.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+    Copyright 2007-2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_IO_TIFF_WRITE_HPP
+#define BOOST_GIL_EXTENSION_IO_TIFF_WRITE_HPP
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "tiff_tags.hpp"
+#include "formats/tiff/supported_types.hpp"
+#include "formats/tiff/write.hpp"
+
+#include "detail/make_writer.hpp"
+#include "detail/make_dynamic_image_writer.hpp"
+
+#include "detail/write_view.hpp"
+
+
+#endif // BOOST_GIL_EXTENSION_IO_TIFF_WRITE_HPP
Index: boost-1.52.0/src/boost/gil/extension/numeric/affine.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/numeric/affine.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,91 @@
+/*
+  Copyright 2005-2007 Adobe Systems Incorporated
+  Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+  or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_AFFINE_HPP
+#define GIL_AFFINE_HPP
+
+#include "boost/gil/utilities.hpp"     // point2
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief support for affine transformations
+/// \author Lubomir Bourdev and Hailin Jin \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n September 21, 2006
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost { namespace gil {
+
+////////////////////////////////////////////////////////////////////////////////////////
+///
+/// Simple matrix to do 2D affine transformations. It is actually 3x3 but the last column is [0 0 1]
+///
+////////////////////////////////////////////////////////////////////////////////////////
+template <typename T>
+class matrix3x2 {
+public:
+    matrix3x2() : a(1), b(0), c(0), d(1), e(0), f(0) {}
+    matrix3x2(T A, T B, T C, T D, T E, T F) : a(A),b(B),c(C),d(D),e(E),f(F) {}
+    matrix3x2(const matrix3x2& mat) : a(mat.a), b(mat.b), c(mat.c), d(mat.d), e(mat.e), f(mat.f) {}
+    matrix3x2& operator=(const matrix3x2& m)           { a=m.a; b=m.b; c=m.c; d=m.d; e=m.e; f=m.f; return *this; }
+
+    matrix3x2& operator*=(const matrix3x2& m)          { (*this) = (*this)*m; return *this; }
+
+    static matrix3x2 get_rotate(T rads)                { T c=std::cos(rads); T s=std::sin(rads); return matrix3x2(c,s,-s,c,0,0); }
+    static matrix3x2 get_translate(const point2<T>& t) { return matrix3x2(1  ,0,0,1  ,t.x,t.y); }
+    static matrix3x2 get_translate(T x, T y)           { return matrix3x2(1  ,0,0,1  ,x,  y  ); }
+    static matrix3x2 get_scale    (const point2<T>& s) { return matrix3x2(s.x,0,0,s.y,0  ,0  ); }
+    static matrix3x2 get_scale    (T x, T y)           { return matrix3x2(x,  0,0,y,  0  ,0  ); }
+    static matrix3x2 get_scale    (T s)                { return matrix3x2(s  ,0,0,s  ,0  ,0  ); }
+
+    T a,b,c,d,e,f;
+};
+
+template <typename T> GIL_FORCEINLINE
+matrix3x2<T> operator*(const matrix3x2<T>& m1, const matrix3x2<T>& m2) {
+    return matrix3x2<T>(
+                m1.a * m2.a + m1.b * m2.c,
+                m1.a * m2.b + m1.b * m2.d,
+                m1.c * m2.a + m1.d * m2.c,
+                m1.c * m2.b + m1.d * m2.d,
+                m1.e * m2.a + m1.f * m2.c + m2.e,
+                m1.e * m2.b + m1.f * m2.d + m2.f );
+}
+
+template <typename T, typename F> GIL_FORCEINLINE
+point2<F> operator*(const point2<T>& p, const matrix3x2<F>& m) {
+    return point2<F>(m.a*p.x + m.c*p.y + m.e, m.b*p.x + m.d*p.y + m.f);
+}
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// Define affine mapping that transforms the source coordinates by the affine transformation
+////////////////////////////////////////////////////////////////////////////////////////
+/*
+template <typename MapFn>
+concept MappingFunctionConcept {
+    typename mapping_traits<MapFn>::result_type;   where PointNDConcept<result_type>;
+
+    template <typename Domain> { where PointNDConcept<Domain> }
+    result_type transform(MapFn&, const Domain& src); 
+};
+*/
+
+template <typename T> struct mapping_traits;
+
+template <typename F>
+struct mapping_traits<matrix3x2<F> > {
+    typedef point2<F> result_type;
+};
+
+template <typename F, typename F2> GIL_FORCEINLINE
+point2<F> transform(const matrix3x2<F>& mat, const point2<F2>& src) { return src * mat; }
+
+} }  // namespace boost::gil
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/numeric/algorithm.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/numeric/algorithm.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,155 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+    or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_NUMERIC_ALGORITHM_HPP
+#define GIL_NUMERIC_ALGORITHM_HPP
+
+/*!
+/// \file               
+/// \brief Numeric algorithms
+/// \author Hailin Jin and Lubomir Bourdev \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated on February 6, 2007
+*/
+
+#include <cassert>
+#include <iterator>
+#include <algorithm>
+#include <numeric>
+#include "boost/gil/gil_config.hpp"
+#include "boost/gil/pixel_iterator.hpp"
+#include "boost/gil/metafunctions.hpp"
+
+namespace boost { namespace gil {
+
+/// \brief Returns the reference proxy associated with a type that has a \p "reference" member typedef.
+///
+/// The reference proxy is the reference type, but with stripped-out C++ reference. It models PixelConcept
+template <typename T>
+struct pixel_proxy : public remove_reference<typename T::reference> {};
+
+/// \brief std::for_each for a pair of iterators
+template <typename Iterator1,typename Iterator2,typename BinaryFunction>
+BinaryFunction for_each(Iterator1 first1,Iterator1 last1,Iterator2 first2,BinaryFunction f) {
+    while(first1!=last1)
+        f(*first1++,*first2++);
+    return f;
+}
+
+template <typename SrcIterator,typename DstIterator>
+inline DstIterator assign_pixels(SrcIterator src,SrcIterator src_end,DstIterator dst) {
+    for_each(src,src_end,dst,pixel_assigns_t<typename pixel_proxy<typename std::iterator_traits<SrcIterator>::value_type>::type,
+                                             typename pixel_proxy<typename std::iterator_traits<DstIterator>::value_type>::type>());             
+    return dst+(src_end-src);
+}
+
+namespace detail {
+template <std::size_t Size>
+struct inner_product_k_t {
+    template <class _InputIterator1, class _InputIterator2, class _Tp,
+              class _BinaryOperation1, class _BinaryOperation2>
+    static _Tp apply(_InputIterator1 __first1, 
+                     _InputIterator2 __first2, _Tp __init, 
+                     _BinaryOperation1 __binary_op1,
+                     _BinaryOperation2 __binary_op2) {
+        __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
+        return inner_product_k_t<Size-1>::template apply(__first1+1,__first2+1,__init,
+                                                         __binary_op1, __binary_op2);
+    }
+};
+
+template <>
+struct inner_product_k_t<0> {
+    template <class _InputIterator1, class _InputIterator2, class _Tp,
+              class _BinaryOperation1, class _BinaryOperation2>
+    static _Tp apply(_InputIterator1 __first1, 
+                     _InputIterator2 __first2, _Tp __init, 
+                     _BinaryOperation1 __binary_op1,
+                     _BinaryOperation2 __binary_op2) {
+        return __init;
+    }
+};
+} // namespace detail
+
+/// static version of std::inner_product
+template <std::size_t Size,
+          class _InputIterator1, class _InputIterator2, class _Tp,
+          class _BinaryOperation1, class _BinaryOperation2>
+GIL_FORCEINLINE
+_Tp inner_product_k(_InputIterator1 __first1, 
+                    _InputIterator2 __first2,
+                    _Tp __init, 
+                    _BinaryOperation1 __binary_op1,
+                    _BinaryOperation2 __binary_op2) {
+    return detail::inner_product_k_t<Size>::template apply(__first1,__first2,__init,
+                                                           __binary_op1, __binary_op2);
+}
+
+/// \brief 1D un-guarded correlation with a variable-size kernel
+template <typename PixelAccum,typename SrcIterator,typename KernelIterator,typename Integer,typename DstIterator>
+inline DstIterator correlate_pixels_n(SrcIterator src_begin,SrcIterator src_end,
+                                      KernelIterator ker_begin,Integer ker_size,
+                                      DstIterator dst_begin) {
+    typedef typename pixel_proxy<typename std::iterator_traits<SrcIterator>::value_type>::type PIXEL_SRC_REF;
+    typedef typename pixel_proxy<typename std::iterator_traits<DstIterator>::value_type>::type PIXEL_DST_REF;
+    typedef typename std::iterator_traits<KernelIterator>::value_type kernel_type;
+    PixelAccum acc_zero; pixel_zeros_t<PixelAccum>()(acc_zero);
+    while(src_begin!=src_end) {
+        pixel_assigns_t<PixelAccum,PIXEL_DST_REF>()(
+            std::inner_product(src_begin,src_begin+ker_size,ker_begin,acc_zero,
+                               pixel_plus_t<PixelAccum,PixelAccum,PixelAccum>(),
+                               pixel_multiplies_scalar_t<PIXEL_SRC_REF,kernel_type,PixelAccum>()),
+            *dst_begin);
+        ++src_begin; ++dst_begin;
+    }
+    return dst_begin;
+}
+
+/// \brief 1D un-guarded correlation with a fixed-size kernel
+template <std::size_t Size,typename PixelAccum,typename SrcIterator,typename KernelIterator,typename DstIterator>
+inline DstIterator correlate_pixels_k(SrcIterator src_begin,SrcIterator src_end,
+                                      KernelIterator ker_begin,
+                                      DstIterator dst_begin) {
+    typedef typename pixel_proxy<typename std::iterator_traits<SrcIterator>::value_type>::type PIXEL_SRC_REF;
+    typedef typename pixel_proxy<typename std::iterator_traits<DstIterator>::value_type>::type PIXEL_DST_REF;
+    typedef typename std::iterator_traits<KernelIterator>::value_type kernel_type;
+    PixelAccum acc_zero; pixel_zeros_t<PixelAccum>()(acc_zero);
+    while(src_begin!=src_end) {
+        pixel_assigns_t<PixelAccum,PIXEL_DST_REF>()(
+            inner_product_k<Size>(src_begin,ker_begin,acc_zero,
+                                  pixel_plus_t<PixelAccum,PixelAccum,PixelAccum>(),
+                                  pixel_multiplies_scalar_t<PIXEL_SRC_REF,kernel_type,PixelAccum>()),
+            *dst_begin);
+        ++src_begin; ++dst_begin;
+    }
+    return dst_begin;
+}
+
+/// \brief destination is set to be product of the source and a scalar
+template <typename PixelAccum,typename SrcView,typename Scalar,typename DstView>
+inline void view_multiplies_scalar(const SrcView& src,const Scalar& scalar,const DstView& dst) {
+    assert(src.dimensions()==dst.dimensions());
+    typedef typename pixel_proxy<typename SrcView::value_type>::type PIXEL_SRC_REF;
+    typedef typename pixel_proxy<typename DstView::value_type>::type PIXEL_DST_REF;
+    int height=src.height();
+    for(int rr=0;rr<height;++rr) {
+        typename SrcView::x_iterator it_src=src.row_begin(rr);
+        typename DstView::x_iterator it_dst=dst.row_begin(rr);
+        typename SrcView::x_iterator it_src_end=src.row_end(rr);
+        while(it_src!=it_src_end) {
+            pixel_assigns_t<PixelAccum,PIXEL_DST_REF>()(
+                pixel_multiplies_scalar_t<PIXEL_SRC_REF,Scalar,PixelAccum>()(*it_src,scalar),
+                *it_dst);
+            ++it_src; ++it_dst;
+        }
+    }
+}
+
+} }  // namespace boost::gil
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/numeric/channel_numeric_operations.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/numeric/channel_numeric_operations.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,156 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+    or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_CHANNEL_NUMERIC_OPERATIONS_HPP
+#define GIL_CHANNEL_NUMERIC_OPERATIONS_HPP
+
+/*!
+/// \file               
+/// \brief Structures for channel-wise numeric operations
+/// \author Hailin Jin and Lubomir Bourdev \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated on September 30, 2006
+/// Currently defined structures:
+///    channel_plus_t (+), channel_minus_t (-),
+///    channel_multiplies_t (*), channel_divides_t (/),
+///    channel_plus_scalar_t (+s), channel_minus_scalar_t (-s),
+///    channel_multiplies_scalar_t (*s), channel_divides_scalar_t (/s),
+///    channel_halves_t (/=2), channel_zeros_t (=0), channel_assigns_t (=)
+*/
+
+#include <functional>
+#include "boost/gil/gil_config.hpp"
+#include "boost/gil/channel.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup ChannelNumericOperations
+/// structure for adding one channel to another
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel1,typename Channel2,typename ChannelR>
+struct channel_plus_t : public std::binary_function<Channel1,Channel2,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel1>::const_reference ch1,
+                        typename channel_traits<Channel2>::const_reference ch2) const {
+        return ChannelR(ch1)+ChannelR(ch2);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for subtracting one channel from another
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel1,typename Channel2,typename ChannelR>
+struct channel_minus_t : public std::binary_function<Channel1,Channel2,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel1>::const_reference ch1,
+                        typename channel_traits<Channel2>::const_reference ch2) const {
+        return ChannelR(ch1)-ChannelR(ch2);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for multiplying one channel to another
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel1,typename Channel2,typename ChannelR>
+struct channel_multiplies_t : public std::binary_function<Channel1,Channel2,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel1>::const_reference ch1,
+                        typename channel_traits<Channel2>::const_reference ch2) const {
+        return ChannelR(ch1)*ChannelR(ch2);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for dividing channels
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel1,typename Channel2,typename ChannelR>
+struct channel_divides_t : public std::binary_function<Channel1,Channel2,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel1>::const_reference ch1,
+                        typename channel_traits<Channel2>::const_reference ch2) const {
+        return ChannelR(ch1)/ChannelR(ch2);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for adding a scalar to a channel
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel,typename Scalar,typename ChannelR>
+struct channel_plus_scalar_t : public std::binary_function<Channel,Scalar,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel>::const_reference ch,
+                        const Scalar& s) const {
+        return ChannelR(ch)+ChannelR(s);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for subtracting a scalar from a channel
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel,typename Scalar,typename ChannelR>
+struct channel_minus_scalar_t : public std::binary_function<Channel,Scalar,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel>::const_reference ch,
+                        const Scalar& s) const {
+        return ChannelR(ch-s);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for multiplying a scalar to one channel
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel,typename Scalar,typename ChannelR>
+struct channel_multiplies_scalar_t : public std::binary_function<Channel,Scalar,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel>::const_reference ch,
+                        const Scalar& s) const {
+        return ChannelR(ch)*ChannelR(s);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for dividing a channel by a scalar
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel,typename Scalar,typename ChannelR>
+struct channel_divides_scalar_t : public std::binary_function<Channel,Scalar,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel>::const_reference ch,
+                        const Scalar& s) const {
+        return ChannelR(ch)/ChannelR(s);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for halving a channel
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel>
+struct channel_halves_t : public std::unary_function<Channel,Channel> {
+    typename channel_traits<Channel>::reference
+    operator()(typename channel_traits<Channel>::reference ch) const {
+        return ch/=2.0;
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for setting a channel to zero
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel>
+struct channel_zeros_t : public std::unary_function<Channel,Channel> {
+    typename channel_traits<Channel>::reference
+    operator()(typename channel_traits<Channel>::reference ch) const {
+        return ch=Channel(0);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for assigning one channel to another
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel1,typename Channel2>
+struct channel_assigns_t : public std::binary_function<Channel1,Channel2,Channel2> {
+    typename channel_traits<Channel2>::reference
+    operator()(typename channel_traits<Channel1>::const_reference ch1,
+               typename channel_traits<Channel2>::reference ch2) const {
+        return ch2=Channel2(ch1);
+    }
+};
+
+} }  // namespace boost::gil
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/numeric/convolve.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/numeric/convolve.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,216 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+    or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_CONVOLVE_HPP
+#define GIL_CONVOLVE_HPP
+
+/*!
+/// \file 
+/// \brief 2D seperable convolutions and correlations
+///
+/// \author Hailin Jin and Lubomir Bourdev \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated on February 6, 2007
+*/
+
+
+#include <cstddef>
+#include <cassert>
+#include <algorithm>
+#include <vector>
+#include <functional>
+#include "boost/gil/gil_config.hpp"
+#include "boost/gil/image_view_factory.hpp"
+#include "boost/gil/algorithm.hpp"
+#include "boost/gil/metafunctions.hpp"
+#include "pixel_numeric_operations.hpp"
+#include "algorithm.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup ImageAlgorithms
+/// Boundary options for 1D correlations/convolutions
+enum convolve_boundary_option  {
+    convolve_option_output_ignore,  /// do nothing to the output
+    convolve_option_output_zero,    /// set the output to zero
+    convolve_option_extend_padded,  /// assume the source boundaries to be padded already 
+    convolve_option_extend_zero,    /// assume the source boundaries to be zero
+    convolve_option_extend_constant /// assume the source boundaries to be the boundary value
+};
+
+namespace detail {
+/// compute the correlation of 1D kernel with the rows of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView,typename Correlator>
+void correlate_rows_imp(const SrcView& src, const Kernel& ker, const DstView& dst,
+                        convolve_boundary_option option,
+                        Correlator correlator) {
+    assert(src.dimensions()==dst.dimensions());
+    assert(ker.size()!=0);
+
+    typedef typename pixel_proxy<typename SrcView::value_type>::type PIXEL_SRC_REF;
+    typedef typename pixel_proxy<typename DstView::value_type>::type PIXEL_DST_REF;
+    typedef typename Kernel::value_type kernel_type;
+
+    if(ker.size()==1) {//reduces to a multiplication
+        view_multiplies_scalar<PixelAccum>(src,*ker.begin(),dst);
+        return;
+    }
+
+    int width=src.width(),height=src.height();
+    PixelAccum acc_zero; pixel_zeros_t<PixelAccum>()(acc_zero);
+    if (width==0) return;
+    if (option==convolve_option_output_ignore || option==convolve_option_output_zero) {
+        typename DstView::value_type dst_zero; pixel_assigns_t<PixelAccum,PIXEL_DST_REF>()(acc_zero,dst_zero);
+        if (width<(int)ker.size()) {
+            if (option==convolve_option_output_zero)
+                fill_pixels(dst,dst_zero);
+        } else {
+            std::vector<PixelAccum> buffer(width);
+            for(int rr=0;rr<height;++rr) {
+                assign_pixels(src.row_begin(rr),src.row_end(rr),&buffer.front());
+                typename DstView::x_iterator it_dst=dst.row_begin(rr);
+                if (option==convolve_option_output_zero)
+                    std::fill_n(it_dst,ker.left_size(),dst_zero);
+                it_dst+=ker.left_size();
+                correlator(&buffer.front(),&buffer.front()+width+1-ker.size(),
+                           ker.begin(),it_dst);
+                it_dst+=width+1-ker.size();
+                if (option==convolve_option_output_zero) 
+                    std::fill_n(it_dst,ker.right_size(),dst_zero);
+            }
+        }
+    } else {
+        std::vector<PixelAccum> buffer(width+ker.size()-1);
+        for(int rr=0;rr<height;++rr) {
+            PixelAccum* it_buffer=&buffer.front();
+            if        (option==convolve_option_extend_padded) {
+                assign_pixels(src.row_begin(rr)-ker.left_size(),
+                              src.row_end(rr)+ker.right_size(),
+                              it_buffer);
+            } else if (option==convolve_option_extend_zero) {
+                std::fill_n(it_buffer,ker.left_size(),acc_zero);
+                it_buffer+=ker.left_size();
+                assign_pixels(src.row_begin(rr),src.row_end(rr),it_buffer);
+                it_buffer+=width;
+                std::fill_n(it_buffer,ker.right_size(),acc_zero);
+            } else if (option==convolve_option_extend_constant) {
+                PixelAccum filler;
+                pixel_assigns_t<PIXEL_SRC_REF,PixelAccum>()(*src.row_begin(rr),filler);
+                std::fill_n(it_buffer,ker.left_size(),filler);
+                it_buffer+=ker.left_size();
+                assign_pixels(src.row_begin(rr),src.row_end(rr),it_buffer);
+                it_buffer+=width;
+                pixel_assigns_t<PIXEL_SRC_REF,PixelAccum>()(src.row_end(rr)[-1],filler);
+                std::fill_n(it_buffer,ker.right_size(),filler);
+            }
+            correlator(&buffer.front(),&buffer.front()+width,
+                       ker.begin(),
+                       dst.row_begin(rr));
+        }
+    }
+}
+template <typename PixelAccum>
+class correlator_n {
+private:
+    std::size_t _size;
+public:
+    correlator_n(std::size_t size_in) : _size(size_in) {}
+    template <typename SrcIterator,typename KernelIterator,typename DstIterator>
+    void operator()(SrcIterator src_begin,SrcIterator src_end,
+                    KernelIterator ker_begin,
+                    DstIterator dst_begin) {
+        correlate_pixels_n<PixelAccum>(src_begin,src_end,ker_begin,_size,dst_begin);
+    }
+};
+template <std::size_t Size,typename PixelAccum>
+struct correlator_k {
+public:
+    template <typename SrcIterator,typename KernelIterator,typename DstIterator>
+    void operator()(SrcIterator src_begin,SrcIterator src_end,
+                    KernelIterator ker_begin,
+                    DstIterator dst_begin){
+        correlate_pixels_k<Size,PixelAccum>(src_begin,src_end,ker_begin,dst_begin);
+    }
+};
+} // namespace detail
+
+/// \ingroup ImageAlgorithms
+///correlate a 1D variable-size kernel along the rows of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void correlate_rows(const SrcView& src, const Kernel& ker, const DstView& dst,
+                    convolve_boundary_option option=convolve_option_extend_zero) {
+    detail::correlate_rows_imp<PixelAccum>(src,ker,dst,option,detail::correlator_n<PixelAccum>(ker.size()));
+}
+
+/// \ingroup ImageAlgorithms
+///correlate a 1D variable-size kernel along the columns of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void correlate_cols(const SrcView& src, const Kernel& ker, const DstView& dst,
+                    convolve_boundary_option option=convolve_option_extend_zero) {
+    correlate_rows<PixelAccum>(transposed_view(src),ker,transposed_view(dst),option);
+}
+
+/// \ingroup ImageAlgorithms
+///convolve a 1D variable-size kernel along the rows of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void convolve_rows(const SrcView& src, const Kernel& ker, const DstView& dst,
+                   convolve_boundary_option option=convolve_option_extend_zero) {
+    correlate_rows<PixelAccum>(src,reverse_kernel(ker),dst,option);
+}
+
+/// \ingroup ImageAlgorithms
+///convolve a 1D variable-size kernel along the columns of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void convolve_cols(const SrcView& src, const Kernel& ker, const DstView& dst,
+                   convolve_boundary_option option=convolve_option_extend_zero) {
+    convolve_rows<PixelAccum>(transposed_view(src),ker,transposed_view(dst),option);
+}
+
+/// \ingroup ImageAlgorithms
+///correlate a 1D fixed-size kernel along the rows of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void correlate_rows_fixed(const SrcView& src, const Kernel& ker, const DstView& dst,
+                          convolve_boundary_option option=convolve_option_extend_zero) {
+    detail::correlate_rows_imp<PixelAccum>(src,ker,dst,option,detail::correlator_k<Kernel::static_size,PixelAccum>());
+}
+
+/// \ingroup ImageAlgorithms
+///correlate a 1D fixed-size kernel along the columns of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void correlate_cols_fixed(const SrcView& src, const Kernel& ker, const DstView& dst,
+                          convolve_boundary_option option=convolve_option_extend_zero) {
+    correlate_rows_fixed<PixelAccum>(transposed_view(src),ker,transposed_view(dst),option);
+}
+
+/// \ingroup ImageAlgorithms
+///convolve a 1D fixed-size kernel along the rows of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void convolve_rows_fixed(const SrcView& src, const Kernel& ker, const DstView& dst,
+                         convolve_boundary_option option=convolve_option_extend_zero) {
+    correlate_rows_fixed<PixelAccum>(src,reverse_kernel(ker),dst,option);
+}
+
+/// \ingroup ImageAlgorithms
+///convolve a 1D fixed-size kernel along the columns of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void convolve_cols_fixed(const SrcView& src, const Kernel& ker, const DstView& dst,
+                         convolve_boundary_option option=convolve_option_extend_zero) {
+    convolve_rows_fixed<PixelAccum>(transposed_view(src),ker,transposed_view(dst),option);
+}
+
+} }  // namespace boost::gil
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/numeric/kernel.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/numeric/kernel.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,101 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+    or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_KERNEL_HPP
+#define GIL_KERNEL_HPP
+
+/*!
+/// \file
+/// \brief Definitions of 1D fixed-size and variable-size kernels and related operations
+/// \author Hailin Jin and Lubomir Bourdev \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated on September 26, 2006
+*/
+
+#include <cstddef>
+#include <cassert>
+#include <algorithm>
+#include <vector>
+#include <memory>
+#include <boost/array.hpp>
+#include "boost/gil/gil_config.hpp"
+#include "boost/gil/utilities.hpp"
+
+namespace boost { namespace gil {
+
+namespace detail {
+
+/// \brief kernel adaptor for one-dimensional cores
+/// Core needs to provide size(),begin(),end(),operator[],
+///                       value_type,iterator,const_iterator,reference,const_reference
+template <typename Core>
+class kernel_1d_adaptor : public Core {
+private:
+    std::size_t _center;
+public:
+    kernel_1d_adaptor() : _center(0) {}
+    explicit kernel_1d_adaptor(std::size_t center_in) : _center(center_in) {assert(_center<this->size());}
+    kernel_1d_adaptor(std::size_t size_in,std::size_t center_in) :
+        Core(size_in), _center(center_in) {assert(_center<this->size());}
+    kernel_1d_adaptor(const kernel_1d_adaptor& k_in) : Core(k_in), _center(k_in._center) {}
+
+    kernel_1d_adaptor& operator=(const kernel_1d_adaptor& k_in) {
+        Core::operator=(k_in);
+        _center=k_in._center;
+        return *this;
+    }
+    std::size_t left_size() const {assert(_center<this->size());return _center;}
+    std::size_t right_size() const {assert(_center<this->size());return this->size()-_center-1;}
+          std::size_t& center()       {return _center;}
+    const std::size_t& center() const {return _center;}
+};
+
+} // namespace detail
+
+/// \brief variable-size kernel
+template <typename T, typename Alloc = std::allocator<T> >
+class kernel_1d : public detail::kernel_1d_adaptor<std::vector<T,Alloc> > {
+    typedef detail::kernel_1d_adaptor<std::vector<T,Alloc> > parent_t;
+public:
+    kernel_1d() {}
+    kernel_1d(std::size_t size_in,std::size_t center_in) : parent_t(size_in,center_in) {}
+    template <typename FwdIterator>
+    kernel_1d(FwdIterator elements, std::size_t size_in, std::size_t center_in) : parent_t(size_in,center_in) {
+        detail::copy_n(elements,size_in,this->begin());
+    }
+    kernel_1d(const kernel_1d& k_in)                     : parent_t(k_in) {}
+};
+
+/// \brief static-size kernel
+template <typename T,std::size_t Size>
+class kernel_1d_fixed : public detail::kernel_1d_adaptor<array<T,Size> > {
+    typedef detail::kernel_1d_adaptor<array<T,Size> > parent_t;
+public:
+    kernel_1d_fixed() {}
+    explicit kernel_1d_fixed(std::size_t center_in) : parent_t(center_in) {}
+    
+    template <typename FwdIterator>
+    explicit kernel_1d_fixed(FwdIterator elements, std::size_t center_in) : parent_t(center_in) {
+        detail::copy_n(elements,Size,this->begin());
+    }
+    kernel_1d_fixed(const kernel_1d_fixed& k_in)    : parent_t(k_in) {}
+};
+
+/// \brief reverse a kernel
+template <typename Kernel>
+inline Kernel reverse_kernel(const Kernel& kernel) {
+    Kernel result(kernel);
+    result.center()=kernel.right_size();
+    std::reverse(result.begin(), result.end());
+    return result;
+}
+
+
+} }  // namespace boost::gil
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/numeric/pixel_numeric_operations.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/numeric/pixel_numeric_operations.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,144 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+    or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_PIXEL_NUMERIC_OPERATIONS_HPP
+#define GIL_PIXEL_NUMERIC_OPERATIONS_HPP
+
+/*!
+/// \file               
+/// \brief Structures for pixel-wise numeric operations
+/// \author Lubomir Bourdev and Hailin Jin \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated on February 6, 2007
+/// Currently defined structures:
+///     pixel_plus_t (+), pixel_minus_t (-)
+///     pixel_multiplies_scalar_t (*), pixel_divides_scalar_t (/)
+///     pixel_halves_t (/=2), pixel_zeros_t (=0)
+///     pixel_assigns_t (=)
+*/
+
+#include <functional>
+#include "boost/gil/gil_config.hpp"
+#include "boost/gil/pixel.hpp"
+#include "boost/gil/color_base_algorithm.hpp"
+#include "channel_numeric_operations.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for adding two pixels
+template <typename PixelRef1, // models pixel concept
+          typename PixelRef2, // models pixel concept
+          typename PixelR>    // models pixel value concept
+struct pixel_plus_t {
+    PixelR operator() (const PixelRef1& p1,
+                       const PixelRef2& p2) const {
+        PixelR result;
+        static_transform(p1,p2,result,
+                           channel_plus_t<typename channel_type<PixelRef1>::type,
+                                          typename channel_type<PixelRef2>::type,
+                                          typename channel_type<PixelR>::type>());
+        return result;
+    }
+};
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for subtracting two pixels
+template <typename PixelRef1, // models pixel concept
+          typename PixelRef2, // models pixel concept
+          typename PixelR>    // models pixel value concept
+struct pixel_minus_t {
+    PixelR operator() (const PixelRef1& p1,
+                       const PixelRef2& p2) const {
+        PixelR result;
+        static_transform(p1,p2,result,
+                           channel_minus_t<typename channel_type<PixelRef1>::type,
+                                           typename channel_type<PixelRef2>::type,
+                                           typename channel_type<PixelR>::type>());
+        return result;
+    }
+};
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for multiplying scalar to a pixel
+template <typename PixelRef, // models pixel concept
+          typename Scalar,   // models a scalar type
+          typename PixelR>   // models pixel value concept
+struct pixel_multiplies_scalar_t {
+    PixelR operator () (const PixelRef& p,
+                        const Scalar& s) const {
+        PixelR result;
+        static_transform(p,result,
+                           std::bind2nd(channel_multiplies_scalar_t<typename channel_type<PixelRef>::type,
+                                                                    Scalar,
+                                                                    typename channel_type<PixelR>::type>(),s));
+        return result;
+    }
+};
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for dividing a pixel by a scalar
+template <typename PixelRef, // models pixel concept
+          typename Scalar,   // models a scalar type
+          typename PixelR>   // models pixel value concept
+struct pixel_divides_scalar_t {
+    PixelR operator () (const PixelRef& p,
+                        const Scalar& s) const {
+        PixelR result;
+        static_transform(p,result,
+                           std::bind2nd(channel_divides_scalar_t<typename channel_type<PixelRef>::type,
+                                                                 Scalar,
+                                                                 typename channel_type<PixelR>::type>(),s));
+        return result;
+    }
+};
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for dividing a pixel by 2
+template <typename PixelRef> // models pixel concept
+struct pixel_halves_t {
+    PixelRef& operator () (PixelRef& p) const {
+        static_for_each(p,channel_halves_t<typename channel_type<PixelRef>::type>());
+        return p;
+    }
+};
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for setting a pixel to zero (for whatever zero means)
+template <typename PixelRef> // models pixel concept
+struct pixel_zeros_t {
+    PixelRef& operator () (PixelRef& p) const {
+        static_for_each(p,channel_zeros_t<typename channel_type<PixelRef>::type>());
+        return p;
+    }
+};
+
+// Hailin: This is how you can do it:
+template <typename Pixel>
+void zero_channels(Pixel& p) {
+    static_for_each(p,channel_zeros_t<typename channel_type<Pixel>::type>());
+}
+
+
+/// \ingroup PixelNumericOperations
+///definition and a generic implementation for casting and assigning a pixel to another
+///user should specialize it for better performance
+template <typename PixelRef,  // models pixel concept
+          typename PixelRefR> // models pixel concept
+struct pixel_assigns_t {
+    PixelRefR operator () (const PixelRef& src,
+                           PixelRefR& dst) const {
+        static_for_each(src,dst,channel_assigns_t<typename channel_type<PixelRef>::type,
+                                                  typename channel_type<PixelRefR>::type>());
+        return dst;
+    }
+};
+
+} }  // namespace boost::gil
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/numeric/resample.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/numeric/resample.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,141 @@
+/*
+  Copyright 2005-2007 Adobe Systems Incorporated
+  Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+  or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_RESAMPLE_HPP
+#define GIL_RESAMPLE_HPP
+
+#include <boost/lambda/lambda.hpp>
+#include <boost/lambda/bind.hpp>
+#include "boost/gil/extension/dynamic_image/dynamic_image_all.hpp"
+#include "affine.hpp"
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief support for generic image resampling
+///        NOTE: The code is for example use only. It is not optimized for performance
+/// \author Lubomir Bourdev and Hailin Jin \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n October 30, 2006
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost { namespace gil {
+
+///////////////////////////////////////////////////////////////////////////
+////
+////   resample_pixels: set each pixel in the destination view as the result of a sampling function over the transformed coordinates of the source view
+////
+///////////////////////////////////////////////////////////////////////////
+
+template <typename MapFn> struct mapping_traits {};
+
+/// \brief Set each pixel in the destination view as the result of a sampling function over the transformed coordinates of the source view
+/// \ingroup ImageAlgorithms
+///
+/// The provided implementation works for 2D image views only
+template <typename Sampler,        // Models SamplerConcept
+          typename SrcView,        // Models RandomAccess2DImageViewConcept
+          typename DstView,        // Models MutableRandomAccess2DImageViewConcept
+          typename MapFn>        // Models MappingFunctionConcept
+void resample_pixels(const SrcView& src_view, const DstView& dst_view, const MapFn& dst_to_src, Sampler sampler=Sampler()) {
+    typename DstView::point_t dst_dims=dst_view.dimensions();
+    typename DstView::point_t dst_p;
+    typename mapping_traits<MapFn>::result_type src_p;
+
+    for (dst_p.y=0; dst_p.y<dst_dims.y; ++dst_p.y) {
+        typename DstView::x_iterator xit = dst_view.row_begin(dst_p.y);
+        for (dst_p.x=0; dst_p.x<dst_dims.x; ++dst_p.x) {
+            sample(sampler, src_view, transform(dst_to_src, dst_p), xit[dst_p.x]);
+        }
+    }
+}
+
+///////////////////////////////////////////////////////////////////////////
+////
+////   resample_pixels when one or both image views are run-time instantiated. 
+////
+///////////////////////////////////////////////////////////////////////////
+
+namespace detail {
+    template <typename Sampler, typename MapFn>
+    struct resample_pixels_fn : public binary_operation_obj<resample_pixels_fn<Sampler,MapFn> > {
+        MapFn  _dst_to_src;
+        Sampler _sampler;
+        resample_pixels_fn(const MapFn& dst_to_src, const Sampler& sampler) : _dst_to_src(dst_to_src), _sampler(sampler) {}
+
+        template <typename SrcView, typename DstView> GIL_FORCEINLINE void apply_compatible(const SrcView& src, const DstView& dst)  const { 
+            resample_pixels(src, dst, _dst_to_src, _sampler); 
+        }
+    };
+}
+
+/// \brief resample_pixels when the source is run-time specified
+///        If invoked on incompatible views, throws std::bad_cast()
+/// \ingroup ImageAlgorithms
+template <typename Sampler, typename Types1, typename V2, typename MapFn>
+void resample_pixels(const any_image_view<Types1>& src, const V2& dst, const MapFn& dst_to_src, Sampler sampler=Sampler()) {
+    apply_operation(src,bind(detail::resample_pixels_fn<Sampler,MapFn>(dst_to_src,sampler), _1, dst));
+}
+
+/// \brief resample_pixels when the destination is run-time specified
+///        If invoked on incompatible views, throws std::bad_cast()
+/// \ingroup ImageAlgorithms
+template <typename Sampler, typename V1, typename Types2, typename MapFn>
+void resample_pixels(const V1& src, const any_image_view<Types2>& dst, const MapFn& dst_to_src, Sampler sampler=Sampler()) {
+    apply_operation(dst,bind(detail::resample_pixels_fn<Sampler,MapFn>(dst_to_src,sampler), src, _1));
+}
+
+/// \brief resample_pixels when both the source and the destination are run-time specified
+///        If invoked on incompatible views, throws std::bad_cast()
+/// \ingroup ImageAlgorithms
+template <typename Sampler, typename SrcTypes, typename DstTypes, typename MapFn> 
+void resample_pixels(const any_image_view<SrcTypes>& src, const any_image_view<DstTypes>& dst, const MapFn& dst_to_src, Sampler sampler=Sampler()) {
+    apply_operation(src,dst,detail::resample_pixels_fn<Sampler,MapFn>(dst_to_src,sampler));
+}
+
+///////////////////////////////////////////////////////////////////////////
+////
+////   resample_subimage: copy into the destination a rotated rectangular region from the source, rescaling it to fit into the destination
+////
+///////////////////////////////////////////////////////////////////////////
+
+// Extract into dst the rotated bounds [src_min..src_max] rotated at 'angle' from the source view 'src'
+// The source coordinates are in the coordinate space of the source image
+// Note that the views could also be variants (i.e. any_image_view)
+template <typename Sampler, typename SrcMetaView, typename DstMetaView> 
+void resample_subimage(const SrcMetaView& src, const DstMetaView& dst, 
+                         double src_min_x, double src_min_y,
+                         double src_max_x, double src_max_y,
+                         double angle, const Sampler& sampler=Sampler()) {
+    double src_width  = std::max<double>(src_max_x - src_min_x - 1,1);
+    double src_height = std::max<double>(src_max_y - src_min_y - 1,1);
+    double dst_width  = std::max<double>((double)(dst.width()-1),1);
+    double dst_height = std::max<double>((double)(dst.height()-1),1);
+
+    matrix3x2<double> mat = 
+        matrix3x2<double>::get_translate(-dst_width/2.0, -dst_height/2.0) * 
+        matrix3x2<double>::get_scale(src_width / dst_width, src_height / dst_height)*
+        matrix3x2<double>::get_rotate(-angle)*
+        matrix3x2<double>::get_translate(src_min_x + src_width/2.0, src_min_y + src_height/2.0);
+    resample_pixels(src,dst,mat,sampler);
+}
+
+///////////////////////////////////////////////////////////////////////////
+////
+////   resize_view: Copy the source view into the destination, scaling to fit
+////
+///////////////////////////////////////////////////////////////////////////
+
+template <typename Sampler, typename SrcMetaView, typename DstMetaView> 
+void resize_view(const SrcMetaView& src, const DstMetaView& dst, const Sampler& sampler=Sampler()) {
+    resample_subimage(src,dst,0.0,0.0,(double)src.width(),(double)src.height(),0.0,sampler);
+}
+
+} }  // namespace boost::gil
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/numeric/sampler.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/numeric/sampler.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,189 @@
+/*
+  Copyright 2005-2007 Adobe Systems Incorporated
+  Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+  or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_SAMPLER_HPP
+#define GIL_SAMPLER_HPP
+
+#include "boost/gil/extension/dynamic_image/dynamic_image_all.hpp"
+#include "pixel_numeric_operations.hpp"
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief Nearest-neighbor and bilinear image samplers.
+///        NOTE: The code is for example use only. It is not optimized for performance
+/// \author Lubomir Bourdev and Hailin Jin \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n October 30, 2006
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost { namespace gil {
+
+///////////////////////////////////////////////////////////////////////////
+////
+////     resample_pixels: set each pixel in the destination view as the result of a sampling function over the transformed coordinates of the source view
+////
+///////////////////////////////////////////////////////////////////////////
+/*
+template <typename Sampler>
+concept SamplerConcept {
+    template <typename DstP,      // Models PixelConcept
+              typename SrcView,    // Models RandomAccessNDImageViewConcept
+              typename S_COORDS>  // Models PointNDConcept, where S_COORDS::num_dimensions == SrcView::num_dimensions
+    bool sample(const Sampler& s, const SrcView& src, const S_COORDS& p, DstP result);
+};
+*/
+
+/// \brief A sampler that sets the destination pixel to the closest one in the source. If outside the bounds, it doesn't change the destination
+/// \ingroup ImageAlgorithms
+struct nearest_neighbor_sampler {};
+
+template <typename DstP, typename SrcView, typename F>
+bool sample(nearest_neighbor_sampler, const SrcView& src, const point2<F>& p, DstP& result) {
+    point2<int> center(iround(p));
+    if (center.x>=0 && center.y>=0 && center.x<src.width() && center.y<src.height()) {
+        result=src(center.x,center.y);
+        return true;
+    }
+    return false;
+}
+
+struct cast_channel_fn {
+    template <typename SrcChannel, typename DstChannel>
+    void operator()(const SrcChannel& src, DstChannel& dst) {
+        typedef typename channel_traits<DstChannel>::value_type dst_value_t;
+        dst = dst_value_t(src);
+    }
+};
+
+template <typename SrcPixel, typename DstPixel>
+void cast_pixel(const SrcPixel& src, DstPixel& dst) {
+    static_for_each(src,dst,cast_channel_fn());
+}
+
+namespace detail {
+
+template <typename Weight>
+struct add_dst_mul_src_channel {
+    Weight _w;
+    add_dst_mul_src_channel(Weight w) : _w(w) {}
+
+    template <typename SrcChannel, typename DstChannel>
+    void operator()(const SrcChannel& src, DstChannel& dst) const {
+        dst += DstChannel(src*_w);
+    }
+};
+
+// dst += DST_TYPE(src * w)
+template <typename SrcP,typename Weight,typename DstP>
+struct add_dst_mul_src {
+    void operator()(const SrcP& src, Weight weight, DstP& dst) const {
+        static_for_each(src,dst, add_dst_mul_src_channel<Weight>(weight));
+//        pixel_assigns_t<DstP,DstP&>()(
+//            pixel_plus_t<DstP,DstP,DstP>()(
+//                pixel_multiplies_scalar_t<SrcP,Weight,DstP>()(src,weight),
+//                dst),
+//            dst);
+    }
+};
+} // namespace detail
+
+/// \brief A sampler that sets the destination pixel as the bilinear interpolation of the four closest pixels from the source. 
+/// If outside the bounds, it doesn't change the destination
+/// \ingroup ImageAlgorithms
+struct bilinear_sampler {};
+
+template <typename DstP, typename SrcView, typename F>
+bool sample(bilinear_sampler, const SrcView& src, const point2<F>& p, DstP& result)
+{
+    typedef typename SrcView::value_type SrcP;
+
+    point2<ptrdiff_t> p0(ifloor(p.x), ifloor(p.y)); // the closest integer coordinate top left from p
+    point2<F> frac(p.x-p0.x, p.y-p0.y);
+
+    if (p0.x < -1 || p0.y < -1 || p0.x>=src.width() || p0.y>=src.height()) 
+    {
+        return false;
+    }
+
+	pixel<F,devicen_layout_t<num_channels<SrcView>::value> > mp(0); // suboptimal
+	typename SrcView::xy_locator loc=src.xy_at(p0.x,p0.y);
+
+	if (p0.x == -1)
+    {
+		if (p0.y == -1)
+        {
+			++loc.y();
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(loc.x()[1],   frac.x *   frac.y ,mp);
+		}
+        else if (p0.y+1<src.height())
+        {
+			// most common case - inside the image, not on the last row or column
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(loc.x()[1],   frac.x *(1-frac.y),mp);
+			++loc.y();
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(loc.x()[1],   frac.x *   frac.y ,mp);
+		}
+        else
+        {
+			// on the last row, but not the bottom-right corner pixel
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(loc.x()[1],   frac.x ,mp);
+		}
+	}
+    else if (p0.x+1<src.width())
+    {
+		if (p0.y == -1)
+        {
+			++loc.y();
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,      (1-frac.x)*   frac.y ,mp);
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(loc.x()[1],   frac.x *   frac.y ,mp);
+		}
+        else if (p0.y+1<src.height())
+        {
+			// most common case - inside the image, not on the last row or column
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,      (1-frac.x)*(1-frac.y),mp);
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(loc.x()[1],   frac.x *(1-frac.y),mp);
+			++loc.y();
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,      (1-frac.x)*   frac.y ,mp);
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(loc.x()[1],   frac.x *   frac.y ,mp);
+		}
+        else
+        {
+			// on the last row, but not the bottom-right corner pixel
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,      (1-frac.x),mp);
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(loc.x()[1],   frac.x ,mp);
+		}
+	}
+    else
+    {
+		if (p0.y+1<src.height())
+        {
+			// on the last column, but not the bottom-right corner pixel
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,      (1-frac.y),mp);
+			++loc.y();
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,         frac.y ,mp);
+		}
+        else
+        {
+			// the bottom-right corner pixel
+			detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,1,mp);
+		}
+	}
+
+	// Convert from floating point average value to the source type
+	SrcP src_result;
+	cast_pixel(mp,src_result);
+
+	color_convert(src_result, result);
+
+	return true;
+}
+
+}  // namespace gil
+}  // namespace boost
+
+#endif // GIL_SAMPLER_HPP
Index: boost-1.52.0/src/boost/gil/extension/opencv/convert_color.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/opencv/convert_color.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,452 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_OPENCV_CONVERT_COLOR_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_OPENCV_CONVERT_COLOR_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/static_assert.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/toolbox/xyz.hpp>
+#include <boost/gil/extension/toolbox/hsl.hpp>
+#include <boost/gil/extension/toolbox/hsv.hpp>
+#include <boost/gil/extension/toolbox/lab.hpp>
+
+#include <boost/mpl/bool.hpp>
+#include <boost/mpl/or.hpp>
+
+#include <boost/type_traits/is_base_of.hpp>
+#include <boost/type_traits/is_same.hpp>
+
+#include <boost/utility/enable_if.hpp>
+
+#include "ipl_image_wrapper.hpp"
+
+namespace boost { namespace gil { namespace opencv {
+
+typedef bit_aligned_image3_type<  5,  5,  5, bgr_layout_t >::type bgr555_image_t;
+typedef bgr555_image_t::view_t::value_type bgr555_pixel_t;
+
+typedef bit_aligned_image3_type<  5,  6,  5, bgr_layout_t >::type bgr565_image_t;
+typedef bgr565_image_t::view_t::value_type bgr565_pixel_t;
+
+template< typename PixelRefT>
+struct is_bit_aligned : mpl::false_{};
+
+template <typename B, typename C, typename L, bool M>  
+struct is_bit_aligned<bit_aligned_pixel_reference<B,C,L,M> > : mpl::true_{};
+
+template <typename B, typename C, typename L, bool M>  
+struct is_bit_aligned<const bit_aligned_pixel_reference<B,C,L,M> > : mpl::true_{};
+
+template <typename B, typename C, typename L>  
+struct is_bit_aligned<packed_pixel<B,C,L> > : mpl::true_{};
+
+template <typename B, typename C, typename L>  
+struct is_bit_aligned<const packed_pixel<B,C,L> > : mpl::true_{};
+
+/*
+// not implemented
+#define  CV_BGR2YCrCb   36
+#define  CV_RGB2YCrCb   37
+#define  CV_YCrCb2BGR   38
+#define  CV_YCrCb2RGB   39
+
+#define  CV_BayerBG2BGR 46
+#define  CV_BayerGB2BGR 47
+#define  CV_BayerRG2BGR 48
+#define  CV_BayerGR2BGR 49
+
+#define  CV_BayerBG2RGB CV_BayerRG2BGR
+#define  CV_BayerGB2RGB CV_BayerGR2BGR
+#define  CV_BayerRG2RGB CV_BayerBG2BGR
+#define  CV_BayerGR2RGB CV_BayerGB2BGR
+
+#define  CV_BGR2Luv     50
+#define  CV_RGB2Luv     51
+#define  CV_Luv2BGR     58
+#define  CV_Luv2RGB     59
+*/
+
+
+template< typename T1, typename T2 > struct is_supported : boost::mpl::false_ {};
+
+// 3 channel to 4 channel with equal layout
+template<> struct is_supported< bgr_layout_t, bgra_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR2BGRA; };
+template<> struct is_supported< rgb_layout_t, rgba_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGB2RGBA; };
+
+// 4 channel to 3 channel with equal layout
+template<> struct is_supported< bgra_layout_t, bgr_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGRA2BGR; };
+template<> struct is_supported< rgba_layout_t, rgb_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGBA2RGB; };
+
+// 3 channel to 4 channel with different layout
+template<> struct is_supported< bgr_layout_t, rgba_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR2RGBA; };
+template<> struct is_supported< rgb_layout_t, bgra_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGB2BGRA; };
+
+// 4 channel to 3 channel with different layout
+template<> struct is_supported< rgba_layout_t, bgr_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGBA2BGR; };
+template<> struct is_supported< bgra_layout_t, rgb_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGB2BGRA; };
+
+// 3 channel to 3 channel with different layout
+template<> struct is_supported< bgr_layout_t, rgb_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGBA2BGR; };
+template<> struct is_supported< rgb_layout_t, bgr_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGB2BGR; };
+
+// 4 channel to 4 channel with different layout
+template<> struct is_supported< bgra_layout_t, rgba_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGRA2RGBA; };
+template<> struct is_supported< rgba_layout_t, bgra_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGBA2BGRA; };
+
+// BGR to Gray
+template<> struct is_supported< bgr_layout_t, gray_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR2GRAY; };
+
+// RGB to Gray
+template<> struct is_supported< rgb_layout_t, gray_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGB2GRAY; };
+
+// Gray to BGR
+template<> struct is_supported< gray_layout_t, bgr_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_GRAY2BGR; };
+
+// Gray to RGB
+template<> struct is_supported< gray_layout_t, rgb_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_GRAY2RGB; };
+
+// Gray to BGRA
+template<> struct is_supported< gray_layout_t, bgra_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_GRAY2BGRA; };
+
+// Gray to RGBA
+template<> struct is_supported< gray_layout_t, rgba_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_GRAY2RGBA; };
+
+// BGRA to Gray
+template<> struct is_supported< bgra_layout_t, gray_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGRA2GRAY; };
+
+// RGBA to Gray
+template<> struct is_supported< rgba_layout_t, gray_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGBA2GRAY; };
+
+// BGR to BGR565
+template<> struct is_supported< bgr_layout_t, bgr565_pixel_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR2BGR565; };
+
+// RGB to BGR565
+template<> struct is_supported< rgb_layout_t, bgr565_pixel_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGB2BGR565; };
+
+// BGR565 to BGR
+template<> struct is_supported< bgr565_pixel_t, bgr_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR5652BGR; };
+
+// BGR565 to RGB
+template<> struct is_supported< bgr565_pixel_t, rgb_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR5652RGB; };
+
+// BGRA to BGR565
+template<> struct is_supported< bgra_layout_t, bgr565_pixel_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGRA2BGR565; };
+
+// RGBA to BGR565
+template<> struct is_supported< rgba_layout_t, bgr565_pixel_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGBA2BGR565; };
+
+// BGR565 to BGRA
+template<> struct is_supported< bgr565_pixel_t, bgra_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR5652BGRA; };
+
+// BGR565 to RGBA
+template<> struct is_supported< bgr565_pixel_t, rgba_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR5652RGBA; };
+
+// Gray to BGR565
+template<> struct is_supported< gray_layout_t, bgr565_pixel_t > : public boost::mpl::true_ 
+{ static const int code = CV_GRAY2BGR565; };
+
+// BGR565 to Gray
+template<> struct is_supported< bgr565_pixel_t, gray_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR5652GRAY; };
+
+// BGR to BGR555
+template<> struct is_supported< bgr_layout_t, bgr555_pixel_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR2BGR555; };
+
+// RGB to BGR555
+template<> struct is_supported< rgb_layout_t, bgr555_pixel_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGB2BGR555; };
+
+// BGR555 to BGR
+template<> struct is_supported< bgr555_pixel_t, bgr_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR5552BGR; };
+
+// BGR555 to RGB
+template<> struct is_supported< bgr555_pixel_t, rgb_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR5552RGB; };
+
+// BGR to BGR555
+template<> struct is_supported< bgra_layout_t, bgr555_pixel_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGRA2BGR555; };
+
+// RGBA to BGR555
+template<> struct is_supported< rgba_layout_t, bgr555_pixel_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGBA2BGR555; };
+
+// BGR555 to BGRA
+template<> struct is_supported< bgr555_pixel_t, bgra_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR5552BGRA; };
+
+// BGR555 to RGBA
+template<> struct is_supported< bgr555_pixel_t, rgba_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR5552RGBA; };
+
+// Gray to BGR555
+template<> struct is_supported< gray_layout_t, bgr555_pixel_t > : public boost::mpl::true_ 
+{ static const int code = CV_GRAY2BGR555; };
+
+// BGR555 to Gray
+template<> struct is_supported< bgr555_pixel_t, gray_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR5552GRAY; };
+
+
+// BGR to XYZ
+template<> struct is_supported< bgr_layout_t, xyz_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR2XYZ; };
+
+// RGB to XYZ
+template<> struct is_supported< rgb_layout_t, xyz_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGB2XYZ; };
+
+// XYZ to BGR
+template<> struct is_supported< xyz_layout_t, bgr_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_XYZ2BGR; };
+
+// XYZ to RGB
+template<> struct is_supported< xyz_layout_t, rgb_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_XYZ2RGB; };
+
+// BGR to HSV
+template<> struct is_supported< bgr_layout_t, hsv_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR2HSV; };
+
+// RGB to HSV
+template<> struct is_supported< rgb_layout_t, hsv_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGB2HSV; };
+
+// BGR to Lab
+template<> struct is_supported< bgr_layout_t, lab_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR2Lab; };
+
+// RGB to Lab
+template<> struct is_supported< rgb_layout_t, lab_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGB2Lab; };
+
+// BGR to HLS
+template<> struct is_supported< bgr_layout_t, hsl_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_BGR2HLS; };
+
+// RGB to HLS
+template<> struct is_supported< rgb_layout_t, hsl_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_RGB2HLS; };
+
+// HSV to BGR
+template<> struct is_supported< hsv_layout_t, bgr_layout_t > : public boost::mpl::true_
+{ static const int code = CV_HSV2BGR; };
+
+// HSV to RGB
+template<> struct is_supported< hsv_layout_t, rgb_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_HSV2RGB; };
+
+// Lab to BGR
+template<> struct is_supported< lab_layout_t, bgr_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_Lab2BGR; };
+
+// Lab to RGB
+template<> struct is_supported< lab_layout_t, rgb_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_Lab2RGB; };
+
+// HLS to BGR
+template<> struct is_supported< hsl_layout_t, bgr_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_HLS2BGR; };
+
+// HLS to RGB
+template<> struct is_supported< hsl_layout_t, rgb_layout_t > : public boost::mpl::true_ 
+{ static const int code = CV_HLS2RGB; };
+
+// Allowed channel types
+
+template< typename Channel > struct allowed_channel_type : boost::mpl::false_ {};
+template <> struct allowed_channel_type< bits8   > : boost::mpl::true_ {};
+template <> struct allowed_channel_type< bits16  > : boost::mpl::true_ {};
+template <> struct allowed_channel_type< bits32f > : boost::mpl::true_ {};
+
+template< typename Is_Supported >
+inline
+void cvtcolor_impl( const ipl_image_wrapper& src
+                  , ipl_image_wrapper&       dst
+                  , const Is_Supported&
+                  , typename boost::enable_if< typename boost::is_base_of< boost::mpl::false_
+                                                                         , Is_Supported
+                                                                         >::type
+                                             >::type* ptr = 0
+                  )
+{
+    // conversion isn't supported
+    BOOST_STATIC_ASSERT(( 0 ));
+}
+
+template< typename Is_Supported >
+inline
+void cvtcolor_impl( const ipl_image_wrapper& src
+                  , ipl_image_wrapper&       dst
+                  , const Is_Supported&
+                  , typename boost::enable_if< typename boost::is_base_of< boost::mpl::true_
+                                                                         , Is_Supported
+                                                                         >::type
+                                             >::type* ptr = 0
+                  )
+{
+    cvCvtColor( src.get()
+              , dst.get()
+              , Is_Supported::code
+              );
+}
+
+template< typename View_Src
+        , typename View_Dst
+        >
+inline
+void cvtcolor( View_Src src
+             , View_Dst dst
+             , const boost::mpl::true_& // is bit aligned
+             )
+{
+    typedef typename View_Src::value_type::layout_t SrcLayout;
+    typedef typename View_Dst::value_type::layout_t DstLayout;
+
+    typedef typename boost::mpl::if_< is_bit_aligned< View_Src::value_type >
+                                    , View_Src::value_type
+                                    , View_Src::value_type::layout_t
+                                    >::type src_t;
+
+    typedef typename boost::mpl::if_< is_bit_aligned< View_Dst::value_type >
+                                    , View_Dst::value_type
+                                    , View_Dst::value_type::layout_t
+                                    >::type dst_t;
+
+    /// @todo: Not implemented yet. Make sure we can create bit aligned ipl images.
+    BOOST_STATIC_ASSERT(( 0 ));
+
+/*
+    ipl_image_wrapper src_ipl = create_ipl_image( src );
+    ipl_image_wrapper dst_ipl = create_ipl_image( dst );
+
+    cvtcolor_impl( src_ipl
+                 , dst_ipl
+                 , is_supported< src_t
+                               , dst_t
+                               >()
+                 );
+*/
+}
+
+template< typename View_Src
+        , typename View_Dst
+        >
+inline
+void cvtcolor( View_Src src
+             , View_Dst dst
+             , const boost::mpl::false_& // is bit aligned
+             )
+{
+    typedef typename channel_type< View_Src >::type src_channel_t;
+    typedef typename channel_type< View_Dst >::type dst_channel_t;
+
+    // Only 8u, 16u, and 32f is allowed.
+    BOOST_STATIC_ASSERT(( boost::mpl::or_< allowed_channel_type< src_channel_t >
+                                         , allowed_channel_type< dst_channel_t >
+                                         >::value ));
+
+    // Channel depths need to match.
+    BOOST_STATIC_ASSERT(( boost::is_same< src_channel_t
+                                        , dst_channel_t >::value ));
+
+    typedef typename View_Src::value_type::layout_t SrcLayout;
+    typedef typename View_Dst::value_type::layout_t DstLayout;
+
+    ipl_image_wrapper src_ipl = create_ipl_image( src );
+    ipl_image_wrapper dst_ipl = create_ipl_image( dst );
+
+    cvtcolor_impl( src_ipl
+                 , dst_ipl
+                 , is_supported< SrcLayout
+                               , DstLayout
+                               >()
+                 );
+}
+
+template< typename View_Src
+        , typename View_Dst
+        >
+inline
+void cvtcolor( View_Src src
+             , View_Dst dst
+             )
+{
+    if(  std::max( src.dimensions().x, dst.dimensions().x ) == 0
+      && std::max( src.dimensions().y, dst.dimensions().y ) == 0
+      )
+    {
+        throw std::exception( "Image doesn't have dimensions ( empty image )." );
+    }
+    
+
+
+    if( src.dimensions() != dst.dimensions() )
+    {
+        throw std::exception( "Image's dimensions don't match." );
+    }
+
+    // There is some special code for dealing with bit_aligned images.
+    // OpenCV seems only to support rgb|bgr555 or rgb|bgr565 images.
+    typedef boost::mpl::or_< is_bit_aligned< View_Src::value_type >::type
+                           , is_bit_aligned< View_Dst::value_type >::type
+                           >::type is_bit_aligned_t;
+
+    cvtcolor( src
+            , dst
+            , is_bit_aligned_t()
+            );
+}
+
+} // namespace opencv
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_OPENCV_CONVERT_COLOR_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/opencv/convert_scale.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/opencv/convert_scale.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,130 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_OPENCV_CONVERT_SCALE_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_OPENCV_CONVERT_SCALE_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/static_assert.hpp>
+#include <boost/type_traits.hpp>
+
+#include <boost/gil/gil_all.hpp>
+
+#include "ipl_image_wrapper.hpp"
+
+namespace boost { namespace gil { namespace opencv {
+
+inline
+void convert_scale_( const ipl_image_wrapper& src
+                   , ipl_image_wrapper&        dst
+                   , const double&             scale = 1.0
+                   , const double&             shift = 0.0
+                   )
+{
+   cvConvertScale( src.get()
+                 , dst.get()
+                 , scale
+                 , shift
+                 );
+}
+
+template< typename View_Src
+        , typename View_Dst
+        >
+inline
+void convert_scale( View_Src&     src
+                  , View_Dst&     dst
+                  , const double& scale = 1.0
+                  , const double& shift = 0.0
+                  )
+{
+/*
+    // color spaces must be equal
+    BOOST_STATIC_ASSERT(( boost::is_same< typename color_space_type< View_Src >::type
+                                        , typename color_space_type< View_Dst >::type
+                                        >::type::value
+                       ));
+
+    // destination image should have 8 bit unsigned channels
+    BOOST_STATIC_ASSERT(( boost::is_same< bits8
+                                        , typename channel_type< View_Dst >::type
+                                        >::type::value
+                       ));
+*/
+
+    ipl_image_wrapper src_ipl = create_ipl_image( src );
+    ipl_image_wrapper dst_ipl = create_ipl_image( dst );
+
+    convert_scale_( src_ipl
+                  , dst_ipl
+                  , scale
+                  , shift
+                  );
+}
+
+
+inline
+void convert_scale_abs_( const ipl_image_wrapper& src
+                      , ipl_image_wrapper&        dst
+                      , const double&             scale = 1.0
+                      , const double&             shift = 0.0
+                      )
+{
+   cvConvertScaleAbs( src.get()
+                    , dst.get()
+                    , scale
+                    , shift
+                    );
+}
+
+template< typename View_Src
+        , typename View_Dst
+        >
+inline
+void convert_scale_abs( View_Src&     src
+                      , View_Dst&     dst
+                      , const double& scale = 1.0
+                      , const double& shift = 0.0
+                      )
+{
+    // color spaces must be equal
+    BOOST_STATIC_ASSERT(( boost::is_same< typename color_space_type< View_Src >::type
+                                        , typename color_space_type< View_Dst >::type
+                                        >::type::value
+                       ));
+
+    // destination image should have 8 bit unsigned channels
+    BOOST_STATIC_ASSERT(( boost::is_same< bits8
+                                        , typename channel_type< View_Dst >::type
+                                        >::type::value
+                       ));
+
+    ipl_image_wrapper src_ipl = create_ipl_image( src );
+    ipl_image_wrapper dst_ipl = create_ipl_image( dst );
+
+    convert_scale_abs_( src_ipl
+                      , dst_ipl
+                      , scale
+                      , shift
+                      );
+}
+
+} // namespace opencv
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_OPENCV_CONVERT_SCALE_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/opencv/drawing.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/opencv/drawing.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,352 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_OPENCV_DRAWING_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_OPENCV_DRAWING_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost\scoped_array.hpp>
+
+#include "ipl_image_wrapper.hpp"
+
+namespace boost { namespace gil { namespace opencv {
+
+struct four_connected_line  : boost::mpl::int_< 4 > {};
+struct eight_connected_line : boost::mpl::int_< 8 > {};
+
+struct cv_fill : boost::mpl::int_< CV_FILLED > {};
+
+struct cv_aa : boost::mpl::int_< CV_AA > {};
+
+
+/// When chaining operators we don't want to reconvert to
+/// ipl_image all the time.
+
+/// rectangle
+
+// Use cv_fill as thickness to fill the rectangle.
+
+template< typename Color
+        , typename Line_Type
+        >
+inline
+void drawRectangle( ipl_image_wrapper&  ipl_image
+                  , point_t             start
+                  , point_t             end
+                  , const Color&        color
+                  , std::size_t         thickness
+                  , const Line_Type&    
+                  )
+{
+   cvRectangle( ipl_image.get()
+              , make_cvPoint ( start )
+              , make_cvPoint ( end   )
+              , make_cvScalar( color )
+              , thickness
+              , typename Line_Type::type::value
+              );
+}
+
+template< typename View
+        , typename Line_Type
+        >
+inline
+void drawRectangle( View                      view
+                  , point_t                   start
+                  , point_t                   end
+                  , typename View::value_type color
+                  , std::size_t               thickness
+                  , const Line_Type&          line_type )
+{
+   drawRectangle( create_ipl_image( view )
+                , start
+                , end
+                , color
+                , thickness
+                , line_type
+                );
+}
+
+/// circle
+
+template< typename Color
+        , typename Line_Type
+        >
+inline
+void drawCircle( ipl_image_wrapper& ipl_image
+               , const point_t&     center
+               , std::size_t        radius
+               , const Color&       color
+               , std::size_t        thickness
+               , const Line_Type&
+               )
+{
+   cvCircle( ipl_image.get()
+           , make_cvPoint( center )
+           , radius
+           , make_cvScalar( color )
+           , thickness
+           , typename Line_Type::type::value
+           );
+}
+
+template< typename View
+        , typename Line_Type
+        >
+inline
+void drawCircle( View                      view
+               , point_t                   center
+               , std::size_t               radius
+               , typename View::value_type color
+               , std::size_t               thickness
+               , const Line_Type&          line_type
+               )
+{
+   drawCircle( create_ipl_image( view )
+             , center
+             , radius
+             , color
+             , thickness
+             , line_type
+             );
+}
+
+/// ellipse
+
+template< typename Color
+        , typename Line_Type
+        >
+inline
+void drawEllipse( ipl_image_wrapper& ipl_image
+                , const point_t&     center
+                , const point_t&     axes
+                , const double&      angle
+                , const double&      start_angle
+                , const double&      end_angle
+                , const Color&       color
+                , std::size_t        thickness
+                , const Line_Type&
+                )
+{
+   cvEllipse( ipl_image.get()
+            , make_cvPoint( center )
+            , make_cvSize ( axes   )
+            , angle
+            , start_angle
+            , end_angle
+            , make_cvScalar( color )
+            , thickness
+            , typename Line_Type::type::value
+            );
+}
+
+template< typename View
+        , typename Line_Type
+        >
+inline
+void drawEllipse( View                      view
+                , const point_t&            center
+                , const point_t&            axes
+                , const double&             angle
+                , const double&             start_angle
+                , const double&             end_angle
+                , typename View::value_type color
+                , std::size_t               thickness
+                , const Line_Type&          line_type
+                )
+{
+   drawEllipse( create_ipl_image( view )
+              , center
+              , axes
+              , angle
+              , start_angle
+              , end_angle
+              , color
+              , thickness
+              , line_type
+              );
+}
+
+/// line
+
+template< typename Color
+        , typename Line_Type
+        >
+inline
+void drawLine( ipl_image_wrapper& ipl_image
+             , point_t            start
+             , point_t            end
+             , Color              color
+             , std::size_t        line_width
+             , const Line_Type&
+             )
+{
+   cvLine( ipl_image.get()
+         , make_cvPoint( start )
+         , make_cvPoint( end )
+         , make_cvScalar( color )
+         , line_width
+         , Line_Type::type::value
+         );
+}
+
+template< typename View
+        , typename Line_Type
+        >
+inline
+void drawLine( View&                     view
+             , point_t                   start
+             , point_t                   end
+             , typename View::value_type color
+             , std::size_t               line_width
+             , const Line_Type&          line_type
+             )
+{
+   drawLine( create_ipl_image( view )
+           , start
+           , end
+           , color
+           , line_width
+           , line_type
+           );
+}
+
+/// polyline
+
+template< typename Color
+        , typename Line_Type
+        >
+inline
+void drawPolyLine( ipl_image_wrapper& ipl_image
+                 , const curve_vec_t& curves
+                 , bool               is_closed
+                 , Color              color
+                 , std::size_t        thickness
+                 , const Line_Type&
+                 )
+{
+    const std::size_t num_curves = curves.size();
+
+    std::vector<int> num_points_per_curve( num_curves );
+
+    for( std::size_t i = 0; i < num_curves; ++i )
+    {
+      num_points_per_curve[i] = curves[i].size();
+    }
+
+    cvpoint_array_vec_t pp( num_curves );
+    boost::scoped_array<CvPoint*> curve_array( new CvPoint*[num_curves] );
+
+    for( std::size_t i = 0; i < num_curves; ++i )
+    {
+        pp[i] = make_cvPoint_array( curves[i] );
+
+        curve_array[i] = pp[i].get();
+    }
+   
+    cvPolyLine( ipl_image.get()
+              , curve_array.get()  // needs to be pointer to C array of CvPoints.
+              , &num_points_per_curve.front()
+              , curves.size()
+              , is_closed
+              , make_cvScalar( color )
+              , thickness
+              , Line_Type::type::value
+              );
+}
+
+template< typename View
+        , typename Line_Type
+        >
+inline
+void drawPolyLine( View&                     view
+                 , const curve_vec_t&        curves
+                 , bool                      is_closed
+                 , typename View::value_type color
+                 , std::size_t               thickness
+                 , const Line_Type&          line_type
+                 )
+{
+   drawPolyLine( create_ipl_image( view )
+               , curves
+               , is_closed
+               , color
+               , thickness
+               , line_type
+               );
+}
+
+template< typename Color
+        , typename Line_Type
+        >
+inline
+void drawFillPoly( ipl_image_wrapper& ipl_image
+                 , const curve_vec_t& curves
+                 , const Color&       color
+                 , const Line_Type&
+                 )
+{
+   const std::size_t num_curves = curves.size();
+
+    std::vector<int> num_points_per_curve( num_curves );
+
+    for( std::size_t i = 0; i < num_curves; ++i )
+    {
+      num_points_per_curve[i] = curves[i].size();
+    }
+
+    cvpoint_array_vec_t pp( num_curves );
+
+    boost::scoped_array<CvPoint*> curve_array( new CvPoint*[num_curves] );
+
+    for( std::size_t i = 0; i < num_curves; ++i )
+    {
+        pp[i] = make_cvPoint_array( curves[i] );
+
+        curve_array[i] = pp[i].get();
+    }
+   
+    cvFillPoly( ipl_image.get()
+              , curve_array.get()           // needs to be pointer to C array of CvPoints.
+              , &num_points_per_curve.front()
+              , curves.size()
+              , make_cvScalar( color )
+              );
+}
+
+template< typename View
+        , typename Line_Type
+        >
+inline
+void drawFillPoly( View&                     view
+                 , const curve_vec_t&        curves
+                 , typename View::value_type color
+                 , const Line_Type&          line_type
+                 )
+{
+   drawFillPoly( create_ipl_image( view )
+               , curves
+               , color
+               , line_type
+               );
+}
+
+} // namespace opencv
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_OPENCV_DRAWING_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/opencv/edge_detection.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/opencv/edge_detection.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,266 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_OPENCV_EDGE_DETECTION_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_OPENCV_EDGE_DETECTION_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/type_traits/is_base_of.hpp>
+
+#include <boost/utility/enable_if.hpp>
+
+#include "ipl_image_wrapper.hpp"
+
+namespace boost { namespace gil { namespace opencv {
+
+struct aperture_base {};
+
+struct aperture1 : aperture_base, boost::mpl::int_< 1 > {};
+struct aperture3 : aperture_base, boost::mpl::int_< 3 > {};
+struct aperture5 : aperture_base, boost::mpl::int_< 5 > {};
+struct aperture7 : aperture_base, boost::mpl::int_< 7 > {};
+struct aperture_scharr : aperture_base, boost::mpl::int_< CV_SCHARR > {};
+
+// default template parameter for function, only for classes
+template< typename Aperture >
+inline
+void sobel( const ipl_image_wrapper& src
+          , ipl_image_wrapper&       dst
+          , const Aperture&
+          , size_t                   x_order = 1
+          , size_t                   y_order = 0
+          , typename boost::enable_if< typename boost::is_base_of< aperture_base
+                                                                 , Aperture
+                                                                 >::type
+                                     >::type* ptr = 0
+          )
+{
+   cvSobel( src.get()
+          , dst.get()
+          , x_order
+          , y_order
+          , Aperture::type::value
+          );
+}
+
+template< typename View
+        , typename Aperture
+        >
+inline
+void sobel( View                  src
+          , View                  dst
+          , const Aperture&       aperture
+          , std::size_t x_order = 1
+          , std::size_t y_order = 0
+          , typename boost::enable_if< typename boost::is_base_of< aperture_base
+                                                                 , Aperture
+                                                                 >::type
+                                     >::type* ptr = 0
+          )
+{
+    ipl_image_wrapper src_ipl = create_ipl_image( src );
+    ipl_image_wrapper dst_ipl = create_ipl_image( dst );
+
+    sobel( src_ipl
+         , dst_ipl
+         , aperture
+         , x_order
+         , y_order
+         );
+}
+
+template< typename Aperture >
+inline
+void laplace( const ipl_image_wrapper& src
+            , ipl_image_wrapper&       dst
+            , const Aperture&
+            , typename boost::enable_if< typename boost::is_base_of< aperture_base
+                                                                   , Aperture
+                                                                   >::type
+                                       >::type* ptr = 0
+            )
+{
+   cvLaplace( src.get()
+            , dst.get()
+            , Aperture::type::value
+            );
+}
+
+template< typename View_Src
+        , typename View_Dst
+        , typename Aperture
+        >
+inline
+void laplace( View_Src        src
+            , View_Dst        dst
+            , const Aperture& aperture
+            , typename boost::enable_if< typename boost::is_base_of< aperture_base
+                                                                   , Aperture
+                                                                   >::type
+                                       >::type* ptr = 0
+            )
+{
+    ipl_image_wrapper src_ipl = create_ipl_image( src );
+    ipl_image_wrapper dst_ipl = create_ipl_image( dst );
+
+    laplace( src_ipl
+           , dst_ipl
+           , aperture
+           );
+}
+
+template< typename Aperture >
+inline
+void canny( const ipl_image_wrapper& src
+          , ipl_image_wrapper&       dst
+          , double                   threshold1
+          , double                   threshold2
+          , const Aperture&
+          , typename boost::enable_if< typename boost::is_base_of< aperture_base
+                                                                 , Aperture
+                                                                 >::type
+                                       >::type* ptr = 0
+            )
+{
+   cvCanny( src.get()
+          , dst.get()
+          , threshold1
+          , threshold2
+          , Aperture::type::value
+          );
+}
+
+template< typename View
+        , typename Aperture
+        >
+inline
+void canny( View            src
+          , View            dst
+          , double          threshold1
+          , double          threshold2
+          , const Aperture& aperture
+          , typename boost::enable_if< typename boost::is_base_of< aperture_base
+                                                                 , Aperture
+                                                                 >::type
+                                     >::type* ptr = 0
+            )
+{
+    ipl_image_wrapper src_ipl = create_ipl_image( src );
+    ipl_image_wrapper dst_ipl = create_ipl_image( dst );
+
+    canny( src_ipl
+         , dst_ipl
+         , threshold1
+         , threshold2
+         , aperture
+         );
+}
+
+template< typename Aperture >
+inline
+void precorner_detect( const ipl_image_wrapper& src
+                     , ipl_image_wrapper&       dst
+                     , const Aperture&
+                     , typename boost::enable_if< typename boost::is_base_of< aperture_base
+                                                                            , Aperture
+                                                                            >::type
+                                                >::type* ptr = 0
+                     )
+{
+   cvPreCornerDetect( src.get()
+                    , dst.get()
+                    , Aperture::type::value
+                    );
+}
+
+template< typename View_Src
+        , typename View_Dst
+        , typename Aperture
+        >
+inline
+void precorner_detect( View_Src        src
+                     , View_Dst        dst
+                     , const Aperture& aperture
+                     , typename boost::enable_if< typename boost::is_base_of< aperture_base
+                                                                            , Aperture
+                                                                            >::type
+                                                >::type* ptr = 0
+                      )
+{
+    ipl_image_wrapper src_ipl = create_ipl_image( src );
+    ipl_image_wrapper dst_ipl = create_ipl_image( dst );
+
+    precorner_detect( src_ipl
+                    , dst_ipl
+                    , aperture
+                    );
+}
+
+template< typename Aperture >
+inline
+void corner_eigen_vals_and_vecs( const ipl_image_wrapper& src
+                               , ipl_image_wrapper&       dst
+                               , const std::size_t        block_size
+                               , const Aperture&
+                               , typename boost::enable_if< typename boost::is_base_of< aperture_base
+                                                                                      , Aperture
+                                                                                      >::type
+                                                          >::type* ptr = 0
+                               )
+{
+    if( src.get()->width * 6 != dst.get()->width )
+    {
+        throw std::runtime_error( "Destination image must be 6 times wider." );
+    }
+
+    cvCornerEigenValsAndVecs( src.get()
+                            , dst.get()
+                            , block_size
+                            , Aperture::type::value
+                            );
+}
+
+template< typename View_Src
+        , typename View_Dst
+        , typename Aperture
+        >
+inline
+void corner_eigen_vals_and_vecs( View_Src          src
+                               , View_Dst          dst
+                               , const std::size_t block_size
+                               , const Aperture&   aperture
+                               , typename boost::enable_if< typename boost::is_base_of< aperture_base
+                                                                                      , Aperture
+                                                                                      >::type
+                                                          >::type* ptr = 0
+                               )
+{
+    ipl_image_wrapper src_ipl = create_ipl_image( src );
+    ipl_image_wrapper dst_ipl = create_ipl_image( dst );
+
+    corner_eigen_vals_and_vecs( src_ipl
+                              , dst_ipl
+                              , block_size
+                              , aperture
+                              );
+}
+
+} // namespace opencv
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_OPENCV_EDGE_DETECTION_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/opencv/ipl_image_wrapper.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/opencv/ipl_image_wrapper.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,98 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_OPENCV_IPL_IMAGE_WRAPPER_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_OPENCV_IPL_IMAGE_WRAPPER_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost\shared_ptr.hpp>
+#include <boost\gil\gil_all.hpp>
+
+#include "utilities.hpp"
+
+namespace boost { namespace gil { namespace opencv {
+
+template < typename Channel > struct ipl_channel_type : boost::mpl::false_ {};
+template<> struct ipl_channel_type< bits8 >   : boost::mpl::int_< IPL_DEPTH_8U  > {};
+template<> struct ipl_channel_type< bits16 >  : boost::mpl::int_< IPL_DEPTH_16U > {};
+template<> struct ipl_channel_type< bits32f > : boost::mpl::int_< IPL_DEPTH_32F > {};
+template<> struct ipl_channel_type< double >  : boost::mpl::int_< IPL_DEPTH_64F > {};
+template<> struct ipl_channel_type< bits8s >  : boost::mpl::int_< IPL_DEPTH_8S  > {};
+template<> struct ipl_channel_type< bits16s > : boost::mpl::int_< IPL_DEPTH_16S > {};
+template<> struct ipl_channel_type< bits32s > : boost::mpl::int_< IPL_DEPTH_32S > {};
+
+
+/**
+ *
+ * ipl_image_wrapper encloses a IplImage pointer. Value semantics, like
+ * copying, are supported by using shared_ptr.
+ *
+ **/
+class ipl_image_wrapper
+{
+public:
+
+    typedef boost::shared_ptr< IplImage > ipl_image_ptr_t;
+
+public:
+    ipl_image_wrapper() {}
+    ipl_image_wrapper( IplImage* img ) : _img( img, ipl_deleter ) {}
+
+    IplImage*       get()       { return _img.get(); }
+    const IplImage* get() const { return _img.get(); }
+
+private:
+
+    static void ipl_deleter( IplImage* ipl_img )
+    {
+        if( ipl_img )
+        {
+            cvReleaseImageHeader( &ipl_img );
+        }
+    }
+
+   ipl_image_ptr_t _img;
+};
+
+template< typename View >
+inline
+ipl_image_wrapper create_ipl_image( View view )
+{
+    typedef typename channel_type< View >::type channel_t;
+
+    IplImage* img;
+
+    if(( img = cvCreateImageHeader( make_cvSize( view.dimensions() )
+                                  , ipl_channel_type<channel_t>::type::value
+                                  , num_channels<View>::value
+                                  )) == NULL )
+    {
+        throw std::runtime_error( "Cannot create IPL image." );
+    }
+
+    cvSetData( img
+             , interleaved_view_get_raw_data( view )
+             , num_channels<View>::value * view.width() * sizeof( channel_t ) );
+
+    return ipl_image_wrapper( img );
+}
+
+} // namespace opencv
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_OPENCV_IPL_IMAGE_WRAPPER_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/opencv/opencv_all.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/opencv/opencv_all.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,30 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_OPENCV_ALL_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_OPENCV_ALL_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "convert_color.hpp"
+#include "convert_scale.hpp"
+#include "drawing.hpp"
+#include "edge_detection.hpp"
+#include "resize.hpp"
+#include "smooth.hpp"
+#include "text.hpp"
+#include "utilities.hpp"
+#endif // BOOST_GIL_EXTENSION_OPENCV_UTILITIES_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/opencv/resize.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/opencv/resize.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,74 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_OPENCV_RESIZE_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_OPENCV_RESIZE_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include "ipl_image_wrapper.hpp"
+
+namespace boost { namespace gil { namespace opencv {
+
+struct interpolation_base {};
+
+struct nearest_neigbor : interpolation_base, boost::mpl::int_< CV_INTER_NN >     {};
+struct bilinear        : interpolation_base, boost::mpl::int_< CV_INTER_LINEAR > {};
+struct area            : interpolation_base, boost::mpl::int_< CV_INTER_AREA >   {};
+struct bicubic         : interpolation_base, boost::mpl::int_< CV_INTER_CUBIC >  {};
+
+template< typename Interpolation >
+void resize( const ipl_image_wrapper& src
+           , ipl_image_wrapper&       dst
+           , const Interpolation& 
+           , typename boost::enable_if< typename boost::is_base_of< interpolation_base 
+                                                                  , Interpolation
+                                                                  >::type
+                                      >::type* ptr = 0
+           )
+{
+   cvResize( src.get()
+           , dst.get()
+           , Interpolation::type::value
+           );
+}
+
+template< typename View
+        , typename Interpolation
+        >
+void resize( View                 src
+           , View                 dst
+           , const Interpolation& interpolation
+           , typename boost::enable_if< typename boost::is_base_of< interpolation_base 
+                                                                  , Interpolation
+                                                                  >::type
+                                      >::type* ptr = 0
+           )
+{
+    ipl_image_wrapper src_ipl = create_ipl_image( src );
+    ipl_image_wrapper dst_ipl = create_ipl_image( dst );
+
+    resize( src_ipl
+          , dst_ipl
+          , interpolation
+          );
+}
+
+} // namespace opencv
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_OPENCV_RESIZE_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/opencv/smooth.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/opencv/smooth.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,92 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_OPENCV_SMOOTH_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_OPENCV_SMOOTH_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/type_traits/is_base_of.hpp>
+
+#include <boost/utility/enable_if.hpp>
+
+#include "ipl_image_wrapper.hpp"
+
+namespace boost { namespace gil { namespace opencv {
+
+struct smooth_base {};
+
+struct blur_no_scale : smooth_base, boost::mpl::int_< CV_BLUR_NO_SCALE > {};
+struct blur          : smooth_base, boost::mpl::int_< CV_BLUR          > {};
+struct gaussian      : smooth_base, boost::mpl::int_< CV_GAUSSIAN      > {};
+struct median        : smooth_base, boost::mpl::int_< CV_MEDIAN        > {};
+struct bilateral     : smooth_base, boost::mpl::int_< CV_BILATERAL     > {};
+
+template< typename Smooth >
+void smooth( const ipl_image_wrapper& src
+           , ipl_image_wrapper&       dst
+           , const Smooth&            smooth
+           , size_t                   param1 = 3
+           , size_t                   param2 = 0
+           , size_t                   param3 = 0
+           , size_t                   param4 = 0
+           , typename boost::enable_if< typename boost::is_base_of< smooth_base 
+                                                                  , Smooth
+                                                                  >::type
+                                      >::type* ptr = 0
+           )
+           
+{
+   cvSmooth( src.get()
+           , dst.get()
+           , Smooth::type::value
+           , param1
+           , param2
+           , param3
+           , param4
+           );
+}
+
+template< typename View
+        , typename Smooth
+        >
+void smooth( View          src
+           , View          dst
+           , const Smooth& smooth_type
+           , size_t        param1 = 3
+           , size_t        param2 = 0
+           , size_t        param3 = 0
+           , size_t        param4 = 0
+           , typename boost::enable_if< typename boost::is_base_of< smooth_base 
+                                                                  , Smooth
+                                                                  >::type
+                                      >::type* ptr = 0
+           )
+{
+    ipl_image_wrapper src_ipl = create_ipl_image( src );
+    ipl_image_wrapper dst_ipl = create_ipl_image( dst );
+
+    smooth( src_ipl
+          , dst_ipl
+          , smooth_type
+          );
+}
+
+} // namespace opencv
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_OPENCV_SMOOTH_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/opencv/text.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/opencv/text.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,130 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_OPENCV_TEXT_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_OPENCV_TEXT_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost\shared_ptr.hpp>
+
+#include "ipl_image_wrapper.hpp"
+#include "drawing.hpp"
+
+namespace boost { namespace gil { namespace opencv {
+
+struct font_hershey_simplex        : boost::mpl::int_< CV_FONT_HERSHEY_SIMPLEX > {};
+struct font_hershey_plain          : boost::mpl::int_< CV_FONT_HERSHEY_PLAIN > {};
+struct font_hershey_duplex         : boost::mpl::int_< CV_FONT_HERSHEY_DUPLEX > {};
+struct font_hershey_complex        : boost::mpl::int_< CV_FONT_HERSHEY_COMPLEX > {};
+struct font_hershey_triplex        : boost::mpl::int_< CV_FONT_HERSHEY_TRIPLEX > {};
+struct font_hershey_complex_small  : boost::mpl::int_< CV_FONT_HERSHEY_COMPLEX_SMALL > {};
+struct font_hershey_script_simplex : boost::mpl::int_< CV_FONT_HERSHEY_SCRIPT_SIMPLEX > {};
+struct font_hershey_script_complex : boost::mpl::int_< CV_FONT_HERSHEY_SCRIPT_COMPLEX > {};
+
+
+typedef boost::shared_ptr< CvFont > ipl_font_wrapper;
+
+
+template< typename Font_Face
+        , typename Line_Type
+        >
+inline
+ipl_font_wrapper create_ipl_font( const Font_Face& font_face
+                                , double           hscale
+                                , double           vscale
+                                , const Line_Type& 
+                                , double           shear     = 0
+                                , std::size_t      thickness = 1
+                                )
+{
+    ipl_font_wrapper ipl_font( new CvFont() );
+
+    cvInitFont( ipl_font.get()
+              , typename Font_Face::type::value
+              , hscale
+              , vscale
+              , shear
+              , thickness
+              , typename Line_Type::type::value
+              );
+
+    return ipl_font;
+}
+
+template< typename Color >
+inline
+void putText( ipl_image_wrapper&       ipl_image
+            , const std::string&       text
+            , point_t                  org
+            , const ipl_font_wrapper&  ipl_font
+            , const Color&             color
+            )
+{
+    cvPutText( ipl_image.get()
+             , text.c_str()
+             , make_cvPoint ( org )
+             , ipl_font.get()
+             , make_cvScalar( color )
+             );
+}
+
+template< typename View
+        , typename Color
+        >
+inline
+void putText( View                     v
+            , const std::string&       text
+            , point_t                  org
+            , const ipl_font_wrapper&  ipl_font
+            , const Color&             color
+            )
+{
+    ipl_image_wrapper ipl = create_ipl_image( v );
+
+    putText( ipl
+           , text
+           , org
+           , ipl_font
+           , color
+           );
+}
+
+inline
+void getTextSize( const std::string&       text
+                , const ipl_font_wrapper&  ipl_font
+                , point_t&                 size
+                , int&                     baseline
+                )
+{
+    CvSize cv_size;
+
+    cvGetTextSize( text.c_str()
+                 , ipl_font.get()
+                 , &cv_size
+                 , &baseline
+                 );
+
+    size.x = cv_size.width;
+    size.y = cv_size.height;
+}
+
+} // namespace opencv
+} // namespace gil
+} // namespace boost
+
+
+#endif // BOOST_GIL_EXTENSION_OPENCV_TEXT_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/opencv/utilities.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/opencv/utilities.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,87 @@
+/*
+    Copyright 2008 Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_OPENCV_UTILITIES_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_OPENCV_UTILITIES_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Christian Henning \n
+///         
+/// \date 2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <cv.h>
+
+#include <vector>
+
+#include <boost/shared_array.hpp>
+
+#include <boost/gil/gil_all.hpp>
+
+namespace boost { namespace gil { namespace opencv {
+
+typedef gil::point2<ptrdiff_t> point_t;
+typedef std::vector< point_t > curve_t;
+typedef std::vector< curve_t > curve_vec_t;
+
+typedef boost::shared_array<CvPoint> cvpoint_array_t;
+typedef std::vector< cvpoint_array_t > cvpoint_array_vec_t;
+
+inline
+CvPoint make_cvPoint( point_t point )
+{
+   return cvPoint( static_cast< int >( point.x )
+                 , static_cast< int >( point.y )
+                 );
+}
+
+inline
+cvpoint_array_t make_cvPoint_array( const curve_t& curve )
+{
+   std::size_t curve_size = curve.size();
+
+   cvpoint_array_t cvpoint_array( new CvPoint[ curve.size() ] );
+
+   for( std::size_t i = 0; i < curve_size ; ++i )
+   {
+      cvpoint_array[i] = make_cvPoint( curve[i] );
+   }
+
+   return cvpoint_array;
+}
+
+inline
+CvSize make_cvSize( point_t point )
+{
+   return cvSize( static_cast< int >( point.x )
+                , static_cast< int >( point.y )
+                );
+}
+
+template< class PIXEL >
+inline
+CvScalar make_cvScalar( const PIXEL& pixel )
+{
+   CvScalar s;
+   for( int i = 0; i < num_channels<PIXEL>::value; ++i )
+   {
+      s.val[i] = pixel[i];
+   }
+
+   return s;
+}
+
+} // namespace opencv
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_OPENCV_UTILITIES_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/sdl/gil_sdl_converters.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/sdl/gil_sdl_converters.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,26 @@
+// Copyright 2007 Christian Henning.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef GIL_SDL_CONVERTERS_HPP
+#define GIL_SDL_CONVERTERS_HPP
+
+#include <SDL.h>
+
+namespace boost { namespace gil { namespace sdl { 
+
+inline
+bgra8_view_t wrap_sdl_image( SDL_Surface* screen )
+{
+   return interleaved_view( screen->w
+                          , screen->h
+                          , (bgra8_pixel_t*) screen->pixels
+                          , screen->pitch   );
+}
+
+} } } // namespace boost::gil::sdl
+
+#endif // GIL_SDL_CONVERTERS_HPP
Index: boost-1.52.0/src/boost/gil/extension/sdl/message_queue.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/sdl/message_queue.h	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,221 @@
+/****************************************************************************
+ *   Copyright (C) 2005 by Oliver Kowalke                                   *
+ *   oliver.kowalke@gmx.de                                                  *
+ *                                                                          *
+ *  This library is free software; you can redistribute it and/or           *
+ *  modify it under the terms of the GNU Lesser General Public              *
+ *  License as published by the Free Software Foundation; either            *
+ *  version 2.1 of the License, or (at your option) any later version.      *
+ *                                                                          *
+ *  This library is distributed in the hope that it will be useful,         *
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       *
+ *  Lesser General Public License for more details.                         *
+ *                                                                          *
+ *  You should have received a copy of the GNU Lesser General Public        *
+ *  License along with this library; if not, write to the Free Software     *
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA *
+ ****************************************************************************/
+#ifndef OGX_MESSAGE_QUEUE_H
+#define OGX_MESSAGE_QUEUE_H
+
+#include <queue>
+
+#include <boost/bind.hpp>
+#include <boost/shared_ptr.hpp>
+#include <boost/thread/condition.hpp>
+#include <boost/thread/mutex.hpp>
+
+namespace ogx
+{
+	template
+	<
+		typename T,
+		typename Q = std::priority_queue< boost::shared_ptr< T > >
+	>
+	class message_queue
+	{
+	public:
+		typedef	Q								queue_type;
+		typedef boost::shared_ptr< T >			msg_type;
+		typedef typename queue_type::size_type	size_type;
+		
+	private:
+		queue_type				queue_;
+		boost::mutex			mtx_;
+		boost::condition		not_empty_cond_;
+		boost::condition		not_full_cond_;
+		size_type				high_water_mark_;
+		size_type				low_water_mark_;
+		bool					active_;
+		static const size_type	infinity_;
+		
+		void enqueue_( msg_type const& msg)
+		{ queue_.push( msg); }
+		
+		void dequeue_( msg_type & msg)
+		{
+			msg = queue_.top();
+			queue_.pop();
+		}
+		
+		bool full_() const
+		{
+			if ( high_water_mark_ == infinity_) return false;
+			return queue_.size() > high_water_mark_;
+		}
+		
+		bool empty_() const
+		{ return queue_.empty(); }
+		
+		bool suppliers_activate_() const
+		{ return active_ == false || ! full_(); }
+		
+		bool consumers_activate_() const
+		{ return active_ == false || ! empty_(); }
+		
+		void activate_()
+		{
+			active_ = true;
+		}
+		
+		void deactivate_()
+		{
+			if ( active_)
+			{
+				active_ = false;
+				not_empty_cond_.notify_all();
+				not_full_cond_.notify_all();
+			}
+		}
+		
+		void flush_()
+		{ queue_.clear(); }
+		
+	public:
+		message_queue()
+		: 
+		queue_(), 
+		mtx_(), 
+		not_empty_cond_(), 
+		not_full_cond_(), 
+		high_water_mark_( infinity_),
+		low_water_mark_( infinity_),
+		active_( true)
+		{}
+		
+		message_queue( size_type water_mark)
+		: 
+		queue_(), 
+		mtx_(), 
+		not_empty_cond_(), 
+		not_full_cond_(), 
+		high_water_mark_( water_mark),
+		low_water_mark_( water_mark),
+		active_( true)
+		{}
+		
+		message_queue( 
+			size_type low_water_mark, 
+			size_type high_water_mark)
+		: 
+		queue_(), 
+		mtx_(), 
+		not_empty_cond_(), 
+		not_full_cond_(), 
+		high_water_mark_( high_water_mark),
+		low_water_mark_( low_water_mark),
+		active_( true)
+		{}
+		
+      std::size_t size()
+      {
+         return queue_.size();
+      }
+
+
+		void activate()
+		{
+			typename boost::mutex::scoped_lock lock( mtx_);
+			activate_();
+		}
+		
+		void deactivate()
+		{
+			typename boost::mutex::scoped_lock lock( mtx_);
+			deactivate_();
+		}
+		
+		bool empty()
+		{ 
+			typename boost::mutex::scoped_lock lock( mtx_);
+			return empty_(); 
+		}
+		
+		bool full()
+		{
+			typename boost::mutex::scoped_lock lock( mtx_);
+			return full_();
+		}
+		
+		bool enqueue( msg_type const& msg)
+		{
+			typename boost::mutex::scoped_lock lock( mtx_);
+			if ( active_ == false) return false;
+			not_full_cond_.wait( 
+				lock,
+				boost::bind(
+					& message_queue< T, Q >::suppliers_activate_,
+					this) );
+			if ( active_ != false)
+			{
+				enqueue_( msg);
+				not_empty_cond_.notify_one();
+				return true;
+			}
+			else
+				return false;
+		}
+		
+		bool dequeue( msg_type & msg)
+		{
+			typename boost::mutex::scoped_lock lock( mtx_);
+			if ( active_ == false && empty_() ) return false;
+			not_empty_cond_.wait( 
+				lock,
+				boost::bind(
+					& message_queue< T, Q >::consumers_activate_,
+					this) );
+ 			if ( empty_() )
+ 				msg.reset();
+ 			else
+				dequeue_( msg);
+ 			if ( active_ == true && queue_.size() <= low_water_mark_)
+				not_full_cond_.notify_one();
+			return msg ? true : false;
+		}
+		
+		void flush()
+		{
+			typename boost::mutex::scoped_lock lock( mtx_);
+			flush_();
+		}
+		
+		void close()
+		{
+			typename boost::mutex::scoped_lock lock( mtx_);
+			deactivate_();
+			flush_();
+		}
+	};
+
+	template
+	<
+		typename T,
+		typename Q
+	>
+	const typename message_queue< T, Q >::size_type
+	message_queue< T, Q >::infinity_ = -1;
+};
+
+#endif // OGX_MESSAGE_QUEUE_H
Index: boost-1.52.0/src/boost/gil/extension/sdl/sdl_events.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/sdl/sdl_events.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,56 @@
+// Copyright 2007 Christian Henning.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef SDL_EVENTS_HPP
+#define SDL_EVENTS_HPP
+
+namespace boost { namespace gil { namespace sdl { namespace detail {
+
+struct sdl_event_base
+{
+   unsigned int type() { return _type; }
+
+protected:
+
+   sdl_event_base() : _type( 0 ) {}
+   sdl_event_base( int type ) : _type( type ) {}
+
+private:
+
+   int _type;
+};
+
+struct redraw_event : public sdl_event_base
+{
+   redraw_event()
+   : sdl_event_base( type )
+   {}
+
+   static const int type = 1;
+};
+
+struct key_up_event : public sdl_event_base
+{
+   key_up_event()
+   : sdl_event_base( type )
+   {}
+
+   static const int type = 2;
+};
+
+struct quit_event : public sdl_event_base
+{
+   quit_event()
+   : sdl_event_base( type )
+   {}
+
+   static const int type = 3;
+};
+
+} } } } // namespace boost::gil::sdl::detail
+
+#endif // SDL_EVENTS_HPP
Index: boost-1.52.0/src/boost/gil/extension/sdl/sdl_service.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/sdl/sdl_service.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,130 @@
+// Copyright 2007 Christian Henning.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef SDL_SERVICE_HPP
+#define SDL_SERVICE_HPP
+
+#include <exception>
+#include <string>
+
+#include <boost/scoped_ptr.hpp>
+
+#include <boost/thread/thread.hpp>
+#include <boost/thread/mutex.hpp>
+
+#include <SDL.h>
+
+#include "sdl_window.hpp"
+#include "sdl_events.hpp"
+#include "message_queue.h"
+
+namespace boost { namespace gil { namespace sdl { 
+
+class sdl_service
+{
+public:
+
+   sdl_service()
+   : _terminate( false )
+   , _init_redraw( true )
+   {
+      if ( SDL_Init( SDL_INIT_VIDEO | SDL_INIT_TIMER ) < 0 ) 
+      {
+         std::string error( "Unable to init SDL: " );
+         error += SDL_GetError();
+         throw  std::runtime_error( error );
+      }
+   }
+
+   ~sdl_service()
+   {
+      _terminate = true;
+
+      SDL_Quit();
+   }
+
+   void add_window( shared_ptr< sdl_window_base > win )
+   {
+      _win.swap( win );
+
+      // Pass the window a message queue.
+      
+      _win->set_queue( _queue );
+   }
+
+   void run()
+   {
+      while( _terminate == false )
+      {
+         if( _init_redraw && _win )
+         {
+            add_message<detail::redraw_event>();
+
+            _init_redraw = false;
+         }
+
+         SDL_Event event;
+         while( SDL_WaitEvent( &event ))
+         {
+            switch (event.type) 
+            {
+               case SDL_KEYDOWN:
+               {
+                  break;
+               }
+
+               case SDL_KEYUP:
+               {
+                  // If escape is pressed, return (and thus, quit)
+                  if( event.key.keysym.sym == SDLK_ESCAPE )
+                  {
+                     add_message<detail::quit_event>();
+
+                     SDL_Delay( 200 );
+
+                     return ;
+                  }
+
+                  add_message<detail::key_up_event>();
+
+                  break;
+               }
+
+               case SDL_QUIT:
+               {
+                  add_message<detail::quit_event>();
+
+                  SDL_Delay( 200 );
+                  return ;
+               }
+
+            } //switch
+         } // while
+      } // while
+   }
+
+private:
+
+   template< class EVENT >
+   void add_message()
+   {
+      _queue.enqueue( boost::shared_ptr< EVENT >( new EVENT() ));
+   }
+
+   bool _terminate;
+
+   shared_ptr< sdl_window_base > _win;
+
+   queue_t _queue;
+
+   bool _init_redraw;
+};
+
+
+} } } // namespace boost::gil::sdl
+
+#endif // SDL_SERVICE_HPP
Index: boost-1.52.0/src/boost/gil/extension/sdl/sdl_timer.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/sdl/sdl_timer.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,102 @@
+// Copyright 2007 Christian Henning.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef SDL_TIMER_HPP
+#define SDL_TIMER_HPP
+
+#include <boost/shared_ptr.hpp>
+
+#include <SDL.h>
+
+#include "sdl_window_base.hpp"
+#include "user_events.hpp"
+
+namespace boost { namespace gil { namespace sdl { namespace detail {
+
+template< typename TIMER_HANDLER  = detail::default_timer_event_handler
+        , typename REDRAW_HANDLER = detail::default_timer_event_handler
+        >
+class sdl_timer_base : virtual public sdl_window_base
+                     , public TIMER_HANDLER
+{
+private:
+
+   typedef boost::shared_ptr<REDRAW_HANDLER> redraw_handler_t;
+
+public:
+
+   sdl_timer_base( int width
+                 , int height
+                 , redraw_handler_t redraw_handler )
+   : sdl_window_base( width, height )
+   , _redraw_handler( redraw_handler )
+   , _timer_id( 0 )
+   , _timer_init( false )
+   {}
+
+   ~sdl_timer_base()
+   {
+      if( _timer_init )
+      {
+         SDL_RemoveTimer( _timer_id );
+
+         std::cout << "timer is removed." << std::endl;
+      }
+   }
+
+
+   // interval in ms
+   void set_timer( unsigned int interval )
+   {
+      if( _timer_init == false )
+      {
+         _timer_id = SDL_AddTimer( interval
+                                 , &sdl_timer_base::timer_callback
+                                 , this                              );
+
+         char* error = SDL_GetError();
+
+         _timer_init = true;
+      }
+      else
+      {
+         throw std::runtime_error( "Timer is already running." );
+      }   
+   }
+
+private:
+
+   static Uint32 timer_callback( Uint32 interval, void *param )
+   {
+      sdl_timer_base* p = (sdl_timer_base*) param;
+
+      if( p && p->time_elapsed() )
+      {
+         p->lock();
+
+         if( p->_screen->pixels == NULL )
+            return 0;
+         p->_redraw_handler->redraw( wrap_sdl_image( p->_screen ));
+         p->unlock();
+      }
+
+      return interval;
+   }
+
+private:
+
+   bool _timer_init;
+
+   SDL_TimerID _timer_id;
+
+   redraw_handler_t _redraw_handler;
+
+};
+
+} } } } // namespace boost::gil::sdl::detail
+
+#endif //SDL_TIMER_HPP
Index: boost-1.52.0/src/boost/gil/extension/sdl/sdl_window.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/sdl/sdl_window.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,149 @@
+// Copyright 2007 Christian Henning.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef SDL_WINDOW_HPP
+#define SDL_WINDOW_HPP
+
+#include <boost/scoped_ptr.hpp>
+
+#include <boost/thread/thread.hpp>
+#include <boost/thread/mutex.hpp>
+
+#include <SDL.h>
+
+#include "sdl_events.hpp"
+#include "sdl_timer.hpp"
+#include "sdl_window_base.hpp"
+#include "user_events.hpp"
+#include "message_queue.h"
+
+namespace boost { namespace gil { namespace sdl { 
+
+typedef detail::sdl_event_base sdl_event_t;
+
+// active object for displaying images
+
+template < typename KEYBOARD_EVENTS = detail::default_keyboard_event_handler
+         , typename REDRAW_EVENT    = detail::default_redraw_event_handler
+         , typename TIMER_EVENT     = detail::default_timer_event_handler
+         , typename QUIT_EVENT      = detail::default_quit_event_handler
+         >
+class sdl_window : virtual public sdl_window_base
+                 , public detail::sdl_timer_base< TIMER_EVENT
+                                                , REDRAW_EVENT >
+                 , public KEYBOARD_EVENTS
+                 , public QUIT_EVENT
+{
+   typedef shared_ptr<REDRAW_EVENT> redraw_handler_t;
+
+public:
+
+   sdl_window( int width
+             , int height
+             , redraw_handler_t rh = redraw_handler_t( new REDRAW_EVENT() ))
+   : sdl_window_base( width
+                    , height )
+   , detail::sdl_timer_base< TIMER_EVENT
+                           , REDRAW_EVENT>( width
+                                          , height
+                                          , rh     )
+
+   , _redraw_handler( rh )
+   , _cancel( false )
+   {
+      _thread.reset( new boost::thread( boost::bind( &boost::gil::sdl::sdl_window< KEYBOARD_EVENTS
+                                                                                 , REDRAW_EVENT
+                                                                                 , TIMER_EVENT 
+                                                                                 , QUIT_EVENT >::_run
+                                                   , this )));
+   }
+
+   ~sdl_window()
+   {
+      cancel();
+      _thread->join();
+   }
+
+   void cancel()
+   {
+      boost::mutex::scoped_lock oLock( _sentinel );
+
+      _cancel = true;
+      std::cout << "cancel is true." << std::endl;
+   }
+
+private:
+
+   void _run()
+   {
+      boost::shared_ptr< sdl_event_t > e;
+
+      while( _cancel == false )
+      {
+         if( get_queue() )
+         {
+            std::cout << "before get event." << std::endl;
+            get_queue()->dequeue( e );
+            std::cout << "after get event." << std::endl;
+
+            switch( e->type() )
+            {
+               case detail::redraw_event::type:
+               {
+                  lock();
+
+                  _redraw_handler->redraw( wrap_sdl_image( _screen ));
+
+                  unlock();
+
+                  break;
+               }
+
+               case detail::key_up_event::type:
+               {
+                  lock();
+
+				  if( KEYBOARD_EVENTS::key_up() == true )
+                  {
+                     _redraw_handler->redraw( wrap_sdl_image( _screen ));
+                  }
+
+                  unlock();
+
+                  break;
+               }
+
+               case detail::quit_event::type:
+               {
+                  std::cout << "received quit event." << std::endl;
+
+                  QUIT_EVENT::quit();
+               }
+            }
+         }
+      }
+
+
+      std::cout << "thread main is done." << std::endl;
+   }
+
+private:
+
+   typedef boost::scoped_ptr<boost::thread> thread_t;
+   thread_t _thread;
+
+   mutable boost::mutex _sentinel;
+
+   redraw_handler_t _redraw_handler;
+
+   bool _cancel;
+};
+
+
+} } } // namespace boost::gil::sdl
+
+#endif // SDL_WINDOW_HPP
Index: boost-1.52.0/src/boost/gil/extension/sdl/sdl_window_base.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/sdl/sdl_window_base.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,107 @@
+// Copyright 2007 Christian Henning.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef SDL_WINDOW_BASE_HPP
+#define SDL_WINDOW_BASE_HPP
+
+#include <boost/scoped_ptr.hpp>
+
+#include <boost/thread/thread.hpp>
+#include <boost/thread/mutex.hpp>
+
+#include <SDL.h>
+
+#include "sdl_events.hpp"
+#include "message_queue.h"
+
+namespace boost { namespace gil { namespace sdl { 
+
+typedef detail::sdl_event_base sdl_event_t;
+typedef ogx::message_queue< sdl_event_t > queue_t;
+
+class sdl_window_base
+{
+protected:
+
+   sdl_window_base( int width
+                  , int height )
+   : _queue( NULL )
+   , _surface_init( false )
+   , _width ( width  )
+   , _height( height )
+   {
+      if( !_surface_init )
+      {
+         _screen = SDL_SetVideoMode( _width
+                                 , _height
+                                 , 32
+                                 , SDL_SWSURFACE );
+
+         if( _screen == NULL )
+         {
+            throw std::runtime_error( "Couldn't create SDL window" );
+         }
+
+         _surface_init = true;
+      }
+
+   }
+
+   void lock()
+   {
+      if( _screen && SDL_MUSTLOCK( _screen ))
+      {
+         if( SDL_LockSurface( _screen ) < 0 ) 
+         {
+            return;
+         }
+      }
+   }
+
+   void unlock()
+   {
+      if( _screen && SDL_MUSTLOCK( _screen )) 
+      {
+         SDL_UnlockSurface( _screen );
+      }
+
+      // Tell SDL to update the whole screen
+      SDL_UpdateRect( _screen
+                    , 0
+                    , 0
+                    , _width
+                    , _height );
+   }
+
+   queue_t* get_queue() { return _queue; }
+
+private:
+
+   void set_queue( queue_t& queue )
+   {
+      _queue = &queue;
+   }
+
+   friend class sdl_service;
+
+protected:
+
+   bool _surface_init;
+
+   int _width;
+   int _height;
+
+   SDL_Surface* _screen;
+
+private:
+
+   queue_t* _queue;
+};
+
+} } } // namespace boost::gil::sdl
+
+#endif // SDL_WINDOW_BASE_HPP
Index: boost-1.52.0/src/boost/gil/extension/sdl/sdl_wrapper.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/sdl/sdl_wrapper.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,8 @@
+#ifndef SDL_WRAPPER_HPP
+#define SDL_WRAPPER_HPP
+
+#include "gil_sdl_converters.hpp"
+#include "sdl_service.hpp"
+#include "user_events.hpp"
+
+#endif //SDL_WRAPPER_HPP
Index: boost-1.52.0/src/boost/gil/extension/sdl/user_events.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/sdl/user_events.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,38 @@
+// Copyright 2007 Christian Henning.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef USER_EVENTS_HPP
+#define USER_EVENTS_HPP
+
+namespace boost { namespace gil { namespace sdl { namespace detail {
+
+struct default_keyboard_event_handler
+{
+   // Return true to trigger redraw.
+   bool key_up() { return false; }
+};
+
+struct default_redraw_event_handler
+{
+   void redraw( const bgra8_view_t& sdl_view ) {}
+};
+
+struct default_timer_event_handler
+{
+   // Return true to trigger redraw.
+   bool time_elapsed() { return false; }
+};
+
+
+struct default_quit_event_handler
+{
+   void quit() {}
+};
+
+} } } } // namespace boost::gil::sdl::detail
+
+#endif // GIL_SDL_CONVERTERS_HPP
Index: boost-1.52.0/src/boost/gil/extension/toolbox/aligned.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/aligned.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,60 @@
+// Copyright Tom Brinkman 2008. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef _aligned_hpp_
+#define _aligned_hpp_
+
+#include <boost/gil/gil_all.hpp>
+#include <blend.hpp>
+
+namespace layer
+{
+
+template <typename view_t>
+struct aligned
+{
+	enum 
+	{ 
+		left = (0x1 << 0),
+		center = (0x1 << 1),
+		right = (0x1 << 2),
+		top = (0x1 << 3),
+		middle = (0x1 << 5),
+		bottom = (0x1 << 7),
+	}; 
+
+	view_t& v2;
+	int align;
+	aligned(view_t v2, int align = center|middle) : v2(v2), align(align) {}
+		
+	void operator()(view_t& view)
+	{
+		using namespace boost::gil;
+
+		int w = v2.width();
+		int h = v2.height();
+
+		if (h > view.height() || w > view.width())
+			return;
+		
+		int x = 0;
+		if (align & center)
+			x = (view.width()-w)/2;
+		else if (align & right)
+			x = view.width()-w;
+
+		int y = 0;
+		if (align & middle)
+			y = (view.height()-h)/2;
+		else if (align & bottom)
+			y = view.height()-h;
+		
+		view_t v3 = subimage_view(view,x,y,w,h);
+		boost::gil::copy_pixels(v2,v3);
+	}
+};
+
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/aligned.ppm
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/boost/gil/extension/toolbox/aligned.ppm	2012-11-09 15:21:14.000000000 +0100 differ
Index: boost-1.52.0/src/boost/gil/extension/toolbox/aligned.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/aligned.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,87 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <aligned.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ aligned.tests.cpp -I /home/scott/project/boost_1_36_0 -I .
+
+static const struct {
+  int  	 width;
+  int  	 height;
+  int  	 bytes_per_pixel; /* 3:RGB, 4:RGBA */ 
+  char 	 pixel_data[16 * 16 * 3 + 1];
+} gimp_image = {
+  16, 16, 3,
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\277\277\277\177\177\177"
+  "\0\0\0\0\0\0\0\0\0\177\177\177\277\277\277\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\277\277"
+  "\277\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\277\277\277\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\277\277\277\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\277\277\277\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\177\177\177\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\177\177\177\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\177\177\177\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\177\177\177\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\277\277\277\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\277\277\277\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\277\277\277\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\277\277\277\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\277\277"
+  "\277\177\177\177\0\0\0\0\0\0\0\0\0\177\177\177\277\277\277\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377",
+};
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		rgb8_view_t view2 = interleaved_view(gimp_image.width,gimp_image.height,
+			(rgb8_pixel_t*)gimp_image.pixel_data,gimp_image.width*gimp_image.bytes_per_pixel);
+
+		typedef layer::aligned<rgb8_view_t> aligned_t;
+		aligned_t aligned(view2,aligned_t::center|aligned_t::middle);
+		aligned(view);
+
+		aligned.align = aligned_t::left|aligned_t::top;
+		aligned(view);
+
+		FILE* fd = fopen("aligned.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "aligned tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/blend.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/blend.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,67 @@
+#ifndef _blend_hpp_
+#define _blend_hpp_
+
+#include <boost/gil/gil_all.hpp>
+
+struct alpha24_blend
+{
+	short alpha;	
+	alpha24_blend(short alpha) : alpha(alpha){}
+
+	template <typename T>
+	void operator()(T& dst, const T src)
+	{
+		dst = ((dst + 1) * alpha >> 8) - 
+			((src + 1) * alpha >> 8) +			
+				src;
+	}
+};
+
+template <typename blend_t, typename pixel_t, typename grayview_t, typename view_t> inline
+void copy(pixel_t pixel, const grayview_t& grayview, const view_t& view)
+{
+	using namespace boost::gil;
+	BOOST_ASSERT(grayview.width() == view.width());
+
+	typedef typename view_t::x_iterator x_iterator_t;
+	typedef typename grayview_t::x_iterator x_iterator2_t;
+	
+	for (int y = 0; y < view.height(); ++y)
+	{
+        	x_iterator_t it_view = view.row_begin(y);
+        	x_iterator2_t it_gray = grayview.row_begin(y);
+		for (int x = 0; x < view.width(); ++x)
+		{
+			pixel_t dst = pixel;
+			static_for_each(dst, it_view[x], blend_t(it_gray[x]));
+			it_view[x] = dst;
+		}
+	}
+}
+
+template <typename blend_t, typename grayview_t, typename view_t> inline
+void copy(const grayview_t& gray, const view_t& bottom, const view_t& top)
+{
+	using namespace boost::gil;
+	BOOST_ASSERT(gray.width() == bottom.width());
+	BOOST_ASSERT(bottom.width() == top.width());
+
+	typedef typename view_t::x_iterator x_iterator_t;
+	typedef typename grayview_t::x_iterator x_iterator2_t;
+	typedef typename view_t::value_type value_type_t;
+	
+	for (int y = 0; y < top.height(); ++y)
+	{
+        	x_iterator_t it_top = top.row_begin(y);
+        	x_iterator_t it_bot = bottom.row_begin(y);
+        	x_iterator2_t it_gray = gray.row_begin(y);
+		for (int x = 0; x < top.width(); ++x)
+		{
+			value_type_t dst = it_bot[x];
+			static_for_each(dst, it_top[x], blend_t(it_gray[x]));
+			it_top[x] = dst;
+		}
+	}
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/border.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/border.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,67 @@
+// Copyright Tom Brinkman 2008. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef _border_hpp_
+#define _border_hpp_
+
+#include <boost/gil/gil_all.hpp>
+
+namespace layer
+{
+
+template <typename view_t>
+struct border
+{
+	typedef typename view_t::value_type color_t;
+	color_t clr;
+	
+	border(color_t clr) : clr(clr) {}
+
+	void operator()(view_t& view)
+	{
+		using namespace boost::gil;		
+		
+		for (int x = 0; x < view.width(); ++x)
+		{
+			view(x,0) = clr;
+			view(x,view.height()-1) = clr;
+		}
+
+		for (int y = 0; y < view.height(); ++y)
+		{
+			view(0,y) = clr;
+			view(view.width()-1,y) = clr;
+		}
+	}
+};	
+
+template <typename view_t>
+struct raised_border
+{
+	typedef typename view_t::value_type color_t;
+	color_t dark,light;
+	
+	raised_border(color_t light, color_t dark) : dark(dark), light(light) {}
+
+	void operator()(view_t& view)
+	{
+		using namespace boost::gil;		
+		
+		for (int x = 0; x < view.width(); ++x)
+			view(x,0) = light;
+
+		for (int y = 0; y < view.height(); ++y)
+			view(0,y) = light;	
+
+		for (int y = 1; y < view.height(); ++y)
+			view(view.width()-1,y) = dark;	
+
+		for (int x = 0; x < view.width(); ++x)
+			view(x,view.height()-1) = dark;	
+	}
+};	
+
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/border.ppm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/border.ppm	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,5 @@
+P6
+# CREATOR: reportbase
+200 200
+255
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
\ No newline at end of file
Index: boost-1.52.0/src/boost/gil/extension/toolbox/border.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/border.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,38 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <border.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ border.tests.cpp -I /home/scott/project/boost_1_36_0 -I .
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		layer::raised_border<rgb8_view_t> border(
+			rgb8_view_t::value_type(220,220,220),
+				rgb8_view_t::value_type(50,50,50));
+		border(view);
+		
+		FILE* fd = fopen("border.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "border tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/channel_view.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/channel_view.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,79 @@
+/*
+    Copyright 2010 Fabien Castan, Christian Henning
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_TOOLBOX_CHANNEL_VIEW_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_TOOLBOX_CHANNEL_VIEW_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file channel_view.hpp
+/// \brief Helper to generate channel_view type.
+/// \author Fabien Castan, Christian Henning \n
+///
+/// \date   2010 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/gil_all.hpp>
+
+namespace boost {
+namespace gil {
+
+template < typename Channel
+         , typename View
+         >
+struct channel_type_to_index
+{
+    static const int value = gil::detail::type_to_index< typename color_space_type< View >::type // color (mpl::vector)
+                                                       , Channel                                 // channel type
+                                                       >::type::value;                           //< index of the channel in the color (mpl::vector)
+};
+
+template< typename Channel
+        , typename View
+        >
+struct channel_view_type : public kth_channel_view_type< channel_type_to_index< Channel
+                                                                              , View
+                                                                              >::value
+                                                       , View
+                                                       >
+{
+    static const int index = channel_type_to_index< Channel
+                                                  , View
+                                                  >::value;
+                                                  
+    typedef kth_channel_view_type< index
+                                 , View
+                                 > parent_t;
+
+    typedef typename parent_t::type type;
+
+
+    static type make( const View& src )
+    {
+        return parent_t::make( src );
+    }
+};
+
+/// \ingroup ImageViewTransformationsKthChannel
+template< typename Channel
+        , typename View
+        >
+typename channel_view_type< Channel
+                          , View
+                          >::type channel_view( const View& src )
+{
+   return channel_view_type< Channel
+                           , View
+                           >::make( src );
+}
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_TOOLBOX_CHANNEL_VIEW_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/toolbox/channels.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/channels.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,121 @@
+#ifndef _channels_hpp_
+#define _channels_hpp_
+
+#include <assert.h>
+#include <boost/gil/gil_all.hpp>
+#include <boost/function.hpp>
+
+struct channels
+{
+	struct channel
+	{
+		int pos;
+		channel* next;
+	};
+
+	channel* head;
+	channel* current;
+
+	channels() : head(NULL), current(NULL) {}
+	channels(channel* head) : head(head), current(head) {}
+	operator bool (){return current != NULL;}
+	operator channel * () {return head;}
+	double operator *(){return current->pos;}
+	void operator ++(int){current = current->next;}
+	void operator ++(){current = current->next;}
+	void reset() {current = head;}
+
+	~channels()
+	{
+		while (head)
+		{
+			channel* tmp = head->next;
+			free(head);
+			head = tmp;
+		}
+		
+		head = NULL;
+	}
+
+	channels(int width, int channels)
+	{
+		assert(channels);
+		assert(width);
+	
+		head = (channel*)malloc(sizeof(channel));
+		
+		head->pos = width-1;
+		head->next = NULL;
+		
+		if (channels != 1)
+		{
+			head->pos = -1;
+			channel* save_head = head;
+			
+			--channels;	
+			int adj = width/channels;
+			int extra = 0;
+			if (width % channels)
+				extra = width-adj*channels;
+		
+			while (head->pos < width-1)
+			{
+				int add = adj;
+				if (extra-- > 0)
+					add++;
+		
+				channel* tail  = (channel*)malloc(sizeof(channel));
+				tail->pos = head->pos + add;
+				tail->next = NULL;
+		
+				head->next = tail;
+				head = tail;
+			}
+		
+			head = save_head;
+			head->pos = 0;
+
+			current = head;
+		}
+	}
+};
+
+
+namespace layer
+{
+
+//Used by the horizontal date labels
+template <typename view_t>
+struct horizontal_channels
+{
+	typedef boost::function<void (view_t&)> layer_t;
+	std::vector<layer_t> layers;
+	int periods;
+
+	horizontal_channels(layer_t* p, int size, int periods) : periods(periods)
+	{
+		for (int n = 0; n < size; ++n)
+			layers.push_back(p[n]);
+	}
+
+	void operator()(view_t& view)
+	{
+		using namespace boost::gil;
+
+		channels i(periods, layers.size());
+		channels x(view.width(), periods);
+
+		int n=0, m=0;
+		for (; i; ++i, ++m)
+		{
+			for (; n < *i; ++n, ++x);
+
+			view_t v = subimage_view(view,*x,0,0,view.height());
+			layers[m](v);
+		}
+	}
+};
+
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/channels.ppm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/channels.ppm	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,5 @@
+P6
+# CREATOR: reportbase
+200 200
+255
+
\ No newline at end of file
Index: boost-1.52.0/src/boost/gil/extension/toolbox/channels.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/channels.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,67 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <channels.hpp>
+#include <fill.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ channels.tests.cpp -I /home/scott/project/boost_1_36_0 -I .
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		typedef boost::function<void (rgb8_view_t&)> layer_t;
+		typedef layer::fill<rgb8_view_t> fill_t;
+
+		layer_t a[] = 
+		{
+			fill_t(rgb8_view_t::value_type(255,0,255)),
+			fill_t(rgb8_view_t::value_type(255,0,0)),
+			fill_t(rgb8_view_t::value_type(0,0,255)),
+			fill_t(rgb8_view_t::value_type(255,0,0)),
+			fill_t(rgb8_view_t::value_type(100,0,255)),
+			fill_t(rgb8_view_t::value_type(100,0,100)),
+		};
+
+		layer::horizontal_channels<rgb8_view_t> channels(a,6,3);
+		channels(view);
+		
+		FILE* fd = fopen("channels.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+struct test2
+{
+	void operator()()
+	{
+		channels curr(100,3);
+
+		double a[] = {0,49,99};
+
+		int n = 0;
+		for(; curr; ++curr, n++)
+		{
+			BOOST_CHECK(a[n] == *curr);
+		}
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "channels tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	test->add( BOOST_TEST_CASE(test2()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/cmyka.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/cmyka.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,66 @@
+#pragma once
+
+#include <boost\gil\rgba.hpp>
+#include <boost\gil\cmyk.hpp>
+
+#include <boost\gil\color_convert.hpp>
+#include <boost\gil\typedefs.hpp>
+
+namespace boost { namespace gil {
+
+/// \ingroup ColorSpaceModel
+typedef mpl::vector5<cyan_t,magenta_t,yellow_t,black_t,alpha_t> cmyka_t;
+
+/// \ingroup LayoutModel
+typedef layout<cmyka_t> cmyka_layout_t;
+
+
+GIL_DEFINE_ALL_TYPEDEFS(8,  cmyka)
+GIL_DEFINE_ALL_TYPEDEFS(8s, cmyka)
+GIL_DEFINE_ALL_TYPEDEFS(16, cmyka)
+GIL_DEFINE_ALL_TYPEDEFS(16s,cmyka)
+GIL_DEFINE_ALL_TYPEDEFS(32 ,cmyka)
+GIL_DEFINE_ALL_TYPEDEFS(32s,cmyka)
+GIL_DEFINE_ALL_TYPEDEFS(32f,cmyka)
+
+///// \ingroup ColorConvert
+///// \brief Converting CMYKA to any pixel type. Note: Supports homogeneous pixels only.
+//template <typename C2>
+//struct default_color_converter_impl<cmyka_t,C2> {
+//    template <typename P1, typename P2>
+//    void operator()(const P1& src, P2& dst) const {
+//        typedef typename channel_type<P1>::type T1;
+//        default_color_converter_impl<cmyk_t,C2>()(
+//            pixel<T1,cmyk_layout_t>(channel_multiply(get_color(src,cyan_t()),  get_color(src,alpha_t())), 
+//                                    channel_multiply(get_color(src,magenta_t()),get_color(src,alpha_t())), 
+//                                    channel_multiply(get_color(src,yellow_t()), get_color(src,alpha_t())),
+//									channel_multiply(get_color(src,black_t()), get_color(src,alpha_t())))
+//            ,dst);
+//    }
+//};
+template <>
+struct default_color_converter_impl<cmyka_t,rgba_t> {
+    template <typename P1, typename P2>
+    void operator()(const P1& src, P2& dst) const {
+        typedef typename channel_type<P1>::type T1;
+        default_color_converter_impl<cmyk_t,rgba_t>()(
+            pixel<T1,cmyk_layout_t>(get_color(src,cyan_t()), 
+                                    get_color(src,magenta_t()), 
+                                    get_color(src,yellow_t()),
+									get_color(src,black_t()))
+            ,dst);
+    }
+};
+
+/// \ingroup ColorConvert
+/// \brief Unfortunately CMYKA to CMYKA must be explicitly provided - otherwise we get ambiguous specialization error.
+template <>
+struct default_color_converter_impl<cmyka_t,cmyka_t> {
+    template <typename P1, typename P2>
+    void operator()(const P1& src, P2& dst) const {
+        static_for_each(src,dst,default_channel_converter());
+    }
+};
+
+} // namespace gil
+} // namespace boost
\ No newline at end of file
Index: boost-1.52.0/src/boost/gil/extension/toolbox/dynamic_images.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/dynamic_images.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,115 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+
+    See http://opensource.adobe.com/gil for most recent version including documentation.
+*/
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_TOOLBOX_DYNAMIC_IMAGES_HPP
+#define BOOST_GIL_EXTENSION_TOOLBOX_DYNAMIC_IMAGES_HPP
+
+/// \file
+/// \brief  Generic io functions for dealing with dynamic images
+//
+/// \author Hailin Jin and Lubomir Bourdev \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated May 30, 2006
+
+#include <boost/mpl/at.hpp>
+#include <boost/mpl/size.hpp>
+#include <boost/gil/gil_config.hpp>
+#include <boost/gil/extension/io_new/detail/io_error.hpp>
+#include <boost/gil/extension/dynamic_image/dynamic_image_all.hpp>
+
+namespace boost { namespace gil {
+
+// need this for various meta functions.
+struct any_image_pixel_t       {};
+struct any_image_channel_t     {};
+struct any_image_color_space_t {};
+
+namespace detail {
+
+template <long N>
+struct construct_matched_t {
+    template <typename Images,typename Pred>
+    static bool apply(any_image<Images>& im,Pred pred) {
+        if (pred.template apply<typename mpl::at_c<Images,N-1>::type>()) {
+            typename mpl::at_c<Images,N-1>::type x;
+            im.move_in(x);
+            return true;
+        } else return construct_matched_t<N-1>::apply(im,pred);
+    }
+};
+template <>
+struct construct_matched_t<0> {
+    template <typename Images,typename Pred>
+    static bool apply(any_image<Images>&,Pred) {return false;}
+};
+
+// A function object that can be passed to apply_operation.
+// Given a predicate IsSupported taking a view type and returning an MPL boolean,
+// calls the apply method of OpClass with the view if the given view IsSupported, or throws an exception otherwise
+template <typename IsSupported, typename OpClass>
+class dynamic_io_fnobj {
+    OpClass* _op;
+
+    template <typename View>
+    void apply(const View& view,mpl::true_ ) {_op->apply(view);}
+
+    template <typename View, typename Info >
+    void apply( const View& view
+              , const Info& info
+              , const mpl::true_
+              )
+    {
+        _op->apply( view, info );
+    }
+
+    template <typename View>
+    void apply(const View& /* view */ ,mpl::false_) {io_error("dynamic_io: unsupported view type for the given file format");}
+
+    template <typename View, typename Info >
+    void apply( const View& /* view */
+              , const Info& /* info */
+              , const mpl::false_
+              )
+    {
+        io_error( "dynamic_io: unsupported view type for the given file format" );
+    }
+
+public:
+    dynamic_io_fnobj(OpClass* op) : _op(op) {}
+
+    typedef void result_type;
+
+    template <typename View>
+    void operator()(const View& view) {apply(view,typename IsSupported::template apply<View>::type());}
+
+    template< typename View, typename Info >
+    void operator()(const View& view, const Info& info )
+    {
+        apply( view
+             , info
+             , typename IsSupported::template apply< View >::type()
+             );
+    }
+
+};
+
+} // namespace detail
+
+/// \brief Within the any_image, constructs an image with the given dimensions
+///        and a type that satisfies the given predicate
+template <typename Images,typename Pred>
+inline bool construct_matched(any_image<Images>& im,Pred pred) {
+    return detail::construct_matched_t<mpl::size<Images>::value>::apply(im,pred);
+}
+
+} }  // namespace boost::gil
+
+#endif // BOOST_GIL_EXTENSION_TOOLBOX_DYNAMIC_IMAGES_HPP
Index: boost-1.52.0/src/boost/gil/extension/toolbox/fill.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/fill.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,63 @@
+// Copyright Tom Brinkman 2008. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef _fill_hpp_
+#define _fill_hpp_
+
+#include <boost/function.hpp>
+#include <boost/gil/gil_all.hpp>
+
+namespace layer
+{
+
+template <typename view_t>
+struct fill
+{
+	typedef typename view_t::value_type value_type_t;
+	value_type_t color;
+	fill(value_type_t color) : color(color) {}
+
+	void operator()(view_t& view)
+	{
+		boost::gil::fill_pixels(view,color);
+	}
+};
+
+template <typename view_t>
+struct fill_horizontal
+{
+	typedef boost::function<void (view_t&)> funct_t;
+	double value1;
+	double value2;
+	double minvalue;
+	double maxvalue;
+	funct_t funct;
+	fill_horizontal(funct_t funct, double value1, double value2, double minvalue, double maxvalue) :
+		funct(funct), minvalue(minvalue), maxvalue(maxvalue), value1(value1), value2(value2) {}
+
+	void operator()(view_t& view)
+	{
+		using namespace boost::gil;
+
+		double diff = maxvalue-minvalue;
+		if (diff == 0)
+			return;
+
+		double rval = 1-((value1-minvalue)/(diff));
+		int y1 = (int)(rval*(view.height()-1));
+
+		rval = 1-((value2-minvalue)/(diff));
+		int y2 = (int)(rval*(view.height()-1));
+
+		int yt = (std::min)(y1,y2);
+		int yb = (std::max)(y1,y2);
+
+		view_t v2 = subimage_view(view,0,yt,view.width(),yb-yt);
+		funct(v2);
+	}
+};
+
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/fill.ppm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/fill.ppm	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,5 @@
+P6
+# CREATOR: reportbase
+200 200
+255
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
\ No newline at end of file
Index: boost-1.52.0/src/boost/gil/extension/toolbox/fill.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/fill.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,37 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <fill.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ fill.tests.cpp -I /home/scott/project/boost_1_36_0 -I .
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		layer::fill<rgb8_view_t> fill(rgb8_view_t::value_type(0,255,0));
+		layer::fill_horizontal<rgb8_view_t> horz(fill,20,40,0,100);
+		horz(view);
+		
+		FILE* fd = fopen("fill.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "fill tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/freegil.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/freegil.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,351 @@
+// Copyright Tom Brinkman 2008. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef _freegil_hpp_
+#define _freegil_hpp_
+
+#include <boost/gil/gil_all.hpp>
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_GLYPH_H
+#include FT_CACHE_H
+
+#include <blend.hpp>
+
+namespace layer
+{
+
+struct glyph
+{
+	glyph(char ch, FT_Face face, boost::gil::rgb8_pixel_t pixel) :
+		ch(ch), face(face), pixel(pixel){}
+
+	char ch;
+	FT_Face face;
+	boost::gil::rgb8_pixel_t pixel;
+};
+
+struct make_metric
+{
+	FT_Glyph_Metrics operator()(glyph& glyph)
+	{
+		BOOST_ASSERT(glyph.face);
+		int load_flags = FT_LOAD_DEFAULT;
+		int index = FT_Get_Char_Index(glyph.face,glyph.ch);
+		FT_Load_Glyph(glyph.face, index, load_flags);
+		return glyph.face->glyph->metrics;
+	}
+};
+
+struct make_width
+{
+	int advance;
+	int lasbwidth;
+	int lastadvance;
+	make_width() : advance(0), lasbwidth(0), lastadvance(0) {}
+	operator int(){return advance-(lastadvance-lasbwidth);}
+	void operator()(FT_Glyph_Metrics metrics)
+	{
+		lastadvance = metrics.horiAdvance >> 6; 
+		lasbwidth = (metrics.width >> 6);
+		advance += lastadvance;
+	}
+};
+
+struct make_advance_width
+{
+	int advance;
+	make_advance_width() : advance(0){}
+	operator int(){return advance;}
+	void operator()(FT_Glyph_Metrics metrics)
+	{
+		advance += metrics.horiAdvance >> 6;
+	}
+};
+
+struct make_advance_height
+{
+	int height;
+	make_advance_height() : height(0){}
+	operator int(){return height;}
+	void operator()(FT_Glyph_Metrics metrics)
+	{
+		int advance = (metrics.vertAdvance >> 6);
+		height = (std::max)(height,advance);
+	}
+};
+
+struct make_height
+{
+	int height;
+	make_height() : height(0){}
+	operator int(){return height;}
+	void operator()(FT_Glyph_Metrics metrics)
+	{
+		int h = (metrics.height >> 6);
+		height = (std::max)(height,h);
+	}
+};
+
+struct make_glyph_height
+{
+	int height;
+	make_glyph_height() : height(0) {} 
+	operator int(){return height;}
+	void operator()(FT_Glyph_Metrics metrics)
+	{
+		int n = (metrics.height >> 6) -(metrics.horiBearingY >> 6);
+		height = (std::max)(height,n);
+	}
+};
+
+struct find_last_fitted_glyph
+{
+	int width,x;
+	find_last_fitted_glyph(int width) : width(width),x(0){}
+	bool operator()(FT_Glyph_Metrics metric)
+	{
+		int tmp = x + (metric.width >> 6);
+		x += (metric.horiAdvance >> 6); 
+		return tmp > width;
+	}
+};
+
+template <typename view_t>
+struct render_glyphs
+{
+	int x;
+	const view_t& view;
+	render_glyphs(const view_t& view) : view(view), x(0) {}	
+
+	void operator()(glyph& glyph)
+	{
+		using namespace boost::gil;
+		
+		FT_GlyphSlot glyphslot = glyph.face->glyph; 
+		FT_Face face = glyph.face;			
+
+		int load_flags = FT_LOAD_DEFAULT;
+		int index = FT_Get_Char_Index(face,glyph.ch);
+		FT_Load_Glyph(face, index, load_flags);
+		FT_Render_Glyph(glyphslot, FT_RENDER_MODE_NORMAL);
+
+		int y = view.height() - (face->glyph->metrics.horiBearingY >> 6);
+		int width = face->glyph->metrics.width >> 6;
+		int height = face->glyph->metrics.height >> 6;
+		int xadvance = face->glyph->advance.x >> 6;
+
+		BOOST_ASSERT(view.width());
+		BOOST_ASSERT(width == glyphslot->bitmap.width);
+		BOOST_ASSERT(height == glyphslot->bitmap.rows);
+
+		gray8c_view_t gray = interleaved_view(width,height,
+			(gray8_pixel_t*)glyphslot->bitmap.buffer,glyphslot->bitmap.width);
+
+		copy<alpha24_blend>(glyph.pixel,gray,subimage_view(view,x,y,width,height));
+		x += xadvance; 
+	}
+};
+
+static inline FT_Error face_requester(FTC_FaceID id, FT_Library library, void* data, FT_Face* face)
+{
+	char** paths = (char**)data;
+	char* path = paths[(long)id]; 
+	return FT_New_Face(library, path, 0, face);
+}
+
+template <typename view_t>
+struct text
+{
+	enum 
+	{ 
+		left = (0x1 << 0),
+		center = (0x1 << 1),
+		right = (0x1 << 2),
+		top = (0x1 << 3),
+		ftop = (0x1 << 4),
+		middle = (0x1 << 5),  //when text is aligned adjacent to each other.
+		fmiddle = (0x1 << 6), //when the text is all by itself
+		bottom = (0x1 << 7),
+	}; 
+
+	enum
+	{
+		fill = (0x1 << 0),
+		clipspecial = (0x1 << 1),
+		fillexcess =  (0x1 << 2),
+	};
+
+	typedef typename view_t::value_type color_t;
+
+	FTC_Manager manager;
+	std::string str;
+	int id;
+	int size;
+	int align;
+	int options;
+	char special;
+	color_t color;
+	std::vector<glyph> glyphs;
+
+	text(FTC_Manager manager, std::string str, color_t color, 
+		int id, int size, int align = center|middle, int options = 0, char special = '#') : 
+			manager(manager), str(str), id(id), size(size), align(align), 
+				color(color), options(options), special(special){}
+
+	text(FTC_Manager manager, color_t color, 
+		int id, int size, int align = center|middle, int options = 0, char special = '.') : 
+			manager(manager), id(id), size(size), align(align), 
+				color(color), options(options), special(special){}
+
+	void operator()(view_t& view)
+	{
+		FTC_ScalerRec_ scaler;
+		scaler.face_id = (FTC_FaceID)id;
+		scaler.width = size;
+		scaler.height = size;
+		scaler.pixel = 1;
+		scaler.x_res = 0;
+		scaler.y_res = 0;
+		
+		FT_Size asize;
+		FT_Error error = FTC_Manager_LookupSize(manager, &scaler, &asize);
+		if (error)
+			return;
+		
+		for (int n = 0; n < str.size(); ++n)
+			glyphs.push_back(glyph(str[n],asize->face,color));
+
+		std::vector<FT_Glyph_Metrics> m;			
+		std::transform(glyphs.begin(),glyphs.end(), std::back_inserter(m), make_metric());		
+
+		int mwidth = std::for_each(m.begin(), m.end(), make_width());
+
+		if (options & fill || (options & fillexcess && mwidth > view.width()))
+		{
+			glyphs.clear();
+			for (int n = 0; n < 500; ++n)
+				glyphs.push_back(glyph(special,asize->face,color));
+
+			m.clear();			
+			std::transform(glyphs.begin(),glyphs.end(),
+				std::back_inserter(m), make_metric());
+		}
+
+		if (options & clipspecial)
+		{
+			int pos = -1;
+			for (pos = 0; pos < glyphs.size(); ++pos)
+				if (glyphs[pos].ch == special)
+					break;
+		
+			if (pos >= 1 && pos < glyphs.size())
+			{
+				std::vector<glyph> front,back;
+				std::copy(glyphs.begin(), glyphs.begin()+pos, std::back_inserter(front));
+				std::copy(glyphs.begin()+pos, glyphs.end(), std::back_inserter(back));
+				glyphs.clear();
+		
+				while (true)
+				{
+					std::vector<glyph> glyphs2;
+					std::copy(front.begin(),front.end(), std::back_inserter(glyphs2));	
+					std::copy(back.begin(),back.end(), std::back_inserter(glyphs2));	
+		
+					std::vector<FT_Glyph_Metrics> metrics;		
+					std::transform(glyphs2.begin(),glyphs2.end(),
+						std::back_inserter(metrics), make_metric());
+		
+					std::vector<FT_Glyph_Metrics>::iterator it = 
+						std::find_if(metrics.begin(),metrics.end(),
+							find_last_fitted_glyph(view.width()));
+
+					if (it != metrics.end())
+						front.pop_back();
+					else
+						break;
+				}
+		
+				std::copy(front.begin(), front.end(), std::back_inserter(glyphs));
+				std::copy(back.begin(), back.end(), std::back_inserter(glyphs));
+			}
+		}
+
+		m.clear();		
+		std::transform(glyphs.begin(),glyphs.end(), std::back_inserter(m), make_metric());
+
+		std::vector<FT_Glyph_Metrics>::iterator it = 
+			std::find_if(m.begin(), m.end(), find_last_fitted_glyph(view.width()));
+		int distance = (int)std::distance(it,m.end());
+		glyphs.erase(glyphs.end()-distance,glyphs.end());
+		
+		m.clear();		
+		std::transform(glyphs.begin(),glyphs.end(), std::back_inserter(m), make_metric());
+
+		mwidth = std::for_each(m.begin(), m.end(), make_width());
+		int mheight = std::for_each(m.begin(), m.end(), make_height());
+		int gheight = std::for_each(m.begin(), m.end(), make_glyph_height());
+
+		int x = 0;
+		if (align & center)
+			x = (view.width()-mwidth)/2;
+		else if (align & right)
+			x = view.width()-mwidth;
+	
+		int y = 0;
+		if (align & middle)
+			y = (view.height()-mheight-gheight)/2;
+		else if (align & fmiddle)
+			y = (view.height()-mheight)/2;
+		else if (align & bottom)
+			y = view.height()-mheight;
+
+		BOOST_ASSERT(!glyphs.empty());
+		view = subimage_view(view,x,y,mwidth,mheight);
+		std::for_each(glyphs.begin(), glyphs.end(), render_glyphs<view_t>(view));
+	}
+};
+
+template <typename view_t>
+struct elipsed_layer
+{
+	typedef typename view_t::value_type color_t;
+
+	FTC_Manager manager;
+	std::string sfront;
+	std::string sback;
+	int id;
+	int size;
+	color_t color;
+	static const int dwidth = 30;
+
+	elipsed_layer(FTC_Manager manager, std::string sfront, std::string sback, color_t color, int id, int size) : 
+			manager(manager), sfront(sfront), sback(sback), id(id), size(size), color(color){}
+
+	void operator()(view_t& view)
+	{
+		typedef text<view_t> text_t;
+
+		text_t lback(manager,sback,color,id,size,
+			text_t::right|text_t::bottom);
+		view_t vback = view;
+		lback(vback);
+		
+		text_t lfront(manager,sfront,color,id,size,
+			text_t::left|text_t::bottom);
+		int width = view.width()-vback.width()-dwidth;
+		view_t vfront = subimage_view(view,0,0,width,view.height());
+		lfront(vfront);
+
+		text_t ldots(manager,color,id,size,	
+			text_t::center|text_t::bottom,text_t::fill,'.');
+		width = view.width()-vfront.width()-vback.width();
+		view_t vdots = subimage_view(view,vfront.width(),0,width,view.height());		
+		ldots(vdots);
+	}	
+};
+
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/freegil.ppm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/freegil.ppm	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,5 @@
+P6
+# CREATOR: reportbase
+200 200
+255
++++   [[[      +++   [[[+++   [[[+++   [[[      +++   [[[+++   [[[+++   [[[      ___         +++   [[[+++   [[[___         +++   '''&&&      MMMGGG   &&&+++   [[[+++   [[[MMMGGG   &&&+++   555      +++   !!!GGG      +++   [[[+++   [[[+++   [[[      +++   [[[      +++   """_________+++   [[[+++   [[[+++   [[[      +++   [[[      PPPFFFPPPFFFPPPFFFPPPFFF   ***+++   [[[      ___            ___   '''___   '''___         
\ No newline at end of file
Index: boost-1.52.0/src/boost/gil/extension/toolbox/freegil.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/freegil.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,66 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <freegil.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ freegil.tests.cpp -I /home/scott/project/boost_1_36_0 -I . -I /usr/include/freetype2 -lfreetype
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view2 = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+		rgb8_view_t view = subimage_view(view2,0,0,width-5,height-5);
+
+		const char* fontnames [] = {"/Mini/MINIHHB_.TTF","/Mini/MINXB___.TTF"};
+		int size = sizeof(fontnames)/sizeof(const char*);
+
+		char fontpath[255];
+		strcpy(fontpath,getenv("FONT_PATH") ? getenv("FONT_PATH") : "/home/scott/project/fonts/");
+
+		char** fonts = (char**)malloc(size * sizeof(char*));
+		for (int n = 0; n < size; ++n)
+		{
+			char tmp[255];
+			sprintf(tmp,"%s%s",fontpath,fontnames[n]);
+			fonts[n] = (char*)malloc((strlen(tmp)+1) * sizeof(char));
+			sprintf(fonts[n],"%s",tmp);
+		}
+	
+		FT_Library library;
+		FTC_Manager manager;
+		FT_Init_FreeType(&library);
+		FTC_Manager_New(library,0,0,0,face_requester,fonts,&manager);
+
+		typedef layer::text<rgb8_view_t> text_t;
+		rgb8_view_t::value_type black(0,0,0);
+		text_t text(manager,"Hello",black,0,12);
+		text(view);
+
+		for (int n = 0; n < size; ++n)
+			free(fonts[n]);
+		free(fonts);
+
+		FTC_Manager_Done(manager);		
+		FT_Done_FreeType(library);
+
+		FILE* fd = fopen("freegil.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "freegil tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/gil_extensions.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/gil_extensions.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,305 @@
+/*
+    Copyright 2010 Christian Henning, Andreas Pokorny, Lubomir Bourdev
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_TOOLBOX_GIL_EXTENSIONS_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_TOOLBOX_GIL_EXTENSIONS_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief Definitions of is_bit_aligned, is_homogeneous, and is_similar metafunctions and
+///        some other goodies.
+/// \author Christian Henning, Andreas Pokorny, Lubomir Bourdev \n
+///
+/// \date   2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/gil_all.hpp>
+
+#include <boost/mpl/accumulate.hpp>
+#include <boost/mpl/if.hpp>
+
+#include <boost/gil/extension/toolbox/dynamic_images.hpp>
+
+namespace boost { namespace gil {
+
+/// is_bit_aligned metafunctions
+/// \brief Determines whether the given type is bit_aligned.
+
+template< typename PixelRef >
+struct is_bit_aligned : mpl::false_{};
+
+template <typename B, typename C, typename L, bool M>  
+struct is_bit_aligned<bit_aligned_pixel_reference<B,C,L,M> > : mpl::true_{};
+
+template <typename B, typename C, typename L, bool M>  
+struct is_bit_aligned<const bit_aligned_pixel_reference<B,C,L,M> > : mpl::true_{};
+
+template <typename B, typename C, typename L>  
+struct is_bit_aligned<packed_pixel<B,C,L> > : mpl::true_{};
+
+template <typename B, typename C, typename L>  
+struct is_bit_aligned<const packed_pixel<B,C,L> > : mpl::true_{};
+
+
+/// is_similar metafunctions
+/// \brief Determines if two pixel types are similar.
+
+template< typename A, typename B >
+struct is_similar : mpl::false_ {};
+
+template<typename A>
+struct is_similar< A, A > : mpl::true_ {};
+
+template<typename B,int I, int S, bool M, int I2>
+struct is_similar< packed_channel_reference< B,  I, S, M >
+                 , packed_channel_reference< B, I2, S, M >
+                 > : mpl::true_ {};
+
+/// is_homogeneous metafunctions
+/// \brief Determines if a pixel types are homogeneous.
+
+template<typename C,typename CMP, int Next, int Last> struct is_homogeneous_impl;
+
+template<typename C,typename CMP, int Last>
+struct is_homogeneous_impl<C,CMP,Last,Last> : mpl::true_{};
+
+template<typename C,typename CMP, int Next, int Last>
+struct is_homogeneous_impl : mpl::and_< is_homogeneous_impl< C, CMP,Next + 1, Last >
+                                      , is_same< CMP, typename mpl::at_c<C,Next>::type
+                                      > > {};
+
+template < typename P > struct is_homogeneous : mpl::false_ {};
+
+// pixel
+template < typename C, typename L > struct is_homogeneous< pixel<C,L> > : mpl::true_ {};
+template < typename C, typename L > struct is_homogeneous<const pixel<C,L> > : mpl::true_ {};
+template < typename C, typename L > struct is_homogeneous< pixel<C,L>& > : mpl::true_ {};
+template < typename C, typename L > struct is_homogeneous<const pixel<C,L>& > : mpl::true_ {};
+
+// planar pixel reference
+template <typename Channel, typename ColorSpace>
+struct is_homogeneous< planar_pixel_reference< Channel, ColorSpace > > : mpl::true_ {};
+template <typename Channel, typename ColorSpace>
+struct is_homogeneous< const planar_pixel_reference< Channel, ColorSpace > > : mpl::true_ {};
+
+template<typename C,typename CMP, int I,int Last>
+struct is_homogeneous_impl_p {};
+
+// for packed_pixel
+template <typename B, typename C, typename L >
+struct is_homogeneous<packed_pixel< B, C, L > > 
+	: is_homogeneous_impl_p< C 
+                           , typename mpl::at_c< C, 0 >::type
+                           , 1
+                           , mpl::size< C >::type::value
+                           > {};
+
+template< typename B
+        , typename C
+        , typename L
+        >  
+struct is_homogeneous< const packed_pixel< B, C, L > > 
+	: is_homogeneous_impl_p< C
+	                       , typename mpl::at_c<C,0>::type
+	                       , 1
+	                       , mpl::size< C >::type::value
+	                       > {};
+
+// for bit_aligned_pixel_reference
+template <typename B, typename C, typename L, bool M>  
+struct is_homogeneous<bit_aligned_pixel_reference<B,C,L,M> > 
+	: is_homogeneous_impl<C,typename mpl::at_c<C,0>::type,1,mpl::size<C>::type::value>
+{};
+
+template <typename B, typename C, typename L, bool M>  
+struct is_homogeneous<const bit_aligned_pixel_reference<B,C,L,M> > 
+	: is_homogeneous_impl<C,typename mpl::at_c<C,0>::type,1,mpl::size<C>::type::value>
+{};
+
+//////////////////////
+/// other goodies
+
+/// get_num_bits metafunctions
+/// \brief Determines the numbers of bits for the given channel type.
+
+template <typename T>
+struct get_num_bits;
+
+template< typename B, int I, int S, bool M >
+struct get_num_bits< packed_channel_reference< B, I, S, M > >
+{
+    BOOST_STATIC_CONSTANT( int, value = S );
+};
+
+template<typename B,int I, int S, bool M>
+struct get_num_bits< const packed_channel_reference< B, I, S, M > >
+{
+    BOOST_STATIC_CONSTANT( int, value = S );
+};
+
+
+/// channel_type metafunction
+/// \brief Generates the channel type for 
+
+
+template <typename B, typename C, typename L, bool M>  
+struct gen_chan_ref
+{
+	typedef packed_dynamic_channel_reference< B
+	                                        , mpl::at_c< C, 0 >::type::value
+	                                        , M
+	                                        > type;
+};
+
+
+//! This implementation works for bit_algined_pixel_reference 
+//! with a homogeneous channel layout. 
+//! The result type will be a packed_dynamic_channel_reference, since the 
+//! offset info will be missing. 
+
+// bit_aligned_pixel_reference
+template <typename B, typename C, typename L, bool M>  
+struct channel_type< bit_aligned_pixel_reference<B,C,L,M> > 
+	: lazy_enable_if< is_homogeneous< bit_aligned_pixel_reference< B, C, L, M > >
+                    , gen_chan_ref< B, C, L, M >
+		            > {};
+
+template <typename B, typename C, typename L, bool M>  
+struct channel_type<const bit_aligned_pixel_reference<B,C,L,M> > 
+	: lazy_enable_if< is_homogeneous< bit_aligned_pixel_reference< B, C, L, M > >
+	                , gen_chan_ref< B, C, L, M >
+		            > {};
+
+template <typename B, typename C, typename L>  
+struct gen_chan_ref_p
+{
+	typedef packed_dynamic_channel_reference< B
+	                                        , get_num_bits< typename mpl::at_c<C,0>::type>::value
+	                                        , true
+	                                        > type;
+};
+
+// packed_pixel
+template < typename BitField
+         , typename ChannelRefVec
+         , typename Layout
+         >
+struct channel_type< packed_pixel< BitField
+                                 , ChannelRefVec
+                                 , Layout
+                                 >
+                   > : lazy_enable_if< is_homogeneous< packed_pixel< BitField
+                                                                   , ChannelRefVec
+                                                                   , Layout
+                                                                   >
+                                                     >
+                                     , gen_chan_ref_p< BitField
+                                                     , ChannelRefVec
+                                                     , Layout
+                                                     >
+		                             > {};
+
+template <typename B, typename C, typename L>  
+struct channel_type< const packed_pixel< B, C, L > > 
+	: lazy_enable_if< is_homogeneous<packed_pixel< B, C, L > >
+	                , gen_chan_ref_p< B, C, L >
+		            >
+{};
+
+template<>
+struct channel_type< any_image_pixel_t >
+{
+    typedef any_image_channel_t type;
+};
+
+template<>
+struct color_space_type< any_image_pixel_t >
+{
+    typedef any_image_color_space_t type;
+};
+
+/// get_pixel_type metafunction
+/// \brief Depending on Image this function generates either 
+///        the pixel type or the reference type in case
+///        the image is bit_aligned.
+template< typename View >
+struct get_pixel_type : mpl::if_< typename is_bit_aligned< typename View::value_type >::type
+                                , typename View::reference
+                                , typename View::value_type
+                                > {};
+
+template< typename ImageViewTypes >
+struct get_pixel_type< any_image_view< ImageViewTypes > >
+{
+    typedef any_image_pixel_t type;
+};
+
+namespace detail {
+
+/// - performance specialization double
+/// - to eliminate compiler warning 4244
+template <typename GrayChannelValue>
+struct rgb_to_luminance_fn< double, double, double, GrayChannelValue >
+{
+    GrayChannelValue operator()( const double& red
+                               , const double& green
+                               , const double& blue    ) const
+   {
+      return channel_convert<GrayChannelValue>( red * 0.30 + green * 0.59 + blue * 0.11 );
+   }
+};
+
+} // namespace detail
+
+/// This one is missing in gil ( color_convert.hpp ).
+template <>
+struct default_color_converter_impl<gray_t,rgba_t>
+{
+    template <typename P1, typename P2>
+    void operator()(const P1& src, P2& dst) const
+    {
+        get_color(dst,red_t())  =
+            channel_convert<typename color_element_type<P2, red_t  >::type>(get_color(src,gray_color_t()));
+        get_color(dst,green_t())=
+            channel_convert<typename color_element_type<P2, green_t>::type>(get_color(src,gray_color_t()));
+        get_color(dst,blue_t()) =
+            channel_convert<typename color_element_type<P2, blue_t >::type>(get_color(src,gray_color_t()));
+
+        typedef typename channel_type< P2 >::type channel_t;
+        get_color(dst,alpha_t()) = channel_traits< channel_t >::max_value();
+    }
+};
+
+
+/// pixel_bit_size metafunctions
+/// \brief Accumulates the all channel size.
+/// e.g.
+/// typedef bit_aligned_image5_type< 16, 16, 16, 8, 8, devicen_layout_t< 5 > >::type image_t;
+/// const int size = pixel_bit_size<image_t::view_t::reference>::value;
+template< typename PixelRef >
+struct pixel_bit_size : mpl::int_<0> {};
+
+template <typename B, typename C, typename L, bool M>  
+struct pixel_bit_size<bit_aligned_pixel_reference<B,C,L,M> > : mpl::int_< mpl::accumulate< C, mpl::int_<0>, mpl::plus<mpl::_1, mpl::_2> >::type::value >{};
+
+template <typename B, typename C, typename L, bool M>  
+struct pixel_bit_size<const bit_aligned_pixel_reference<B,C,L,M> > : mpl::int_< mpl::accumulate< C, mpl::int_<0>, mpl::plus<mpl::_1, mpl::_2> >::type::value >{};
+
+template <typename B, typename C, typename L>  
+struct pixel_bit_size<packed_pixel<B,C,L> > : mpl::int_< mpl::accumulate< C, mpl::int_<0>, mpl::plus<mpl::_1, mpl::_2> >::type::value >{};
+
+template <typename B, typename C, typename L>  
+struct pixel_bit_size<const packed_pixel<B,C,L> > : mpl::int_< mpl::accumulate< C, mpl::int_<0>, mpl::plus<mpl::_1, mpl::_2> >::type::value >{};
+
+
+} // namespace gil
+} // namespace boost
+
+#endif // BOOST_GIL_EXTENSION_TOOLBOX_GIL_EXTENSIONS_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/toolbox/gray_alpha.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/gray_alpha.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,101 @@
+/*
+    Copyright 2007-2008 Andreas Pokorny
+    Use, modification and distribution are subject to the Boost Software License,
+    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt).
+*/
+
+/*************************************************************************************************/
+
+
+#ifndef BOOST_GIL_GRAY_ALPHA_HPP_INCLUDED
+#define BOOST_GIL_GRAY_ALPHA_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief
+/// \author Andreas Pokorny \n
+///         
+/// \date   2007-2008 \n
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/gil_config.hpp>
+#include <boost/mpl/contains.hpp>
+#include <boost/gil/gray.hpp>
+#include <boost/gil/typedefs.hpp>
+
+namespace boost { namespace gil {
+
+typedef mpl::vector2<gray_color_t,alpha_t> gray_alpha_t;
+
+typedef layout<gray_alpha_t> gray_alpha_layout_t;
+typedef layout<gray_alpha_layout_t, mpl::vector2_c<int,1,0> > alpha_gray_layout_t;
+
+GIL_DEFINE_BASE_TYPEDEFS(8,  alpha_gray)
+GIL_DEFINE_BASE_TYPEDEFS(8s, alpha_gray)
+GIL_DEFINE_BASE_TYPEDEFS(16, alpha_gray)
+GIL_DEFINE_BASE_TYPEDEFS(16s,alpha_gray)
+GIL_DEFINE_BASE_TYPEDEFS(32 ,alpha_gray)
+GIL_DEFINE_BASE_TYPEDEFS(32s,alpha_gray)
+GIL_DEFINE_BASE_TYPEDEFS(32f,alpha_gray)
+
+GIL_DEFINE_ALL_TYPEDEFS(8,  gray_alpha)
+GIL_DEFINE_ALL_TYPEDEFS(8s, gray_alpha)
+GIL_DEFINE_ALL_TYPEDEFS(16, gray_alpha)
+GIL_DEFINE_ALL_TYPEDEFS(16s,gray_alpha)
+GIL_DEFINE_ALL_TYPEDEFS(32 ,gray_alpha)
+GIL_DEFINE_ALL_TYPEDEFS(32s,gray_alpha)
+GIL_DEFINE_ALL_TYPEDEFS(32f,gray_alpha)
+
+/// \ingroup ColorConvert
+/// \brief Gray Alpha to RGBA
+template <>
+struct default_color_converter_impl<gray_alpha_t,rgba_t> {
+    template <typename P1, typename P2>
+    void operator()(const P1& src, P2& dst) const {
+        get_color(dst,red_t())  =
+            channel_convert<typename color_element_type<P2, red_t>::type>(get_color(src,gray_color_t()));
+        get_color(dst,green_t())=
+            channel_convert<typename color_element_type<P2, green_t>::type>(get_color(src,gray_color_t()));
+        get_color(dst,blue_t()) =
+            channel_convert<typename color_element_type<P2, blue_t>::type>(get_color(src,gray_color_t()));
+        get_color(dst,alpha_t()) =
+            channel_convert<typename color_element_type<P2, alpha_t>::type>(get_color(src,alpha_t()));
+    }
+};
+
+template <>
+struct default_color_converter_impl<gray_alpha_t,rgb_t> {
+    template <typename P1, typename P2>
+    void operator()(const P1& src, P2& dst) const {
+        get_color(dst,red_t())  =
+            channel_convert<typename color_element_type<P2, red_t>::type>(
+                channel_multiply(get_color(src,gray_color_t()),get_color(src,alpha_t()) ) 
+                );
+        get_color(dst,green_t())  =
+            channel_convert<typename color_element_type<P2, green_t>::type>(
+                channel_multiply(get_color(src,gray_color_t()),get_color(src,alpha_t()) ) 
+                );
+        get_color(dst,blue_t())  =
+            channel_convert<typename color_element_type<P2, blue_t>::type>(
+                channel_multiply(get_color(src,gray_color_t()),get_color(src,alpha_t()) ) 
+                );
+    }
+};
+
+template <>
+struct default_color_converter_impl<gray_alpha_t,gray_t> {
+    template <typename P1, typename P2>
+    void operator()(const P1& src, P2& dst) const {
+        get_color(dst,gray_color_t())  =
+            channel_convert<typename color_element_type<P2, gray_color_t>::type>(
+                channel_multiply(get_color(src,gray_color_t()),get_color(src,alpha_t()) ) 
+                );
+    }
+};
+
+} // gil
+} // boost
+
+#endif // BOOST_GIL_GRAY_ALPHA_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/toolbox/hsl.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/hsl.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,262 @@
+// Copyright 2007 Christian Henning.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef GIL_HSL_H
+#define GIL_HSL_H
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief Support for HSL color space
+/// \author Christian Henning \n
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/gil/gil_all.hpp>
+
+namespace boost { namespace gil {
+
+/// \addtogroup ColorNameModel
+/// \{
+namespace hsl_color_space
+{
+/// \brief Hue
+struct hue_t {};    
+/// \brief Saturation
+struct saturation_t {};
+/// \brief Lightness
+struct lightness_t {}; 
+}
+/// \}
+
+/// \ingroup ColorSpaceModel
+typedef mpl::vector3< hsl_color_space::hue_t
+                    , hsl_color_space::saturation_t
+                    , hsl_color_space::lightness_t
+                    > hsl_t;
+
+/// \ingroup LayoutModel
+typedef layout<hsl_t> hsl_layout_t;
+
+
+GIL_DEFINE_ALL_TYPEDEFS( 32f, hsl );
+
+/// \ingroup ColorConvert
+/// \brief RGB to HSL
+template <>
+struct default_color_converter_impl< rgb_t, hsl_t >
+{
+   template <typename P1, typename P2>
+   void operator()( const P1& src, P2& dst ) const
+   {
+      using namespace hsl_color_space;
+
+      // only bits32f for hsl is supported
+      bits32f temp_red   = channel_convert<bits32f>( get_color( src, red_t()   ));
+      bits32f temp_green = channel_convert<bits32f>( get_color( src, green_t() ));
+      bits32f temp_blue  = channel_convert<bits32f>( get_color( src, blue_t()  ));
+
+      bits32f hue, saturation, lightness;
+
+      bits32f min_color = (std::min)( temp_red, (std::min)( temp_green, temp_blue ));
+      bits32f max_color = (std::max)( temp_red, (std::max)( temp_green, temp_blue ));
+
+      if( abs( min_color - max_color ) < 0.001 )
+      {
+         // rgb color is gray
+
+         hue        = 0.f;
+         saturation = 0.f;
+
+         // doesn't matter which rgb channel we use.
+         lightness = temp_red;
+      }
+      else
+      {
+
+         bits32f diff = max_color - min_color;
+
+         // lightness calculation
+
+         lightness = ( min_color + max_color ) / 2.f;
+
+         // saturation calculation
+
+         if( lightness < 0.5f )
+         {
+            saturation = diff 
+                       / ( min_color + max_color );
+         }
+         else
+         {
+            saturation = ( max_color - min_color ) 
+                       / ( 2.f - diff );
+
+         }
+
+         // hue calculation
+         if( abs( max_color - temp_red ) < 0.0001f )
+         {
+            // max_color is red
+            hue = ( temp_green - temp_blue ) 
+                / diff;
+
+         }
+         else if( abs( max_color - temp_green) < 0.0001f )
+         {
+            // max_color is green
+            // 2.0 + (b - r) / (maxColor - minColor);
+            hue = 2.f 
+                + ( temp_blue - temp_red ) 
+                / diff;
+
+         }
+         else
+         {
+            // max_color is blue
+            hue = 4.f 
+                + ( temp_red - temp_blue ) 
+                / diff;
+         }
+
+         hue /= 6.f;
+         
+         if( hue < 0.f )
+         {
+            hue += 1.f;
+         }
+      }
+
+      get_color( dst,hue_t() )        = hue;
+      get_color( dst,saturation_t() ) = saturation;
+      get_color( dst,lightness_t() )  = lightness;
+   }
+};
+
+/// \ingroup ColorConvert
+/// \brief HSL to RGB
+template <>
+struct default_color_converter_impl<hsl_t,rgb_t>
+{
+   template <typename P1, typename P2>
+   void operator()( const P1& src, P2& dst) const
+   {
+      using namespace hsl_color_space;
+
+      bits32f red, green, blue;
+
+      if( abs( get_color( src, saturation_t() )) < 0.0001  )
+      {
+         // If saturation is 0, the color is a shade of gray
+         red   = get_color( src, lightness_t() );
+         green = get_color( src, lightness_t() );
+         blue  = get_color( src, lightness_t() );
+      }
+      else
+      {
+         float temp1, temp2;
+         float tempr, tempg, tempb;
+
+         //Set the temporary values
+         if( get_color( src, lightness_t() ) < 0.5 ) 
+         {
+            temp2 = get_color( src, lightness_t() )
+                  * ( 1.f + get_color( src, saturation_t() ) );
+         }
+         else
+         {
+            temp2 = ( get_color( src, lightness_t() ) + get_color( src, saturation_t() )) 
+                  - ( get_color( src, lightness_t() ) * get_color( src, saturation_t() ));
+         }
+
+         temp1 = 2.f
+               * get_color( src, lightness_t() ) 
+               - temp2;
+
+         tempr = get_color( src, hue_t() ) + 1.f / 3.f;    
+
+         if( tempr > 1.f )
+         {
+            tempr--;
+         }
+
+         tempg = get_color( src, hue_t() );     
+         tempb = get_color( src, hue_t() ) - 1.f / 3.f;
+
+         if( tempb < 0.f )
+         {
+            tempb++;
+         }
+
+         //Red     
+         if( tempr < 1.f / 6.f )
+         {
+            red = temp1 + ( temp2 - temp1 ) * 6.f * tempr;
+         }
+         else if( tempr < 0.5f )
+         {
+            red = temp2;
+         }
+         else if( tempr < 2.f / 3.f )
+         {
+            red = temp1 + (temp2 - temp1) 
+                * (( 2.f / 3.f ) - tempr) * 6.f;
+         }
+         else
+         {
+            red = temp1;
+         }
+
+         //Green       
+         if( tempg < 1.f / 6.f )
+         {
+            green = temp1 + ( temp2 - temp1 ) * 6.f * tempg;
+         }
+         else if( tempg < 0.5f )
+         {
+            green = temp2;
+         }
+         else if( tempg < 2.f / 3.f )
+         {
+            green = temp1 + ( temp2 - temp1 )
+                  * (( 2.f / 3.f ) - tempg) * 6.f;
+         }
+         else
+         {
+            green = temp1;
+         }
+
+         //Blue    
+         if( tempb < 1.f / 6.f )
+         {
+            blue = temp1 + (temp2 - temp1) * 6.f * tempb;
+         }
+         else if( tempb < 0.5f )
+         {
+            blue = temp2;
+         }
+         else if( tempb < 2.f / 3.f )
+         {
+            blue = temp1 + (temp2 - temp1) 
+                 * (( 2.f / 3.f ) - tempb) * 6.f;
+         }
+         else
+         {
+            blue = temp1;
+         }
+      }
+
+      get_color(dst,red_t())  =
+         channel_convert<typename color_element_type< P2, red_t >::type>( red );
+      get_color(dst,green_t())=
+         channel_convert<typename color_element_type< P2, green_t >::type>( green );
+      get_color(dst,blue_t()) =
+         channel_convert<typename color_element_type< P2, blue_t >::type>( blue );
+   }
+};
+
+} }  // namespace boost::gil
+
+#endif // GIL_HSL_H
Index: boost-1.52.0/src/boost/gil/extension/toolbox/hsl_algorithms.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/hsl_algorithms.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,44 @@
+#ifndef HSL_ALGORITHMS_HPP
+#define HSL_ALGORITHMS_HPP
+
+#include <boost/gil/gil_all.hpp>
+
+namespace boost { namespace gil {
+namespace toolbox {
+
+template< typename HSL_VIEW >
+void shift_hue( const HSL_VIEW& img
+              , const bits32f   value )
+{
+   // make sure src and dst are views
+   // make sure src and dst are either hsl or hsv
+
+   for( int y = 0; y < img.height(); ++y )
+   {
+      HSL_VIEW::x_iterator img_it = img.row_begin( y );
+
+      for( int x = 0; x < img.width(); ++x )
+      {
+         bits32f& hue = get_color( img_it[x], boost::gil::hsl_color_space::hue_t() );
+
+         hue += value;
+
+         if( hue > 1.f )
+         {
+            hue -= 1.f;
+         }
+
+         if( hue < 0.f )
+         {
+            hue = 0.f;
+         }
+      }
+   }
+}
+
+
+} //namespace toolbox
+} //namespace gil
+} //namespace boost
+
+#endif // HSL_ALGORITHMS_HPP
\ No newline at end of file
Index: boost-1.52.0/src/boost/gil/extension/toolbox/hsv.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/hsv.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,231 @@
+// Copyright 2004 Christian Henning.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef GIL_HSV_H
+#define GIL_HSV_H
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief Support for HSV color space
+/// \author Christian Henning \n
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/cast.hpp>
+#include <boost/gil/gil_all.hpp>
+
+namespace boost { namespace gil {
+
+/// \addtogroup ColorNameModel
+/// \{
+namespace hsv_color_space
+{
+/// \brief Hue
+struct hue_t {};    
+/// \brief Saturation
+struct saturation_t{};
+/// \brief Value
+struct value_t {}; 
+}
+/// \}
+
+/// \ingroup ColorSpaceModel
+typedef mpl::vector3< hsv_color_space::hue_t
+                    , hsv_color_space::saturation_t
+                    , hsv_color_space::value_t
+                    > hsv_t;
+
+/// \ingroup LayoutModel
+typedef layout<hsv_t> hsv_layout_t;
+
+
+GIL_DEFINE_ALL_TYPEDEFS( 32f, hsv )
+
+/// \ingroup ColorConvert
+/// \brief RGB to HSV
+template <>
+struct default_color_converter_impl< rgb_t, hsv_t >
+{
+   template <typename P1, typename P2>
+   void operator()( const P1& src, P2& dst ) const
+   {
+      using namespace hsv_color_space;
+
+      // only bits32f for hsv is supported
+      bits32f temp_red   = channel_convert<bits32f>( get_color( src, red_t()   ));
+      bits32f temp_green = channel_convert<bits32f>( get_color( src, green_t() ));
+      bits32f temp_blue  = channel_convert<bits32f>( get_color( src, blue_t()  ));
+
+      bits32f hue, saturation, value;
+
+      bits32f min_color = (std::min)( temp_red, (std::min)( temp_green, temp_blue ));
+      bits32f max_color = (std::max)( temp_red, (std::max)( temp_green, temp_blue ));
+
+      value = max_color;
+
+      bits32f diff = max_color - min_color;
+
+      if( max_color < 0.0001f )
+      {  
+         saturation = 0.f;
+      }
+      else  
+      {      
+         saturation = diff / max_color;
+      }
+
+
+      if( saturation < 0.0001f )
+      {
+         //it doesn't matter what value it has
+         hue = 0.f; 
+      }   
+      else
+      { 
+         if( (std::abs)( boost::numeric_cast<int>(temp_red - max_color) ) < 0.0001f )
+         {
+            hue = ( temp_green - temp_blue )
+                / diff;
+         }
+         else if( temp_green == max_color )
+         {
+            hue = 2.f + ( temp_blue - temp_red ) 
+                / diff;
+         }
+         else
+         {
+            hue = 4.f + ( temp_red - temp_green ) 
+                / diff;
+         }
+
+         //to bring it to a number between 0 and 1
+         hue /= 6.f; 
+
+         if( hue < 0.f )
+         {
+            hue++;
+         }
+      }
+
+      get_color( dst, hue_t() )        = hue;
+      get_color( dst, saturation_t() ) = saturation;
+      get_color( dst, value_t() )      = value;
+   }
+};
+
+/// \ingroup ColorConvert
+/// \brief HSV to RGB
+template <>
+struct default_color_converter_impl<hsv_t,rgb_t>
+{
+   template <typename P1, typename P2>
+   void operator()( const P1& src, P2& dst) const
+   {
+      using namespace hsv_color_space;
+
+      bits32f red, green, blue;
+
+      //If saturation is 0, the color is a shade of gray
+      if( abs( get_color( src, saturation_t() )) < 0.0001f  )
+      {
+         // If saturation is 0, the color is a shade of gray
+         red   = get_color( src, value_t() );
+         green = get_color( src, value_t() );
+         blue  = get_color( src, value_t() );
+      }
+      else
+      {
+         bits32f frac, p, q, t, h;
+         bits32 i;
+
+         //to bring hue to a number between 0 and 6, better for the calculations
+         h = get_color( src, hue_t() );
+         h *= 6.f;
+
+         i = static_cast<bits32>( floor( h ));
+
+         frac = h - i;
+
+         p = get_color( src, value_t() ) 
+           * ( 1.f - get_color( src, saturation_t() ));
+
+         q = get_color( src, value_t() )
+           * ( 1.f - ( get_color( src, saturation_t() ) * frac ));
+
+         t = get_color( src, value_t() ) 
+           * ( 1.f - ( get_color( src, saturation_t() ) * ( 1.f - frac )));
+
+         switch( i )
+         {         
+            case 0: 
+            {
+               red   = get_color( src, value_t() );
+               green = t;
+               blue  = p;
+
+               break;
+            }
+
+            case 1: 
+            {
+               red   = q;
+               green = get_color( src, value_t() );
+               blue  = p;
+
+               break;
+            }
+
+            case 2: 
+            {
+               red   = p;
+               green = get_color( src, value_t() );
+               blue  = t;
+
+               break;
+            }
+
+            case 3: 
+            {
+               red   = p;
+               green = q;
+               blue  = get_color( src, value_t() );
+
+               break;
+            }
+
+            case 4: 
+            {
+               red   = t;
+               green = p;
+               blue  = get_color( src, value_t() );
+
+               break;
+            }
+
+            case 5: 
+            {
+               red   = get_color( src, value_t() );
+               green = p; 
+               blue  = q;
+
+               break;
+            }
+
+         }
+      }
+
+      get_color(dst,red_t())  =
+         channel_convert<typename color_element_type< P2, red_t >::type>( red );
+      get_color(dst,green_t())=
+         channel_convert<typename color_element_type< P2, green_t >::type>( green );
+      get_color(dst,blue_t()) =
+         channel_convert<typename color_element_type< P2, blue_t >::type>( blue );
+   }
+};
+
+} }  // namespace boost::gil
+
+#endif // GIL_HSV_H
Index: boost-1.52.0/src/boost/gil/extension/toolbox/indexed_image.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/indexed_image.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,353 @@
+// Copyright 2009 Christian Henning.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef BOOST_GIL_EXTENSION_TOOLBOX_INDEXED_IMAGE_HPP_INCLUDED
+#define BOOST_GIL_EXTENSION_TOOLBOX_INDEXED_IMAGE_HPP_INCLUDED
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file   indexed_image.hpp
+/// \brief  Indexed Image extension
+/// \author Christian Henning \n
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/type_traits/is_integral.hpp>
+#include <boost/utility/enable_if.hpp>
+
+#include <boost/gil/image.hpp>
+
+#include <boost/gil/extension/toolbox/gil_extensions.hpp>
+
+namespace boost { namespace gil {
+
+typedef boost::gil::point2< std::ptrdiff_t > point_t;
+
+template< typename Locator >
+struct get_pixel_type_locator : mpl::if_< typename is_bit_aligned< typename Locator::value_type >::type
+                                        , typename Locator::reference
+                                        , typename Locator::value_type
+                                        > {};
+
+// used for virtual locator
+template< typename IndicesLoc
+        , typename PaletteLoc
+        >
+struct indexed_image_deref_fn_base
+{
+    typedef IndicesLoc indices_locator_t;
+    typedef PaletteLoc palette_locator_t;
+    //typedef typename get_pixel_type_locator< indices_locator_t >::type index_t;
+ 
+    typedef IndicesLoc indices_locator_t;
+    typedef PaletteLoc palette_locator_t;
+
+    typedef indexed_image_deref_fn_base     const_t;
+    typedef typename PaletteLoc::value_type value_type;
+    typedef value_type                      reference;
+    typedef value_type                      const_reference;
+    typedef point_t                         argument_type;
+    typedef reference                       result_type;
+
+    static const bool is_mutable = false;
+
+    indexed_image_deref_fn_base() {}
+
+    indexed_image_deref_fn_base( const indices_locator_t& indices_loc
+                               , const palette_locator_t& palette_loc
+                               )
+    : _indices_loc( indices_loc )
+    , _palette_loc( palette_loc )
+    {}
+
+    void set_indices( const indices_locator_t& indices_loc ) { _indices_loc = indices_loc; }
+    void set_palette( const palette_locator_t& palette_loc ) { _palette_loc = palette_loc; }
+
+    const indices_locator_t& indices() const { return _indices_loc; }
+    const palette_locator_t& palette() const { return _palette_loc; }
+
+protected:
+
+    indices_locator_t _indices_loc;
+    palette_locator_t _palette_loc;
+};
+
+
+// used for virtual locator
+template< typename IndicesLoc
+        , typename PaletteLoc
+        , typename Enable = void // there is specilization for integral indices
+        >
+struct indexed_image_deref_fn : indexed_image_deref_fn_base< IndicesLoc
+                                                           , PaletteLoc
+                                                           >
+{
+    indexed_image_deref_fn()
+    : indexed_image_deref_fn_base()
+    {}
+
+    indexed_image_deref_fn( const indices_locator_t& indices_loc
+                          , const palette_locator_t& palette_loc
+                          )
+    : indexed_image_deref_fn_base( indices_loc
+                                 , palette_loc
+                                 )
+    {}
+
+    result_type operator()( const point_t& p ) const
+    {
+        return *_palette_loc.xy_at( at_c<0>( *_indices_loc.xy_at( p )), 0 );
+    }
+};
+
+
+template< typename IndicesLoc
+        , typename PaletteLoc
+        >
+struct indexed_image_deref_fn< IndicesLoc
+                             , PaletteLoc
+                             , typename boost::enable_if< boost::is_integral< typename IndicesLoc::value_type > >::type
+                             > : indexed_image_deref_fn_base< IndicesLoc
+                                                            , PaletteLoc
+                                                            >
+{
+    indexed_image_deref_fn()
+    : indexed_image_deref_fn_base()
+    {}
+
+    indexed_image_deref_fn( const indices_locator_t& indices_loc
+                          , const palette_locator_t& palette_loc
+                          )
+    : indexed_image_deref_fn_base( indices_loc
+                                 , palette_loc
+                                 )
+    {}
+
+    result_type operator()( const point_t& p ) const
+    {
+        return *_palette_loc.xy_at( *_indices_loc.xy_at( p ), 0 );
+    }
+};
+
+template< typename IndicesLoc
+        , typename PaletteLoc
+        >
+struct indexed_image_locator_type
+{
+    typedef virtual_2d_locator< indexed_image_deref_fn< IndicesLoc
+                                                      , PaletteLoc
+                                                      >
+                              , false
+                              > type;
+};
+
+template< typename Locator > // indexed_image_locator_type< ... >::type
+class indexed_image_view : public image_view< Locator >
+{
+public:
+
+    typedef typename Locator::deref_fn_t deref_fn_t;
+    typedef typename deref_fn_t::indices_locator_t indices_locator_t;
+    typedef typename deref_fn_t::palette_locator_t palette_locator_t;
+
+    typedef indexed_image_view< Locator > const_t;
+
+    typedef image_view< indices_locator_t > indices_view_t;
+    typedef image_view< palette_locator_t > palette_view_t;
+
+    indexed_image_view()
+    : image_view()
+    , _num_colors( 0 )
+    {}
+
+    indexed_image_view( const point_t& dimensions
+                      , std::size_t    num_colors
+                      , const Locator& locator
+                      )
+    : image_view( dimensions, locator )
+    , _num_colors( num_colors )
+    {}
+
+    template< typename IndexedView >
+    indexed_image_view( const IndexedView& iv )
+    : image_view( iv )
+    , _num_colors( iv._num_colors )
+    {}
+
+    const std::size_t num_colors() const { return _num_colors; }
+
+    
+    const indices_locator_t& indices() const { return get_deref_fn().indices(); }
+    const palette_locator_t& palette() const { return get_deref_fn().palette(); }
+
+    const indices_view_t get_indices_view() const { return indices_view_t( dimensions(), indices() ); }
+    const palette_view_t get_palette_view() const { return palette_view_t( point_t( num_colors(), 1 )
+                                                                         , palette()
+                                                                         ); }
+
+private:
+
+    const deref_fn_t& get_deref_fn() const { return pixels().deref_fn(); }
+
+private:
+
+    template< typename Locator2 > friend class indexed_image_view;
+
+    std::size_t _num_colors;
+};
+
+
+template< typename Index
+        , typename Pixel
+        , typename IndicesAllocator = std::allocator< unsigned char >
+        , typename PalleteAllocator = std::allocator< unsigned char >
+        >
+class indexed_image
+{
+public:
+
+    typedef image< Index, false, IndicesAllocator > indices_t;
+    typedef image< Pixel, false, PalleteAllocator > palette_t;
+
+    typedef typename indices_t::view_t indices_view_t;
+    typedef typename palette_t::view_t palette_view_t;
+
+    typedef typename indices_t::const_view_t indices_const_view_t;
+    typedef typename palette_t::const_view_t palette_const_view_t;
+
+    typedef typename indices_view_t::locator indices_locator_t;
+    typedef typename palette_view_t::locator palette_locator_t;
+
+    typedef typename indexed_image_locator_type< indices_locator_t
+                                               , palette_locator_t
+                                               >::type locator_t;
+
+    typedef typename indices_t::coord_t x_coord_t;
+    typedef typename indices_t::coord_t y_coord_t;
+
+
+    typedef indexed_image_view< locator_t > view_t;
+    typedef typename view_t::const_t        const_view_t;
+
+    indexed_image( const x_coord_t   width = 0
+                 , const y_coord_t   height = 0
+                 , const std::size_t num_colors = 1
+                 , const std::size_t indices_alignment = 0
+                 , const std::size_t palette_alignment = 0
+                 )
+    : _indices( width     , height, indices_alignment, IndicesAllocator() )
+    , _palette( num_colors,      1, palette_alignment, PalleteAllocator() )
+    {
+        init( point_t( width, height ), num_colors );
+    }
+
+    indexed_image( const point_t&    dimensions
+                 , const std::size_t num_colors = 1
+                 , const std::size_t indices_alignment = 0
+                 , const std::size_t palette_alignment = 0
+                 )
+    : _indices( dimensions,    indices_alignment, IndicesAllocator() )
+    , _palette( num_colors, 1, palette_alignment, PalleteAllocator() )
+    {
+        init( dimensions, num_colors );
+    }
+
+    indexed_image( const indexed_image& img )
+    : _indices( img._indices )
+    , _palette( img._palette )
+    {}
+
+    template <typename Pixel2, typename Index2>
+    indexed_image( const indexed_image< Pixel2, Index2 >& img )
+    {
+        _indices = img._indices;
+        _palette = img._palette;
+    }
+
+    indexed_image& operator= ( const indexed_image& img )
+    {
+        _indices = img._indices;
+        _palette = img._palette;
+
+        return *this;
+    }
+
+    indices_const_view_t get_indices_const_view() const { return static_cast< indices_const_view_t >( _view.get_indices_view()); }
+    palette_const_view_t get_palette_const_view() const { return static_cast< palette_const_view_t >( _view.get_palette_view()); }
+
+    indices_view_t get_indices_view() { return _view.get_indices_view(); }
+    palette_view_t get_palette_view() { return _view.get_palette_view(); }
+
+public:
+
+    view_t _view;
+
+private:
+
+    void init( const point_t&    dimensions
+             , const std::size_t num_colors
+             )
+    {
+        typedef indexed_image_deref_fn< indices_locator_t
+                                      , palette_locator_t
+                                      > defer_fn_t;
+
+        defer_fn_t deref_fn( view( _indices ).xy_at( 0, 0 )
+                           , view( _palette ).xy_at( 0, 0 )
+                           );
+
+        locator_t locator( point_t( 0, 0 )
+                         , point_t( 1, 1 )
+                         , deref_fn
+                         );
+
+        _view = view_t( dimensions
+                      , num_colors
+                      , locator
+                      );
+    }
+
+private:
+
+    indices_t _indices;
+    palette_t _palette;
+};
+
+template< typename Index
+        , typename Pixel
+        >
+inline 
+const typename indexed_image< Index, Pixel >::view_t& view( indexed_image< Index, Pixel >& img )
+{
+    return img._view;
+}
+
+template< typename Index
+        , typename Pixel
+        >
+inline 
+const typename indexed_image< Index, Pixel >::const_view_t const_view( indexed_image< Index, Pixel >& img )
+{
+    return static_cast< const typename indexed_image< Index, Pixel >::const_view_t>( img._view );
+}
+
+// Whole image has one color and all indices are set to 0.
+template< typename Locator
+        , typename Value
+        >
+void fill_pixels( const indexed_image_view< Locator >& view
+                , const Value&                         value
+                )
+{
+    typedef indexed_image_view< Locator > view_t;
+
+    fill_pixels( view.get_indices_view(), view_t::indices_view_t::value_type( 0 ));
+    *view.get_palette_view().begin() = value;
+}
+
+} // gil
+} // boost
+
+#endif // BOOST_GIL_EXTENSION_TOOLBOX_INDEXED_IMAGE_HPP_INCLUDED
Index: boost-1.52.0/src/boost/gil/extension/toolbox/lab.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/lab.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,173 @@
+// Copyright 2008 Chung-Lin Wen.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef GIL_LAB_H
+#define GIL_LAB_H
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file
+/// \brief Support for CIE Lab color space
+/// \author Chung-Lin Wen \n
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/cast.hpp>
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/toolbox/xyz.hpp>
+
+namespace boost { namespace gil {
+
+/// \addtogroup ColorNameModel
+/// \{
+namespace lab_color_space
+{
+/// \brief Luminance
+struct luminance_t {};    
+/// \brief a Color Component
+struct a_color_opponent_t {};
+/// \brief b Color Component
+struct b_color_opponent_t {}; 
+}
+/// \}
+
+/// \ingroup ColorSpaceModel
+typedef mpl::vector3< lab_color_space::luminance_t
+                    , lab_color_space::a_color_opponent_t
+                    , lab_color_space::b_color_opponent_t
+                    > lab_t;
+
+/// \ingroup LayoutModel
+typedef layout<lab_t> lab_layout_t;
+
+GIL_DEFINE_ALL_TYPEDEFS( 32f, lab );
+
+/// \ingroup ColorConvert
+/// \brief LAB to XYZ
+template <>
+struct default_color_converter_impl< lab_t, xyz_t >
+{
+    template <typename P1, typename P2>
+    void operator()( const P1& src, P2& dst ) const
+    {
+        using namespace lab_color_space;
+        using namespace xyz_color_space;
+
+        bits32f p = ((get_color(src, luminance_t()) + 16.f)/116.f);
+
+        get_color(dst, y_t()) =
+                1.f * powf(p, 3.f);
+
+        get_color(dst, x_t()) =
+                0.95047f * powf((p +
+                                 (get_color(src, a_color_opponent_t())/500.f)
+                                 ), 3.f);
+        get_color(dst, z_t()) =
+                1.08883f * powf((p -
+                                 (get_color(src, b_color_opponent_t())/200.f)
+                                 ), 3.f);
+    }
+};
+
+/// \ingroup ColorConvert
+/// \brief XYZ to LAB
+/// \note I assume \c xyz_t
+template <>
+struct default_color_converter_impl< xyz_t, lab_t >
+{
+private:
+    /// \ref http://www.brucelindbloom.com/index.html?Eqn_XYZ_to_Lab.html
+    GIL_FORCEINLINE
+    bits32f forward_companding(bits32f value) const
+    {
+        if (value > 216.f/24389.f)
+        {
+            return powf(value, 1.f/3.f);
+        }
+        else
+        {
+            return ((24389.f/27.f * value + 16.f)/116.f);
+        }
+    }
+
+public:
+    template <typename P1, typename P2>
+    void operator()( const P1& src, P2& dst ) const
+    {
+        using namespace lab_color_space;
+
+        bits32f f_y =
+                forward_companding(
+                    channel_convert<bits32f>(
+                        get_color(src, xyz_color_space::y_t())
+                        )
+                    // / 1.f
+                    );
+
+        bits32f f_x =
+                forward_companding(
+                    channel_convert<bits32f>(
+                        get_color(src, xyz_color_space::x_t())
+                        )
+                    * (1.f / 0.95047f)  // if the compiler is smart, it should
+                                        // precalculate this, no?
+                    );
+
+        bits32f f_z =
+                forward_companding(
+                    channel_convert<bits32f>(
+                        get_color(src, xyz_color_space::z_t())
+                        )
+                    * (1.f / 1.08883f)  // if the compiler is smart, it should
+                                        // precalculate this, no?
+                    );
+
+        get_color(dst, luminance_t()) =
+                116.f * f_y - 16.f;
+
+        get_color(dst, a_color_opponent_t()) =
+                500.f * (f_x - f_y);
+
+        get_color(dst, b_color_opponent_t()) =
+                200.f * (f_y - f_z);
+    }
+};
+
+
+/// \ingroup ColorConvert
+/// \brief RGB to LAB
+template <>
+struct default_color_converter_impl< rgb_t, lab_t >
+{
+    template <typename P1, typename P2>
+    void operator()( const P1& src, P2& dst ) const
+    {
+        using namespace lab_color_space;
+
+        xyz32f_pixel_t xyz32f_temp_pixel;
+        default_color_converter_impl<rgb_t, xyz_t>()(src, xyz32f_temp_pixel);
+        default_color_converter_impl<xyz_t, lab_t>()(xyz32f_temp_pixel, dst);
+    }
+};
+
+/// \ingroup ColorConvert
+/// \brief LAB to RGB
+template <>
+struct default_color_converter_impl<lab_t,rgb_t>
+{
+    template <typename P1, typename P2>
+    void operator()( const P1& src, P2& dst) const
+    {
+        using namespace lab_color_space;
+
+        xyz32f_pixel_t xyz32f_temp_pixel;
+        default_color_converter_impl<lab_t, xyz_t>()(src, xyz32f_temp_pixel);
+        default_color_converter_impl<xyz_t, rgb_t>()(xyz32f_temp_pixel, dst);
+    }
+};
+
+} }  // namespace boost::gil
+
+#endif // GIL_LAB_H
Index: boost-1.52.0/src/boost/gil/extension/toolbox/layers.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/layers.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,35 @@
+// Copyright Tom Brinkman 2008. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef _layers_hpp_
+#define _layers_hpp_
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/function.hpp>
+
+namespace layer
+{
+
+template <typename view_t>
+struct layers
+{
+	typedef boost::function<void (view_t&)> layer_t;	
+	std::vector<layer_t> lst;	
+
+	layers(layer_t* p, int n)
+	{
+		for (int m = 0; m < n; ++m)
+			lst.push_back(p[m]);
+	}
+	
+	void operator()(view_t& view)
+	{
+		for (std::size_t n = 0; n < lst.size(); ++n)
+			lst[n](view);
+	}
+};
+
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/layers.ppm
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/boost/gil/extension/toolbox/layers.ppm	2012-11-09 15:21:14.000000000 +0100 differ
Index: boost-1.52.0/src/boost/gil/extension/toolbox/layers.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/layers.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,48 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <layers.hpp>
+#include <fill.hpp>
+#include <shrink.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ layers.tests.cpp -I /home/scott/project/boost_1_36_0 -I .
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		typedef boost::function<void (rgb8_view_t&)> layer_t;
+
+		layer_t a[] = 
+		{
+			layer::shrink<rgb8_view_t>(
+				layer::fill<rgb8_view_t>(rgb8_view_t::value_type(255,0,255)),5,5,5,5),
+			layer::shrink<rgb8_view_t>(
+				layer::fill<rgb8_view_t>(rgb8_view_t::value_type(255,0,0)),20,20,20,20)
+		};
+
+		layer::layers<rgb8_view_t> layer(a,2);
+		layer(view);
+		
+		FILE* fd = fopen("layers.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "rounded tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/lines.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/lines.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,134 @@
+// Copyright Tom Brinkman 2008. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef _lines_hpp_
+#define _lines_hpp_
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/mpl/vector_c.hpp>
+#include <boost/mpl/for_each.hpp>
+#include <channels.hpp>
+
+namespace layer
+{
+
+template <typename view_t, typename dash_t = boost::mpl::vector_c<int,1,1,0> >
+struct uniform_horizontal_lines
+{
+	typedef typename view_t::value_type color_t;
+	color_t color;
+	int intervals;
+	uniform_horizontal_lines(color_t color, int intervals) : 
+		color(color), intervals(intervals) {}
+
+	void operator()(view_t& view)
+	{
+		typedef typename view_t::value_type value_type_t;
+		
+		BOOST_ASSERT(view.width());
+		
+		std::vector<int> dash;
+		boost::mpl::for_each<dash_t>(
+			boost::bind(&std::vector<int>::push_back, &dash, _1));    
+
+		channels y(view.height(),intervals);
+
+		for (; y; ++y)
+			for (int x = 0; x < view.width(); )
+				for (int d = 0; d < dash.size(); ++d, ++x)
+					if (dash[d] && x < view.width())
+						view(x,*y) = color;
+	}
+};
+
+template <typename view_t, typename dash_t = boost::mpl::vector_c<int,1,1,0> >
+struct uniform_vertical_lines
+{
+	typedef typename view_t::value_type color_t;
+	color_t color;
+	int intervals;
+	uniform_vertical_lines(color_t color, int intervals) : color(color), intervals(intervals) {}
+		
+	void operator()(view_t& view)
+	{
+		typedef typename view_t::value_type value_type_t;
+		
+		std::vector<int> dash;
+		boost::mpl::for_each<dash_t>(
+			boost::bind(&std::vector<int>::push_back, &dash, _1));    
+
+		channels x(view.width(),intervals);
+
+		for (; x; x++)
+			for (int y = 0; y < view.width(); )
+				for (int d = 0; d < dash.size(); ++d, ++y)
+					if (dash[d] && y < view.height())
+						view(*x,y) = color;
+	}
+};
+
+template <typename view_t, typename dash_t=boost::mpl::vector_c<int,1,1,1,0> >
+struct horizontal_line
+{
+	typedef typename view_t::value_type color_t;
+	color_t color;
+	double value,minvalue,maxvalue;
+	horizontal_line(color_t color, double value, double minvalue, double maxvalue) :
+		color(color), minvalue(minvalue), maxvalue(maxvalue), value(value) {}
+
+	void operator()(view_t& view)
+	{
+		std::vector<int> dash;
+		boost::mpl::for_each<dash_t>(
+			boost::bind(&std::vector<int>::push_back, &dash, _1));    
+
+		double diff = maxvalue-minvalue;
+		if (diff == 0)
+			return;
+
+		double rval = 1-((value-minvalue)/(diff));
+		int y = (int)(rval*(view.height()-1));
+
+		for (int x = 0; x < view.width(); )
+			for (int d = 0; d < dash.size(); ++d, ++x)
+				if (dash[d] && x < view.width())
+					view(x,y) = color;
+	}
+};
+
+template <typename view_t, typename dashlst_t = boost::mpl::vector_c<int,1,1,0> >
+struct vertical_lines
+{
+	typedef typename view_t::value_type color_t;
+	color_t color;
+	int width;
+	int periods;
+	vertical_lines(color_t color, int periods, int width) : 
+		color(color), periods(periods), width(width) {}
+
+	void operator()(view_t& view)
+	{
+		std::vector<int> dashlst;
+		boost::mpl::for_each<dashlst_t>(
+			boost::bind(&std::vector<int>::push_back, &dashlst, _1));
+		
+		int intervals = view.width()/width;
+		channels i(periods,intervals);
+		channels x(view.width(),periods);
+
+		for (int n=0; i; ++i)
+		{
+			for (; n < *i; ++n, ++x) ;
+
+			for (int y = 0; y < view.height(); )
+				for (std::size_t d = 0; d < dashlst.size(); ++d, ++y)
+					if (dashlst[d] && y < view.height())
+						view(*x,y) = color;
+		}
+	}
+};
+
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/lines.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/lines.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,111 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <lines.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ lines.tests.cpp -I /home/scott/project/boost_1_36_0 -I .
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		typedef boost::function<void (rgb8_view_t&)> layer_t;
+
+		layer::uniform_horizontal_lines<rgb8_view_t> lines(rgb8_view_t::value_type(0,0,0),10);
+		lines(view);
+		
+		FILE* fd = fopen("lines1.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+struct test2
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		typedef boost::function<void (rgb8_view_t&)> layer_t;
+
+		layer::uniform_vertical_lines<rgb8_view_t> lines(rgb8_view_t::value_type(0,0,0),10);
+		lines(view);
+		
+		FILE* fd = fopen("lines2.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+struct test3
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		typedef boost::function<void (rgb8_view_t&)> layer_t;
+
+		layer::horizontal_line<rgb8_view_t> line(rgb8_view_t::value_type(0,0,0),30,0,100);
+		line(view);
+		
+		FILE* fd = fopen("lines3.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+struct test4
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		typedef boost::function<void (rgb8_view_t&)> layer_t;
+
+		layer::vertical_lines<rgb8_view_t> line(rgb8_view_t::value_type(0,0,0),10,20);
+		line(view);
+		
+		FILE* fd = fopen("lines4.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "lines tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	test->add( BOOST_TEST_CASE(test2()), 0);
+	test->add( BOOST_TEST_CASE(test3()), 0);
+	test->add( BOOST_TEST_CASE(test4()), 0);
+	return test;
+}
+
Index: boost-1.52.0/src/boost/gil/extension/toolbox/lines1.ppm
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/boost/gil/extension/toolbox/lines1.ppm	2012-11-09 15:21:14.000000000 +0100 differ
Index: boost-1.52.0/src/boost/gil/extension/toolbox/lines2.ppm
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/boost/gil/extension/toolbox/lines2.ppm	2012-11-09 15:21:14.000000000 +0100 differ
Index: boost-1.52.0/src/boost/gil/extension/toolbox/lines3.ppm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/lines3.ppm	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,5 @@
+P6
+# CREATOR: reportbase
+200 200
+255
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
\ No newline at end of file
Index: boost-1.52.0/src/boost/gil/extension/toolbox/lines4.ppm
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/boost/gil/extension/toolbox/lines4.ppm	2012-11-09 15:21:14.000000000 +0100 differ
Index: boost-1.52.0/src/boost/gil/extension/toolbox/parallel_grid.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/parallel_grid.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,92 @@
+// Copyright Tom Brinkman 2008. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef _parallel_grid_hpp_
+#define _parallel_grid_hpp_
+
+#include <vector>
+#include <boost/gil/gil_all.hpp>
+#include <boost/function.hpp>
+
+#include <tbb/parallel_for.h>
+#include <tbb/parallel_reduce.h>
+#include <tbb/blocked_range.h>
+#include <tbb/task_scheduler_init.h>
+#include <tbb/tick_count.h>
+
+#include <sections.hpp>
+
+namespace layer
+{
+
+template <typename view_t>
+struct parallel_draw
+{
+	typedef boost::function<void (view_t&)> layer_t;
+
+	std::vector<view_t> views;
+	std::vector<layer_t> layers;				
+	parallel_draw(std::vector<layer_t>& layers, std::vector<view_t>& views) : 
+		views(views), layers(layers){}
+
+	void operator()(const tbb::blocked_range<size_t>& blocks) const 
+	{
+		BOOST_ASSERT(layers.size() == views.size());
+		for (std::size_t block = blocks.begin(); block != blocks.end(); ++block)
+		{
+			view_t v = views[block];
+			layers[block](v);
+		}
+	}
+};
+
+template <typename view_t>
+struct parallel_grid
+{
+	typedef boost::function<void (view_t&)> layer_t;
+	typedef std::vector<layer_t> layers_t;
+	layers_t layers;
+	int cols;
+	int margin;
+
+	parallel_grid(layer_t* p, int total, int cols, int margin = 5) : 
+		cols(cols), margin(margin)
+	{
+		for (int n = 0; n < total; ++n)
+			layers.push_back(p[n]);
+	}
+
+	void operator()(view_t& view)
+	{
+		using namespace boost::gil;
+
+		int y = 0;
+		std::vector<view_t> views;
+
+		int rows = (int)ceil(layers.size()/(double)cols);
+		sections ycurr(view.height()+margin,rows);
+		for (; ycurr; ycurr++)
+		{
+			int yheight = *ycurr-margin;
+			int x = 0;
+			
+			sections xcurr(view.width()+margin,cols);
+			for (; xcurr; xcurr++)
+			{			
+				int xwidth = *xcurr-margin;
+				views.push_back(subimage_view(view,x,y,xwidth,yheight));
+				x += xwidth+margin;
+			}
+
+			y += yheight+margin;
+		}	
+
+		tbb::parallel_for(tbb::blocked_range<std::size_t>(0,views.size()),
+			parallel_draw<view_t>(layers,views), tbb::auto_partitioner());
+	}
+};
+
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/parallel_grid.ppm
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/boost/gil/extension/toolbox/parallel_grid.ppm	2012-11-09 15:21:14.000000000 +0100 differ
Index: boost-1.52.0/src/boost/gil/extension/toolbox/parallel_grid.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/parallel_grid.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,70 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <parallel_grid.hpp>
+#include <fill.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ parallel_grid.tests.cpp -I /home/scott/project/boost_1_36_0 -I . -ltbb -lpthread
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		typedef boost::function<void (rgb8_view_t&)> layer_t;
+		typedef layer::fill<rgb8_view_t> fill_t;
+
+		layer_t a[] = 
+		{
+			fill_t(rgb8_view_t::value_type(255,0,255)),
+			fill_t(rgb8_view_t::value_type(255,0,0)),
+			fill_t(rgb8_view_t::value_type(0,0,255)),
+			fill_t(rgb8_view_t::value_type(255,0,0)),
+			fill_t(rgb8_view_t::value_type(100,0,255)),
+			fill_t(rgb8_view_t::value_type(100,0,100)),
+		};
+
+		tbb::task_scheduler_init init(tbb::task_scheduler_init::automatic);
+		init.initialize(1);
+
+		layer::parallel_grid<rgb8_view_t> grid(a,6,3);
+		grid(view);
+		
+		FILE* fd = fopen("parallel_grid.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+struct test2
+{
+	void operator()()
+	{
+		sections curr(100,3);
+
+		double a[] = {34,33,33};
+
+		int n = 0;
+		for(; curr; ++curr, n++)
+		{
+			BOOST_CHECK(a[n] == *curr);
+		}
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "border tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	test->add( BOOST_TEST_CASE(test2()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/pattern.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/pattern.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,58 @@
+// Copyright Tom Brinkman 2008. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef _pattern_hpp_
+#define _pattern_hpp_
+
+#include <boost/gil/gil_all.hpp>
+#include <blend.hpp>
+
+namespace layer
+{
+
+template <typename view_t>
+struct pattern
+{
+	view_t v2;
+	pattern(view_t v2) : v2(v2){}
+		
+	void operator()(view_t& view)
+	{
+		using namespace boost::gil;
+
+		int h = v2.height();
+		int w = v2.width();
+		if (h > view.height() || w > view.width())
+			return;
+		
+		int n = 0;
+		for (int x = 0; x < view.width(); x+=w)
+		{
+			for (int y = 0; y < view.height(); y+=h)
+			{
+				int aw = w;
+				if (x+w > view.width())
+				{
+					int t = x+w-view.width();
+					aw = w-t;	
+				}
+
+				int ah = h;
+				if (y+h > view.height())
+				{
+					int t = y+h-view.height();
+					ah = h-t;	
+				}
+
+				view_t v3 = subimage_view(view,x,y,aw,ah);
+				view_t v4 = subimage_view(v2,0,0,aw,ah);
+				boost::gil::copy_pixels(v4,v3);
+			}
+		}
+	}
+};
+
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/pattern.ppm
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/boost/gil/extension/toolbox/pattern.ppm	2012-11-09 15:21:14.000000000 +0100 differ
Index: boost-1.52.0/src/boost/gil/extension/toolbox/pattern.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/pattern.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,85 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <pattern.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ pattern.tests.cpp -I /home/scott/project/boost_1_36_0 -I .
+
+static const struct {
+  int  	 width;
+  int  	 height;
+  int  	 bytes_per_pixel; /* 3:RGB, 4:RGBA */ 
+  char 	 pixel_data[16 * 16 * 3 + 1];
+} gimp_image = {
+  16, 16, 3,
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377",
+};
+
+struct test1
+{
+	void operator()()
+	{
+		int rows = 4;
+		int cols = 7;
+		int extra = 5;
+		int width = gimp_image.width*cols+extra;
+		int height = gimp_image.height*rows+extra;
+		unsigned char* buffer = new unsigned char[width * height * gimp_image.bytes_per_pixel];
+		memset(buffer, 255, width * height * gimp_image.bytes_per_pixel);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*gimp_image.bytes_per_pixel);
+
+		rgb8_view_t view2 = interleaved_view(gimp_image.width,gimp_image.height,
+			(rgb8_pixel_t*)gimp_image.pixel_data,gimp_image.width*gimp_image.bytes_per_pixel);
+
+		layer::pattern<rgb8_view_t> pattern(view2);
+		pattern(view);
+		
+		FILE* fd = fopen("pattern.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "pattern tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/rgb_algorithms.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/rgb_algorithms.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,232 @@
+#ifndef RGB_ALGORITHMS_HPP
+#define RGB_ALGORITHMS_HPP
+
+#include <boost/gil/gil_all.hpp>
+
+namespace boost { namespace gil {
+namespace toolbox {
+
+struct calc_negative
+{
+   template < typename DST_CHANNEL
+            , typename SRC_CHANNEL
+            > void operator()( DST_CHANNEL& dst 
+                             , SRC_CHANNEL& src ) const
+   {
+      SRC_CHANNEL max = channel_traits< SRC_CHANNEL >::max_value();
+
+      dst = max - src;
+   }
+
+   template < typename CHANNEL
+            > void operator()( CHANNEL& c ) const
+   {
+      CHANNEL max = channel_traits< CHANNEL >::max_value();
+
+      c = max - c;
+   }
+};
+
+template< typename RGB_VIEW >
+void negative( const RGB_VIEW& view )
+{
+   typedef typename channel_type< RGB_VIEW >::type channel_t;
+   channel_t max = channel_traits<channel_t>::max_value();
+
+   for( int y=0; y < view.height(); ++y )
+   {
+      typename RGB_VIEW::x_iterator it = view.row_begin( y );
+
+      for( int x = 0; x < view.width(); ++x )
+      {
+         static_for_each( it[x], calc_negative() );
+      }
+   }
+}
+
+template< typename RGB_VIEW >
+void negative( const RGB_VIEW& src
+             , const RGB_VIEW& dst )
+{
+   // make sure src and dst have same dimensions.
+
+   // for rgba do it only for rgb channels
+
+   typedef typename channel_type< RGB_VIEW >::type channel_t;
+   channel_t max = channel_traits<channel_t>::max_value();
+
+   for( int y=0; y < src.height(); ++y )
+   {
+      typename RGB_VIEW::x_iterator src_it = src.row_begin( y );
+      typename RGB_VIEW::x_iterator dst_it = dst.row_begin( y );
+
+      for( int x = 0; x < src.width(); ++x )
+      {
+         static_for_each( dst_it[x], src_it[x], calc_negative() );
+      }
+   }
+}
+
+struct calc_brightness
+{
+   float _factor;
+
+   template < typename DST_CHANNEL
+            , typename SRC_CHANNEL
+            > void operator()( DST_CHANNEL&       dst 
+                             , const SRC_CHANNEL& src ) const
+   {
+      float d = static_cast<float>( src ) * _factor;
+
+      if( d > channel_traits< DST_CHANNEL >::max_value() )
+      {
+         dst = channel_traits< DST_CHANNEL >::max_value();
+      }
+      else
+      {
+         dst = static_cast< DST_CHANNEL >( d );
+      }
+   }
+};
+
+
+
+template< typename RGB_VIEW >
+void brightness( const RGB_VIEW& src
+               , const RGB_VIEW& dst
+               , float           factor )
+{
+   calc_brightness calc;
+   calc._factor = factor;
+
+   for( int y=0; y < src.height(); ++y )
+   {
+      typename RGB_VIEW::x_iterator src_it = src.row_begin( y );
+      typename RGB_VIEW::x_iterator dst_it = dst.row_begin( y );
+
+      for( int x = 0; x < src.width(); ++x )
+      {
+         static_for_each( dst_it[x], src_it[x], calc );
+      }
+   }
+}
+
+template< typename VALUE >
+struct calc_brightness_
+{
+   VALUE _number;
+
+   template < typename DST_CHANNEL
+            , typename SRC_CHANNEL
+            > void operator()( DST_CHANNEL&       dst 
+                             , const SRC_CHANNEL& src ) const
+   {
+      VALUE d = static_cast< VALUE >( src ) + _number;
+
+      if( d > channel_traits< DST_CHANNEL >::max_value() )
+      {
+         dst = channel_traits< DST_CHANNEL >::max_value();
+      }
+      else
+      {
+         dst = d;
+      }
+   }
+};
+
+template< typename RGB_VIEW
+        , typename VALUE >
+void brightness_( const RGB_VIEW& src
+                , const RGB_VIEW& dst
+                , VALUE           number )
+{
+   calc_brightness_<VALUE> calc;
+   calc._number = number;
+
+   for( int y=0; y < src.height(); ++y )
+   {
+      typename RGB_VIEW::x_iterator src_it = src.row_begin( y );
+      typename RGB_VIEW::x_iterator dst_it = dst.row_begin( y );
+
+      for( int x = 0; x < src.width(); ++x )
+      {
+         static_for_each( dst_it[x], src_it[x], calc );
+      }
+   }
+}
+
+template< typename RGB_VIEW >
+void remove_channel( const RGB_VIEW& src
+                   , unsigned int    c   )
+{
+   typedef typename channel_type< RGB_VIEW >::type channel_t;
+   channel_t min_value = channel_traits<channel_t>::min_value();
+
+   for( int y = 0; y < src.dimensions().y; ++y )
+   {
+      typename RGB_VIEW::x_iterator src_it = src.row_begin( y );
+
+      for( int x = 0; x < src.dimensions().x; ++x )
+      {
+         dynamic_at_c( src_it[x], c ) = min_value;
+      }
+   }
+}
+
+template< typename CHANNEL
+        , typename RGB_VIEW >
+void remove_channel( const RGB_VIEW& src )
+{
+   typedef typename channel_type< RGB_VIEW >::type channel_t;
+   channel_t min = channel_traits<channel_t>::min_value();
+
+   for( int y = 0; y < src.dimensions().y; ++y )
+   {
+      typename RGB_VIEW::x_iterator src_it = src.row_begin( y );
+
+      for( int x = 0; x < src.dimensions().x; ++x )
+      {
+         get_color( src_it[x], CHANNEL() ) = min;
+      }
+   }
+}
+
+
+template< typename RGB_VIEW >
+void difference( const RGB_VIEW& src_1
+               , const RGB_VIEW& src_2
+               , const RGB_VIEW& dst    )
+{
+   if( src_1.dimensions() != src_2.dimensions() )
+   {
+      throw std::runtime_error( "Source image have different dimensions." );
+   }
+
+   if( src_1.dimensions() != dst.dimensions() )
+   {
+      throw std::runtime_error( "Destination image must have equal dimensions as the source images." );
+   }
+
+   for( int y = 0; y < src_1.dimensions().y; ++y )
+   {
+      typename RGB_VIEW::x_iterator src_1_it = src_1.row_begin( y );
+      typename RGB_VIEW::x_iterator src_2_it = src_2.row_begin( y );
+
+      typename RGB_VIEW::x_iterator dst_it = dst.row_begin( y );
+
+      typedef typename channel_type<RGB_VIEW>::type channel_t;
+
+      for( int x = 0; x < src_1.dimensions().x; ++x )
+      {
+			 assert(false);
+		//TODO: what is calc_diff?
+         //static_for_each( src_1_it[x], src_1_it[x], dst_it[x], calc_diff() );
+      }
+   }
+}
+
+} //namespace toolbox
+} //namespace gil
+} //namespace boost
+
+#endif // RGB_ALGORITHMS_HPP
Index: boost-1.52.0/src/boost/gil/extension/toolbox/rounded.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/rounded.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,110 @@
+#ifndef _rounded_hpp_
+#define _rounded_hpp_
+
+#include <boost/gil/gil_all.hpp>
+#include <blend.hpp>
+
+namespace layer
+{
+
+template <typename view_t>
+struct rounded
+{
+	typedef typename view_t::value_type color_t;
+	color_t backcolor;
+	color_t frontcolor;
+	color_t bordercolor;
+	rounded(color_t backcolor, color_t frontcolor, color_t bordercolor) : 
+		backcolor(backcolor), frontcolor(frontcolor), bordercolor(bordercolor) {}
+			
+	void operator()(view_t& view)
+	{
+		using namespace boost::gil;
+		#define ___ 0
+		
+		static unsigned char buffer2[] = {
+			___,___,___,___,___,___,___,___,___,___,___,___,___,255,230,
+			___,___,___,___,___,___,___,___,___,___,___,___,___,255,220,
+			___,___,___,___,___,___,___,___,___,___,___,___,___,255,170,
+			___,___,___,___,___,___,___,___,___,___,___,___,140,255,140,
+			___,___,___,___,___,___,___,___,___,___,___,___,180,255,110,
+			___,___,___,___,___,___,___,___,___,___,___,___,220,220,065,
+			___,___,___,___,___,___,___,___,___,___,___,180,255,150,___,
+			___,___,___,___,___,___,___,___,___,___,___,255,220,070,___,
+			___,___,___,___,___,___,___,___,___,___,255,255,170,___,___,
+			___,___,___,___,___,___,___,___,___,180,255,180,___,___,___,
+			___,___,___,___,___,___,___,___,255,255,190,060,___,___,___,
+			___,___,___,___,___,___,180,255,255,185,060,___,___,___,___,
+			___,___,___,140,180,220,255,215,170,___,___,___,___,___,___,
+			255,255,255,255,255,215,165,100,___,___,___,___,___,___,___,
+			230,200,170,140,110,065,___,___,___,___,___,___,___,___,___
+			};
+
+		static unsigned char buffer3[] = {
+			___,___,___,___,___,___,___,___,___,___,255,
+			___,___,___,___,___,___,___,___,___,255,255,
+			___,___,___,___,___,___,___,___,___,255,255,
+			___,___,___,___,___,___,___,___,255,255,255,
+			___,___,___,___,___,___,___,___,255,255,255,
+			___,___,___,___,___,___,___,255,255,255,255,
+			___,___,___,___,___,___,255,255,255,255,255,
+			___,___,___,___,___,255,255,255,255,255,255,
+			___,___,___,___,255,255,255,255,255,255,255,
+			___,___,255,255,255,255,255,255,255,255,255,
+			255,255,255,255,255,255,255,255,255,255,255
+			};
+				
+		int width = 15;
+		int height = 15;
+				
+		boost::gil::fill_pixels(view,frontcolor);		
+				
+		for (int x = width; x < view.width()-width; ++x)
+		{
+			view(x,0) = bordercolor;
+			view(x,1) = bordercolor;
+			view(x,view.height()-1) = bordercolor;
+			view(x,view.height()-2) = bordercolor;
+		}
+			
+		for (int y = height; y < view.height()-height; ++y)
+		{
+			view(0,y) = bordercolor;
+			view(1,y) = bordercolor;
+			view(view.width()-1,y) = bordercolor;
+			view(view.width()-2,y) = bordercolor;
+		}
+
+		width = 11;
+		height = 11;
+		gray8c_view_t grayview = interleaved_view(width,height,
+			(gray8_pixel_t*)buffer3,sizeof(unsigned char)*width);
+
+		copy<alpha24_blend>(backcolor,rotated180_view(grayview),
+			subimage_view(view,0,0,width,height));
+		copy<alpha24_blend>(backcolor,grayview,
+			subimage_view(view,view.width()-width,view.height()-height,width,height));
+		copy<alpha24_blend>(backcolor,rotated90ccw_view(grayview),
+			subimage_view(view,view.width()-width,0,width,height));
+		copy<alpha24_blend>(backcolor,rotated90cw_view(grayview),
+			subimage_view(view,0,view.height()-height,width,height));
+
+		width = 15;
+		height = 15;
+		grayview = interleaved_view(width,height,
+			(gray8_pixel_t*)buffer2,sizeof(unsigned char)*width);
+
+		copy<alpha24_blend>(bordercolor,rotated180_view(grayview),
+			subimage_view(view,0,0,width,height));
+		copy<alpha24_blend>(bordercolor,grayview,
+			subimage_view(view,view.width()-width,view.height()-height,width,height));
+		copy<alpha24_blend>(bordercolor,rotated90ccw_view(grayview),
+			subimage_view(view,view.width()-width,0,width,height));
+		copy<alpha24_blend>(bordercolor,rotated90cw_view(grayview),
+			subimage_view(view,0,view.height()-height,width,height));		
+	}
+};
+
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/rounded.ppm
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/boost/gil/extension/toolbox/rounded.ppm	2012-11-09 15:21:14.000000000 +0100 differ
Index: boost-1.52.0/src/boost/gil/extension/toolbox/rounded.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/rounded.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,39 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <rounded.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ rounded.tests.cpp -I /home/scott/project/boost_1_36_0 -I .
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		rgb8_view_t::value_type back(255,255,255);
+		rgb8_view_t::value_type front(70,70,70);
+		rgb8_view_t::value_type border(0,0,0);
+		layer::rounded<rgb8_view_t> rounded(back,front,border);
+		rounded(view);
+		
+		FILE* fd = fopen("rounded.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "rounded tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/section.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/section.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,87 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <sections.hpp>
+#include <fill.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ section.tests.cpp -I /home/scott/project/boost_1_36_0 -I .
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		typedef boost::function<void (rgb8_view_t&)> layer_t;
+		typedef std::pair<double, layer_t> pair_t;
+		typedef layer::fill<rgb8_view_t> fill_t;
+
+		pair_t a[] = 
+		{
+			pair_t(30,fill_t(rgb8_view_t::value_type(255,0,255))),
+			pair_t(30,fill_t(rgb8_view_t::value_type(255,0,0))),
+			pair_t(0,fill_t(rgb8_view_t::value_type(0,0,255))),
+			pair_t(30,fill_t(rgb8_view_t::value_type(255,0,0))),
+			pair_t(30,fill_t(rgb8_view_t::value_type(100,0,255))),
+			pair_t(30,fill_t(rgb8_view_t::value_type(100,0,100))),
+		};
+
+		layer::rows<rgb8_view_t> rows(a,6,5);
+		rows(view);
+		
+		FILE* fd = fopen("sections.test1.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+struct test2
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		typedef boost::function<void (rgb8_view_t&)> layer_t;
+		typedef std::pair<double, layer_t> pair_t;
+		typedef layer::fill<rgb8_view_t> fill_t;
+
+		pair_t a[] = 
+		{
+			pair_t(30,fill_t(rgb8_view_t::value_type(255,0,255))),
+			pair_t(30,fill_t(rgb8_view_t::value_type(255,0,0))),
+			pair_t(0,fill_t(rgb8_view_t::value_type(0,0,255))),
+			pair_t(30,fill_t(rgb8_view_t::value_type(255,0,0))),
+			pair_t(30,fill_t(rgb8_view_t::value_type(100,0,255))),
+			pair_t(30,fill_t(rgb8_view_t::value_type(100,0,100))),
+		};
+
+		layer::columns<rgb8_view_t> rows(a,6,5);
+		rows(view);
+		
+		FILE* fd = fopen("sections.test2.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "sections tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	test->add( BOOST_TEST_CASE(test2()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/sections.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/sections.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,181 @@
+// Copyright Tom Brinkman 2008. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef _sections_hpp_
+#define _sections_hpp_
+
+#include <boost/function.hpp>
+#include <boost/gil/gil_all.hpp>
+
+struct sections
+{
+	struct section
+	{
+		int pos;
+		section* next;
+	};
+	
+	section* head;
+	section* current;
+
+	operator bool (){return current != NULL;}
+	operator section * () {return head;}
+	double operator *(){return current->pos;}
+	void operator ++(int){current = current->next;}
+	void operator ++(){current = current->next;}
+	void reset() {current = head;}
+
+	~sections()
+	{
+		while (head)
+		{
+			section* tmp = head->next;
+			free(head);
+			head = tmp;
+		}
+		
+		head = NULL;
+	}
+
+	sections(int width, int intervals) : head(NULL), current(NULL)
+	{
+		BOOST_ASSERT(intervals);
+		
+		int adj = width / intervals;
+		int extra = width-adj*intervals;
+		int pos = 0;
+		int ppos = 0;
+	
+		head = NULL;
+		current = NULL;
+		
+		while (pos < width)
+		{
+			int add = adj;
+			if (extra-- > 0)
+				add++;
+	
+			section* tmp  = (section*)malloc(sizeof(section));
+			pos += add;
+			tmp->pos = pos - ppos;
+			tmp->next = NULL;
+			ppos = pos;
+			
+			if (head == NULL)
+				head = tmp;
+			else
+				current->next = tmp;
+			
+			current = tmp;
+		}
+		
+		current = head;
+	}
+};
+
+namespace layer
+{
+
+template <typename view_t>
+struct columns
+{
+	typedef boost::function<void (view_t&)> layer_t;
+	typedef std::pair<double, layer_t> pair_t;
+	
+	std::vector<pair_t> layers;
+	int margin;
+
+	columns(pair_t* p, int size, int margin = 0) : margin(margin) 
+	{
+		for (int n = 0; n < size; ++n)
+			layers.push_back(p[n]);
+	}
+
+	void operator()(view_t& view)
+	{
+		int zcount = 0;
+		int swidth = 0;
+		for (int n = 0; n < layers.size(); ++n)
+		{
+			BOOST_ASSERT(layers[n].first >= 0);
+			if (layers[n].first < 1 && layers[n].first > 0)
+				layers[n].first = (int)(layers[n].first * view.width());
+
+			swidth += (int)(layers[n].first);
+			zcount += layers[n].first == 0 ? 1 : 0;
+		}
+
+		sections curr(view.width()-swidth+margin,zcount);
+		int x = 0;
+		for (int n = 0; n < layers.size(); ++n)
+		{
+			if (!layers[n].first)
+			{
+				layers[n].first = *curr;
+				curr++;
+			}
+
+			int xwidth = (int)(layers[n].first);
+			xwidth -= margin;
+
+			view_t v = boost::gil::subimage_view(view,x,0,xwidth,view.height());
+			layers[n].second(v);
+			x += xwidth + margin;
+		}
+	}
+};
+
+template <typename view_t>
+struct rows
+{
+	typedef boost::function<void (view_t&)> layer_t;
+	typedef std::pair<double, layer_t> pair_t;
+	typedef std::vector<std::pair<double,layer_t> > layers_t; 
+
+	int margin;
+	layers_t layers;
+	
+	rows(pair_t* p, int size, int margin = 0) : margin(margin)
+	{
+		for (int n = 0; n < size; ++n)
+			layers.push_back(p[n]);
+	}
+
+	void operator()(view_t& view)
+	{
+		int zcount = 0;
+		int sheight = 0;
+		for (int n = 0; n < layers.size(); ++n)
+		{
+			BOOST_ASSERT(layers[n].first >= 0);
+			if (layers[n].first < 1 && layers[n].first > 0)
+				layers[n].first = (int)(layers[n].first * view.height());
+
+			sheight += (int)(layers[n].first);
+			zcount += layers[n].first == 0 ? 1 : 0;
+		}
+
+		sections curr(view.height()-sheight+margin,zcount);
+		int y = 0;
+		for (int n = 0; n < layers.size(); ++n)
+		{
+			if (!layers[n].first)
+			{
+				layers[n].first = *curr;
+				curr++;
+			}
+			
+			int yheight = (int)(layers[n].first);
+			yheight -= margin;
+			
+			view_t v = boost::gil::subimage_view(view,0,y,view.width(),yheight);
+			layers[n].second(v);
+			y += yheight+margin;
+		}
+	}
+};
+
+};
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/sections.test1.ppm
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/boost/gil/extension/toolbox/sections.test1.ppm	2012-11-09 15:21:14.000000000 +0100 differ
Index: boost-1.52.0/src/boost/gil/extension/toolbox/sections.test2.ppm
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/boost/gil/extension/toolbox/sections.test2.ppm	2012-11-09 15:21:14.000000000 +0100 differ
Index: boost-1.52.0/src/boost/gil/extension/toolbox/shrink.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/shrink.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,46 @@
+// Copyright Tom Brinkman 2008. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef _shrink_hpp_
+#define _shrink_hpp_
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/function.hpp>
+
+namespace layer
+{
+
+template <typename view_t>
+struct shrink
+{
+	typedef boost::function<void (view_t&)> funct_t;
+
+	double left;
+	double top;
+	double right;
+	double bottom;
+	funct_t funct;
+
+	shrink(funct_t funct, double left=5, double top=5,
+		double right=5, double bottom=5) :
+			funct(funct), left(left), top(top), 
+				right(right), bottom(bottom){}
+
+	void operator()(view_t& view)
+	{
+		if (left < 1.0) left *= view.width();
+		if (right < 1.0) right *= view.width();
+		if (top < 1.0) top *= view.height();
+		if (bottom < 1.0) bottom *= view.height();
+
+		double width = view.width()-left-right;
+		double height = view.height()-top-bottom;
+		view_t view2 = boost::gil::subimage_view(view,(int)left,(int)top,(int)width,(int)height);
+		funct(view2);
+	}
+};	
+
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/shrink.ppm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/shrink.ppm	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,5 @@
+P6
+# CREATOR: reportbase
+200 200
+255
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
\ No newline at end of file
Index: boost-1.52.0/src/boost/gil/extension/toolbox/shrink.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/shrink.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,39 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <shrink.hpp>
+#include <fill.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ shrink.tests.cpp -I /home/scott/project/boost_1_36_0 -I .
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		rgb8_view_t::value_type black(0,0,0);
+		layer::fill<rgb8_view_t> fill(black);
+		layer::shrink<rgb8_view_t> shrink(fill,0.20,0.30,0.20,0.30);
+		shrink(view);
+		
+		FILE* fd = fopen("shrink.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "rounded tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/test.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,404 @@
+// test.cpp : Defines the entry point for the console application.
+//
+
+#include "stdafx.h"
+
+#include <boost/gil/extension/io/bmp_io.hpp>
+
+#include <boost/gil/extension/opencv/convert.hpp>
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+using namespace opencv;
+
+// Models a Unary Function
+template <typename P>   // Models PixelValueConcept
+struct mandelbrot_fn {
+    typedef point2<ptrdiff_t>    point_t;
+
+    typedef mandelbrot_fn        const_t;
+    typedef P                    value_type;
+    typedef value_type           reference;
+    typedef value_type           const_reference;
+    typedef point_t              argument_type;
+    typedef reference            result_type;
+    BOOST_STATIC_CONSTANT(bool, is_mutable=false);
+
+    value_type                    _in_color,_out_color;
+    point_t                       _img_size;
+    static const int MAX_ITER=1000;        // max number of iterations
+
+    mandelbrot_fn() {}
+    mandelbrot_fn(const point_t& sz, const value_type& in_color, const value_type& out_color) : _in_color(in_color), _out_color(out_color), _img_size(sz) {}
+
+    result_type operator()(const point_t& p) const {
+        // normalize the coords to (-2..1, -1.5..1.5)
+        // (actually make y -1.0..2 so it is asymmetric, so we can verify some view factory methods)
+        double t=get_num_iter(point2<double>(p.x/(double)_img_size.x*3-2, p.y/(double)_img_size.y*3-1.0f));//1.5f));
+        t=pow(t,0.2);
+
+        value_type ret;
+        for (int k=0; k<num_channels<P>::value; ++k)
+            ret[k]=(typename channel_type<P>::type)(_in_color[k]*t + _out_color[k]*(1-t));
+        return ret;
+    }
+
+private:
+    double get_num_iter(const point2<double>& p) const {
+        point2<double> Z(0,0);
+        for (int i=0; i<MAX_ITER; ++i) {
+            Z = point2<double>(Z.x*Z.x - Z.y*Z.y + p.x, 2*Z.x*Z.y + p.y);
+            if (Z.x*Z.x + Z.y*Z.y > 4)
+                return i/(double)MAX_ITER;
+        }
+        return 0;
+    }
+};
+
+struct set_to_max
+{
+   template <typename CHANNEL > void operator()(CHANNEL& c) const
+   {
+      c = channel_traits< CHANNEL >::max_value();
+   }
+};
+
+struct set_to_min
+{
+   template <typename CHANNEL > void operator()(CHANNEL& c) const
+   {
+      c = channel_traits< CHANNEL >::min_value();
+   }
+};
+
+
+template< class PIXEL
+        , class VIEW >
+inline
+PIXEL min_channel_values( const VIEW& view )
+{
+   PIXEL min;
+
+   // initialize the min pixel with the max values
+   static_for_each( min, set_to_max() );
+
+   for( int y=0; y < view.height(); ++y )
+   {
+      VIEW::x_iterator x_it = view.row_begin( y );
+
+      for( int x = 0; x < view.width(); ++x )
+      {
+         typename PIXEL::const_reference p = x_it[x];
+
+         for( int i = 0; i < num_channels<PIXEL>::type::value; ++i )
+         {
+            if( dynamic_at_c( p, i ) < dynamic_at_c( min, i ))
+            {
+               dynamic_at_c( min, i ) = dynamic_at_c( p, i );
+            }
+         }
+      }
+   }
+
+   return min;
+}
+
+template <typename T>
+struct add_vector
+{
+   typedef std::vector<T> type;
+};
+
+template< class PIXEL
+        , class VIEW >
+inline
+PIXEL min_channel_values_( const VIEW&  view
+                        , const size_t percent = 1 )
+{
+   typedef mpl::transform1< color_space_type<VIEW>::type, add_vector<mpl::_1> >::type channels_t;
+
+   typedef kth_semantic_element_type< PIXEL, 0 >::type channel_t; //channel_0 = semantic_at_c<0>( PIXEL() );
+   channel_t max = channel_traits<channel_t>::max_value();
+
+   return PIXEL();
+}
+
+
+template< class PIXEL
+        , class VIEW >
+inline
+PIXEL max_channel_values( const VIEW& view )
+{
+   PIXEL max;
+
+   // initialize the max pixel with the min values
+   static_for_each( max, set_to_min() );
+
+   // find the max values
+   for( VIEW::iterator it = view.begin()
+      ; it != view.end()
+      ; ++it )
+   {
+      for( int i = 0; i < num_channels<PIXEL>::type::value; ++i )
+      {
+         if( dynamic_at_c( *it, i ) > dynamic_at_c( max, i ))
+         {
+            dynamic_at_c( max, i ) = dynamic_at_c( *it, i );
+         }
+      }
+   }
+
+   return max;
+}
+
+template< class PIXEL
+        , class VIEW >
+inline
+boost::fusion::vector<PIXEL, PIXEL>
+minmax_channel_values( const VIEW& view )
+{
+   PIXEL min, max;
+
+   static_for_each( min, set_to_max() );
+   static_for_each( max, set_to_min() );
+
+   // find the max values
+   for( VIEW::iterator it = view.begin()
+      ; it != view.end()
+      ; ++it )
+   {
+      for( int i = 0; i < num_channels<PIXEL>::type::value; ++i )
+      {
+         if( dynamic_at_c( *it, i ) < dynamic_at_c( min, i ))
+         {
+            dynamic_at_c( min, i ) = dynamic_at_c( *it, i );
+         }
+
+         if( dynamic_at_c( *it, i ) > dynamic_at_c( max, i ))
+         {
+            dynamic_at_c( max, i ) = dynamic_at_c( *it, i );
+         }
+      }
+   }
+
+   return boost::fusion::vector<PIXEL, PIXEL>( min, max );
+}
+
+struct calc_diff
+{
+   template <typename CHANNEL > void operator()( CHANNEL&       diff
+                                               , const CHANNEL& min
+                                               , const CHANNEL& max ) const
+   {
+      diff = max - min;
+   }
+};
+
+typedef channel_type<rgb16_pixel_t>::type channel_t;
+
+template< class SRC
+        , class DST
+        >
+void down_sample( const SRC& src_view
+                , const DST& dst_view  )
+{
+   assert( src_view.dimensions() == dst_view.dimensions() );
+
+   // @todo Take care of signed images. Bransform them into unsigned images
+   // by adding half the value range to the channels.
+
+   typedef SRC::value_type src_pixel_t;
+   typedef DST::value_type dst_pixel_t;
+   typedef channel_type<dst_pixel_t>::type dst_channel_t;
+
+   boost::fusion::vector<src_pixel_t,src_pixel_t> minmax = minmax_channel_values<src_pixel_t>( src_view );
+
+   const src_pixel_t& min = at_c<0>( minmax );
+   const src_pixel_t& max = at_c<1>( minmax );
+
+   // calculate the diff
+   src_pixel_t diff;
+   static_for_each( diff, min, max, calc_diff() );
+
+
+   // sample down
+   dst_channel_t dst_max = channel_traits< dst_channel_t >::max_value();
+
+   for( int y=0; y < src_view.height(); ++y )
+   {
+      SRC::x_iterator src_it = src_view.row_begin( y );
+      DST::x_iterator dst_it = dst_view.row_begin( y );
+
+      for( int x = 0; x < src_view.width(); ++x )
+      {
+         typename src_pixel_t::const_reference src = src_it[x];
+         typename dst_pixel_t::reference       dst = dst_it[x];
+
+         for( int i = 0; i < num_channels<src_pixel_t>::type::value; ++i )
+         {
+            if( dynamic_at_c( diff, i ) == 0 )
+            {
+               dynamic_at_c( dst, i ) = 0;
+            }
+            else
+            {
+               dynamic_at_c( dst, i ) = static_cast<dst_channel_t>( dst_max * ( static_cast<float>( dynamic_at_c( src, i ) 
+                                                                                                  - dynamic_at_c( min, i )) 
+                                                                              / static_cast<float>( dynamic_at_c( diff, i ))));
+            } // else
+
+         } //for
+
+      } //for
+
+   } // for
+}
+
+// channel_wise calculation.
+
+// @todo need better name
+template< typename DST_MAX >
+struct foo
+{
+   foo( const DST_MAX& dst_max )
+   : _dst_max( dst_max ){}
+
+   template < typename DST_CHANNEL
+            , typename SRC_CHANNEL >
+   void operator()( DST_CHANNEL&  dst
+                  , SRC_CHANNEL&  src
+                  , SRC_CHANNEL&  min
+                  , SRC_CHANNEL&  diff )
+   const
+   {
+      if( diff == 0 )
+      {
+         dst = 0;
+
+         return;
+      }
+
+      float d = ( static_cast<float>( _dst_max )
+                * ( ( static_cast<float>( src ) - static_cast<float>( min ))
+                  / static_cast<float>( diff ))));
+
+      dst_channel = static_cast<DST_CHANNEL>( dst );
+   }
+
+   DST_MAX _dst_max;
+};
+
+// pixel_wise calculation.
+
+// @todo need better name
+template< typename SRC_VIEW
+        , typename SRC_PIXEL
+        , typename DST_VIEW
+        , typename DST_MAX
+        >
+struct do_it
+{
+   do_it( const DST_VIEW&  dst_view
+        , const DST_MAX&   dst_max
+        , const SRC_PIXEL& min
+        , const SRC_PIXEL& diff      )
+   : _dst_view( dst_view )
+   , _min( min )
+   , _diff( diff )
+   , _op( dst_max )
+   {
+      _dst_it = dst_view.begin();
+   }
+
+   void operator()( SRC_PIXEL& src ) 
+   {
+      static_for_each( *_dst_it
+                     , src
+                     , _min
+                     , _diff
+                     , _op    );
+      ++_dst_it;
+   }
+
+   typename DST_VIEW::iterator _dst_it;
+
+   foo<DST_MAX> _op;
+
+   DST_VIEW _dst_view;
+
+   SRC_PIXEL _min;
+   SRC_PIXEL _diff;
+};
+
+int main(int argc, char* argv[])
+{
+   {
+      rgb8_image_t dst( 10, 10 );
+
+      min_channel_values<rgb8_image_t::value_type>( view( dst ));
+   }
+
+   {
+/*
+      bits8 max = 255;
+      rgb16_pixel_t min;
+      rgb16_pixel_t diff;
+
+
+      rgb16_image_t src( 640, 480 );
+      rgb8_image_t dst( 640, 480 );
+
+
+      do_it< rgb16_view_t
+           , rgb16_pixel_t
+           , rgb8_view_t
+           , bits8
+           > d( view( dst ), max, min, diff );
+
+      for_each_pixel( view( src ), d );
+
+      bmp_write_view( ".\\red.bmp", view( dst ));
+*/
+   }
+
+   {
+      typedef rgb16_image_t src_image_t;
+      typedef src_image_t::view_t src_view_t;
+      typedef src_view_t::value_type src_pixel_t;
+      typedef channel_type<src_pixel_t>::type src_channel_t;
+      src_channel_t max_value = channel_traits<src_channel_t>::max_value();
+      
+
+      typedef mandelbrot_fn<src_pixel_t> deref_t;
+      typedef deref_t::point_t           point_t;
+
+      typedef virtual_2d_locator<deref_t,false> locator_t;
+      typedef image_view<locator_t> my_virt_view_t;
+
+      function_requires<PixelLocatorConcept<locator_t> >();
+      gil_function_requires<StepIteratorConcept<locator_t::x_iterator> >();
+
+      point_t dims( 640, 480 );
+      my_virt_view_t mandel( dims
+                           , locator_t( point_t( 0, 0 )
+                           , point_t( 1 , 1)
+                           , deref_t( dims
+                                    , src_pixel_t( max_value,         0, 0 )
+                                    , src_pixel_t(         0, max_value, 0 ))));
+
+
+      src_image_t img( dims );
+      copy_pixels( mandel, view( img ));
+
+      // @todo How to compute the unsigned xxx8_image_t from src_image_t?
+      rgb8_image_t eight_bit_img( dims );
+
+      down_sample( view( img )
+                 , view( eight_bit_img ));
+
+      bmp_write_view( ".\\mandelbrot.bmp", view( eight_bit_img ));
+   }
+
+  	return 0;
+}
\ No newline at end of file
Index: boost-1.52.0/src/boost/gil/extension/toolbox/wuline.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/wuline.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,135 @@
+// Copyright Tom Brinkman 2008. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef _wuline_hpp_
+#define _wuline_hpp_
+
+#include "blend.hpp"
+
+template <typename view_t, typename value_type_t> inline 
+void wuline(const view_t& view, const value_type_t& pixel, 
+	int X0, int Y0, int X1, int Y1, int NumLevels=256, int IntensityBits=8)
+{
+	using namespace boost::gil;
+	unsigned short IntensityShift, ErrorAdj, ErrorAcc;
+	unsigned short ErrorAccTemp, Weighting, WeightingComplementMask;
+	short DeltaX, DeltaY, Temp, XDir;
+
+	if (Y0 > Y1) 
+	{
+  		Temp = Y0; Y0 = Y1; Y1 = Temp;
+  		Temp = X0; X0 = X1; X1 = Temp;
+	}
+
+	view(X0,Y0) = pixel;
+
+	if ((DeltaX = X1 - X0) >= 0) 
+	{
+  		XDir = 1;
+	} 
+	else 
+	{
+		XDir = -1;
+		DeltaX = -DeltaX; 
+	}
+
+	if ((DeltaY = Y1 - Y0) == 0) 
+	{
+  		while (DeltaX-- != 0) 
+		{
+			X0 += XDir;
+			view(X0,Y0) = pixel;
+  		}
+      		
+		return;
+	}
+	
+	if (DeltaX == 0) 
+	{
+		do 
+		{
+			Y0++;
+			view(X0,Y0) = pixel;
+		} 
+		while (--DeltaY != 0);
+
+		return;
+	}
+
+	if (DeltaX == DeltaY) 
+	{
+		do 
+		{
+			X0 += XDir;
+			Y0++;
+			view(X0,Y0) = pixel;
+		} 
+		while (--DeltaY != 0);
+
+		return;
+	}
+
+	ErrorAcc = 0;  
+	IntensityShift = 16 - IntensityBits;
+	WeightingComplementMask = NumLevels - 1;
+
+	if (DeltaY > DeltaX) 
+	{
+		ErrorAdj = ((unsigned long) DeltaX << 16) / (unsigned long) DeltaY;
+
+		while (--DeltaY) 
+		{
+			ErrorAccTemp = ErrorAcc;   
+			ErrorAcc += ErrorAdj;     
+         	
+			if (ErrorAcc <= ErrorAccTemp) 
+				X0 += XDir;
+         		
+			Y0++;
+
+			Weighting = ErrorAcc >> IntensityShift;
+	
+			value_type_t dst = pixel;
+			static_for_each(dst,view(X0,Y0), 
+				alpha24_blend((Weighting ^ WeightingComplementMask)));
+			view(X0,Y0) = dst;
+
+			dst = pixel;
+			static_for_each(dst,view(X0 + XDir, Y0), alpha24_blend(Weighting));
+			view(X0 + XDir, Y0) = dst;
+  		}
+
+		view(X1,Y1) = pixel;
+		return;
+	}
+
+	ErrorAdj = ((unsigned long) DeltaY << 16) / (unsigned long) DeltaX;
+
+	while (--DeltaX) 
+	{
+		ErrorAccTemp = ErrorAcc;   
+		ErrorAcc += ErrorAdj;     
+      		
+		if (ErrorAcc <= ErrorAccTemp) 
+			Y0++;
+
+		X0 += XDir; 
+      		
+		Weighting = ErrorAcc >> IntensityShift;
+
+		value_type_t dst = pixel;
+		static_for_each(dst,view(X0,Y0), 
+			alpha24_blend(Weighting ^ WeightingComplementMask));
+		view(X0,Y0) = dst;
+	
+		dst = pixel;
+		static_for_each(dst,view(X0, Y0 + 1), 
+			alpha24_blend(Weighting));
+		view(X0, Y0 + 1) = dst;
+	}
+
+	view(X1,Y1) = pixel;
+}
+
+#endif
Index: boost-1.52.0/src/boost/gil/extension/toolbox/wuline.ppm
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/boost/gil/extension/toolbox/wuline.ppm	2012-11-09 15:21:14.000000000 +0100 differ
Index: boost-1.52.0/src/boost/gil/extension/toolbox/wuline.tests.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/wuline.tests.cpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,41 @@
+#include <boost/test/included/unit_test.hpp>
+
+#include <wuline.hpp>
+
+using boost::unit_test::test_suite;
+using namespace boost::gil;
+
+//g++ wuline.tests.cpp -I /home/scott/project/boost_1_36_0 -I .
+
+struct test1
+{
+	void operator()()
+	{
+		int width = 200;
+		int height = 200;
+		unsigned char* buffer = new unsigned char[width * height * 3];
+		memset(buffer, 255, width * height * 3);	
+		rgb8_view_t view = interleaved_view(width,height,(rgb8_pixel_t*)buffer,width*3);
+
+		double phase = 0;
+		for (double theta = phase; theta < 360 + phase; theta += 10)
+		{
+			int x = (100.0*cos(theta*3.14/180.0)+100);
+			int y = (-100*sin(theta*3.14/180.0)+100);
+			wuline(view,rgb8_pixel_t(0,0,0),x,y,100,100);
+		}
+		
+		FILE* fd = fopen("wuline.ppm", "wb");
+		fprintf(fd, "P6\n# CREATOR: reportbase\n%d %d\n255\n", width, height);
+		fwrite(buffer, 1, width*height*3, fd);
+		fclose(fd);
+		delete [] buffer;
+	}
+};
+
+test_suite* init_unit_test_suite( int argc, char** argv)
+{
+	test_suite* test= BOOST_TEST_SUITE( "wuline tests" );
+	test->add( BOOST_TEST_CASE(test1()), 0);
+	return test;
+}
Index: boost-1.52.0/src/boost/gil/extension/toolbox/xyz.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/boost/gil/extension/toolbox/xyz.hpp	2012-11-09 15:21:14.000000000 +0100
@@ -0,0 +1,159 @@
+// Copyright 2008-12 Chung-Lin Wen, Davide Anastasia
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/*************************************************************************************************/
+
+#ifndef GIL_XYZ_H
+#define GIL_XYZ_H
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file xyz.hpp
+/// \brief Support for CIE XYZ color space
+/// \author Chung-Lin Wen \n
+/// \author Davide Anastasia \n
+////////////////////////////////////////////////////////////////////////////////////////
+
+#include <boost/cast.hpp>
+#include <boost/gil/gil_all.hpp>
+
+namespace boost { namespace gil {
+
+/// \addtogroup ColorNameModel
+/// \{
+namespace xyz_color_space
+{
+/// \brief x Color Component
+struct x_t {};    
+/// \brief y Color Component
+struct y_t {};
+/// \brief z Color Component
+struct z_t {}; 
+}
+/// \}
+
+/// \ingroup ColorSpaceModel
+typedef mpl::vector3< xyz_color_space::x_t
+                    , xyz_color_space::y_t
+                    , xyz_color_space::z_t
+                    > xyz_t;
+
+/// \ingroup LayoutModel
+typedef layout<xyz_t> xyz_layout_t;
+
+GIL_DEFINE_ALL_TYPEDEFS( 32f, xyz );
+
+/// \ingroup ColorConvert
+/// \brief RGB to XYZ
+/// \ref http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
+/// \note rgb_t is assumed to be sRGB D65
+template <>
+struct default_color_converter_impl< rgb_t, xyz_t >
+{
+private:
+    GIL_FORCEINLINE
+    bits32f inverse_companding(bits32f sample) const
+    {
+        if ( sample > 0.04045f )
+        {
+            return powf((( sample + 0.055f ) / 1.055f ), 2.4f);
+        }
+        else
+        {
+            return ( sample / 12.92f );
+        }
+    }
+
+public:
+    template <typename P1, typename P2>
+    void operator()( const P1& src, P2& dst ) const
+    {
+        using namespace xyz_color_space;
+
+        bits32f red(
+                    inverse_companding(
+                        channel_convert<bits32f>( get_color( src, red_t() ))
+                        )
+                    );
+        bits32f green(
+                    inverse_companding(
+                        channel_convert<bits32f>( get_color( src, green_t() ))
+                        )
+                    );
+        bits32f blue(
+                    inverse_companding(
+                        channel_convert<bits32f>( get_color( src, blue_t() ))
+                        )
+                    );
+
+        get_color( dst, x_t() ) =
+                red * 0.4124564f +
+                green * 0.3575761f +
+                blue * 0.1804375f;
+        get_color( dst, y_t() ) =
+                red * 0.2126729f +
+                green * 0.7151522f +
+                blue * 0.0721750f;
+        get_color( dst, z_t() ) =
+                red * 0.0193339f +
+                green * 0.1191920f +
+                blue * 0.9503041f;
+    }
+};
+
+/// \ingroup ColorConvert
+/// \brief XYZ to RGB
+template <>
+struct default_color_converter_impl<xyz_t,rgb_t>
+{
+private:
+    GIL_FORCEINLINE
+    bits32f companding(bits32f sample) const
+    {
+        if ( sample > 0.0031308f )
+        {
+            return ( 1.055f * powf( sample, 1.f/2.4f ) - 0.055f );
+        }
+        else
+        {
+            return ( 12.92f * sample );
+        }
+    }
+
+public:
+    template <typename P1, typename P2>
+    void operator()( const P1& src, P2& dst) const
+    {
+        using namespace xyz_color_space;
+
+        // Note: ideally channel_convert should be compiled out, because xyz_t
+        // is bits32f natively only
+        bits32f x( channel_convert<bits32f>( get_color( src, x_t() ) ) );
+        bits32f y( channel_convert<bits32f>( get_color( src, y_t() ) ) );
+        bits32f z( channel_convert<bits32f>( get_color( src, z_t() ) ) );
+
+        get_color(dst,red_t())  =
+                channel_convert<typename color_element_type<P2, red_t>::type>(
+                    companding( x *  3.2404542f +
+                                y * -1.5371385f +
+                                z * -0.4985314f )
+                    );
+        get_color(dst,green_t()) =
+                channel_convert<typename color_element_type<P2, green_t>::type>(
+                    companding( x * -0.9692660f +
+                                y *  1.8760108f +
+                                z *  0.0415560f )
+                    );
+        get_color(dst,blue_t()) =
+                channel_convert<typename color_element_type<P2, blue_t>::type>(
+                    companding( x *  0.0556434f +
+                                y * -0.2040259f +
+                                z *  1.0572252f )
+                    );
+    }
+};
+
+} }  // namespace boost::gil
+
+#endif // GIL_XYZ_H
Index: boost-1.52.0/src/libs/gil/io_new/doc/io.qbk
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/doc/io.qbk	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,466 @@
+[library Boost.GIL.IO
+	[quickbook 1.3]
+    [authors [Henning, Christian] ]
+    [copyright 2012 Christian Henning]
+    [purpose
+        An generic, user-friendly interface for reading and writing different image formats.
+    ]
+    [id gil.io]
+    [dirname gil/extension/io_new]
+    [license
+        Distributed under the Boost Software License, Version 1.0.
+        (See accompanying file LICENSE_1_0.txt or copy at
+        [@http://www.boost.org/LICENSE_1_0.txt])
+    ]
+]
+
+[/ Links ]
+[def _BMP_Wiki_            [@http://en.wikipedia.org/wiki/BMP_file_format]]
+[def _JPEG_Wiki_           [@http://en.wikipedia.org/wiki/JPEG]]
+[def _JPEG_lib_            [@http://www.ijg.org/]]
+[def _PNG_Wiki_            [@http://en.wikipedia.org/wiki/Portable_Network_Graphics]]
+[def _PNG_Lib_             [@http://libpng.org/pub/png/libpng.html]]
+[def _PNM_Wiki_            [@http://en.wikipedia.org/wiki/Portable_anymap]]
+[def _TARGA_Wiki           [@http://en.wikipedia.org/wiki/Truevision_TGA]]
+[def _TIFF_Wiki_           [@http://en.wikipedia.org/wiki/Tagged_Image_File_Format]]
+[def _TIFF_Lib_            [@http://www.remotesensing.org/libtiff/]]
+[def _TIFF_Base_Tags_      [@http://www.awaresystems.be/imaging/tiff/tifftags/baseline.html]]
+[def _TIFF_Extension_Tags_ [@http://www.awaresystems.be/imaging/tiff/tifftags/extension.html]]
+
+[section Overview]
+This extension to boost::gil provides an easy to use interface for reading and writing
+various image formats. It also includes a framework for adding new formats.
+
+Please see section 3.3 for all supported image formats. A basic tutorial is provided 
+in section [link gil.io.tutorial Tutorial]. Also, this extension requires Boost version 1.42 and up.
+
+For adding new image formats please refer to section [link gil.io.using_io.extending_gil__io_with_new_formats Extending GIL::IO with new Formats].
+[h2 Supported Platforms]
+All platforms supported by boost which have a decent C++ compiler. Depending on the  
+image format one or more of the following image libraries might be needed:
+
+* libtiff
+* libjpeg
+* libpng
+
+The library is designed to support as many formats as required by the user.
+For instance, if the user only needs bmp support none of the above mentioned 
+dependencies are required.
+
+There are more details available in this documentation on the image format dependencies. 
+Please see section [link gil.io.using_io.supported_image_formats Supported Image Formats].
+[endsect]
+
+[section Tutorial]
+Thanks to modern C++ programming techniques the interface for this library
+is rather small and easy to use. In this tutorial I'll give you a short walk-around 
+on how to use this boost::gil extension. For more details please refer to section 3.
+
+Since this is an extension to boost::gil I expect the user to have some very basic
+understanding of the gil ( generic image library ). Please see here for the help.
+
+[h2 Header Files]
+The header files to be included all have the same format. For instance, tiff_all.hpp will 
+allow to read and write. Whereas, tiff_read.hpp only allows for reading. If the user only 
+wants to write jpeg's include jpeg_write.hpp. All formats provide these three types of header files:
+
+* xxx_all.hpp
+* xxx_read.hpp
+* xxx_write.hpp
+
+xxx stands for image format.
+
+[h2 Reading An Image]
+Probably the most common case to read a tiff image can be done as follows:
+
+    std::string filename( "image.tif" );
+    rgb8_image_t img;
+    read_image( filename, img, tiff_tag() );
+
+The code would be same for all other image formats. The only thing that needs to
+change is the tag type ( tiff_tag ) in the read_image call.
+The read_image() expects the supplied image type to be compatible with the 
+image stored in the file. If the user doesn't know what format an image has he/she
+can use read_and_convert_image().
+Another important fact is that read_image() will allocate the appropriate
+memory needed for the read operation. There are read_view or read_and_convert_view
+counterparts, if the memory is already allocated.
+
+Sometimes the user only wants to read a sub-part of an image, then the above call
+would look as follows:
+
+    read_image( filename
+              , img
+              , image_read_settings< tiff_tag >( point_t( 0, 0 ), point_t( 50, 50 ) )
+              );
+
+The image_read_settings class will provide the user with image format independent 
+reading setting but can also serves as a pointer for format dependent settings. Please
+see the specific image format sections [link gil.io.using_io.supported_image_formats Supported Image Formats] for more details.
+
+[h2 Writing An Image]
+Besides reading the information also writing is the second part of this boost::gil extension.
+Writing is a lot simpler than reading since an existing image view contains all the information.
+For instance writing an image can be done as follows:
+
+    std::string filename( "image.tif" );
+    rgb8_image_t img( 640, 480 );
+    
+    // write data into image
+
+    write_view( filename
+              , view( img )
+              , tiff_tag()
+              );
+
+
+The interface is similar to reading an image. To add image format specific parameter the user can use
+image_write_info class. For instance, a user can specify the jpeg quality when writing like this:
+
+    std::string filename( "image.jpg" );
+    rgb8_image_t img( 640, 480 );
+
+    // write data into image
+
+    write_view( filename
+              , view( img )
+              , image_write_info< jpeg_tag >( 95 )
+              );
+
+
+The above example will write an image where the jpeg quality is set to 95 percent.
+
+[h2 Reading And Writing In-Memory Buffers]
+Reading and writing in-memory buffers are supported as well. See as follows:
+
+    // 1. Read an image.
+    ifstream in( "test.tif", ios::binary );
+
+    rgb8_image_t img;
+    read_image( in, img, tiff_tag() );
+
+    // 2. Write image to in-memory buffer.
+    stringstream out_buffer( ios_base::out | ios_base::binary );
+
+    rgb8_image_t src;
+    write_view( out_buffer, view( src ), tiff_tag() );
+
+    // 3. Copy in-memory buffer to another.
+    stringstream in_buffer( ios_base::in | ios_base::binary );
+    in_buffer << out_buffer.rdbuf();
+
+    // 4. Read in-memory buffer to gil image
+    rgb8_image_t dst;
+    read_image( in_buffer, dst, tag_t() );
+
+    // 5. Write out image.
+    string filename( "out.tif" );
+    ofstream out( filename.c_str(), ios_base::binary );
+    write_view( out, view( dst ), tiff_tag() );
+
+In case the user is using his own stream classes he has to make sure it has the common interface read,
+write, seek, close, etc. Interface.
+
+[endsect]
+
+[section:using_io Using IO]
+[h2 Read Interface]
+As the Tutorial demonstrated there are a few ways to read images. Here is an enumeration of 
+all read functions with a short description:
+
+    * read_image - read into a gil image with no conversion. Memory is allocated.
+    * read_view  - read into a gil view with no conversion.
+    * read_and_convert_image - read and convert into a gil image. Memory is allocated.
+    * read_and_convert_view  - read and convert into a gil view.
+    * read_image_info - read the image header.
+
+Conversion in this context is necessary if the source ( file ) has an incompatible color space
+with the destination ( gil image type ). If that's the case the user has to use the xxx_and_convert_xxx
+variants.
+
+All functions take the filename or a device as the first parameter. The filename can be anything from 
+a c string, std::string, std::wstring, and a boost::filesystem path. When using the path object the 
+user needs to define the ADD_FS_PATH_SUPPORT compiler symbol to include the boost::filesystem 
+dependency. Devices could be a FILE*, std::ifstream, and a TIFF* for TIFF images.
+
+The second parameter is either an image or view type depending on the read_xxx function.
+The third and last parameter is either an instance of the image_read_settings<FormatTag> or just the 
+FormatTag. The settings can be various depending on the format which is being read. But the all
+share settings for reading a partial image area. The first point describes the top left image
+coordinate whereas the second are the dimensions in x and y directions. Here an example of
+setting up partial read.
+
+    read_image( filename
+              , img
+              , image_read_settings< tiff_tag >( point_t( 0, 0 ), point_t( 50, 50 ) )
+              );
+
+Each format supports reading just the header information, using read_image_info(). Please
+refer to the format specific sections under 3.3. A basic example follows:
+
+    image_read_info< tiff_t > info = read_image_info( filename
+                                                    , tiff_t()
+                                                    );
+
+GIL also comes with a dynamic image extension. In the context of GIL.IO a user can define an any_image type based
+on several image types. The IO extension would then pick the matching image type to the current image file.
+The following example shows this feature:
+
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , rgba_image_t
+                       > my_img_types;
+
+    any_image< my_img_types > runtime_image;
+
+    read_image( filename
+              , runtime_image
+              , tiff_tag()
+              );
+
+[h2 Write Interface]
+There is only one function for writing out images, write_view. Similar to reading the first parameter is either
+a filename or a device. The filename can be anything from a c string, std::string, std::wstring, and a 
+boost::filesystem path. When using the path object the user needs to define the ADD_FS_PATH_SUPPORT compiler symbol 
+to include the boost::filesystem dependency. Devices could be a FILE*, std::ifstream, and a TIFF* for TIFF images.
+
+The second parameter is an view object to image being written. The third and last parameter is either a tag or 
+an image_write_info< FormatTag > object containing more settings. One example for instance is the jpeg quality. 
+Refer to the format specific sections under 3.3. to have a list of all the possible settings.
+
+Writing an any_image<...> is supported. See the following example:
+
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , rgba_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    // fill any_image 
+
+    write_view( filename
+              , view( runtime_image )
+              , tiff_tag()
+              );
+
+[h2 Supported Image Formats]
+[h3 BMP]
+For a general overview of the BMP image file format go to the following _BMP_Wiki_.
+
+Please note, the code has not been tested on X Windows System variations
+of the BMP format which are usually referred to XBM and XPM formats.
+
+Here, only the MS Windows and OS/2 format is relevant.
+
+Currently the code is able to read and write the following image types:
+
+Read: gray1_image_t, gray4_image_t, gray8_image_t, rgb8_image_t and, rgba8_image_t
+Write: rgb8_image_t and, rgba8_image_t
+
+The lack of having an indexed image type in gil restricts the current interface to only
+write out non-indexed images. This is subject to change soon.
+
+[h3 JPEG]
+For a general overview of the JPEG image file format go to the following _JPEG_Wiki_.
+
+This jpeg extension is based on the libjpeg library which can be found here, _JPEG_Lib_.
+
+The user has to make sure this library is properly installed. I strongly recommend the user
+to build the library yourself. It could potentially save you a lot of trouble.
+
+Currently the code is able to read and write the following image types:
+
+Read: gray8_image_t, rgb8_image_t, cmyk8_image_t
+Write: gray8_image_t, rgb8_image_t, cmyk8_image_t
+
+Reading YCbCr or YCCK images is possible but might result in inaccuracies since both color spaces
+aren't available yet for gil. For now these color space are read as rgb images.
+This is subject to change soon.
+
+[h4 Compiler Symbols]
+BOOST_GIL_EXTENSION_IO_JPEG_C_LIB_COMPILED_AS_CPLUSPLUS
+This symbol can be used to let compiler know that libjpeg was compiled as a cpp project. By default this symbol is off. 
+
+
+[h3 PNG]
+For a general overview of the PNG image file format go to the following _PNG_Wiki_.
+
+This png extension is based on the libpng, which can be found here, _PNG_Lib.
+
+The user has to make sure this library is properly installed. I strongly recommend the user
+to build the library yourself. It could potentially save you a lot of trouble.
+
+Currently the code is able to read and write the following image types:
+
+Read: gray1, gray2, gray4, gray8, gray16, gray_alpha_8, gray_alpha_16, rgb8, rgb16, rgba8, rgba16
+Write: gray1, gray2, gray4, gray8, gray16, gray_alpha_8, gray_alpha_16, rgb8, rgb16, rgba8, rgba16
+
+For reading gray_alpha images the user has to enable the ENABLE_GRAY_ALPHA compiler switch. This color
+space is defined in the toolbox by using gray_alpha.hpp.
+
+[h4 Compiler Symbols]
+BOOST_GIL_EXTENSION_IO_PNG_C_LIB_COMPILED_AS_CPLUSPLUS
+This symbol can be used to let compiler know that libjpeg was compiled as a cpp project. By default this symbol is off. 
+
+[h3 PNM]
+For a general overview of the PNM image file format go to the following _PNM_Wiki_.
+
+No external library is needed for the pnm format. Both ascii and binary formats are supported.
+
+Currently the code is able to read and write the following image types:
+
+Read: gray1, gray8, rgb8
+Write: gray1, gray8, rgb8
+
+When reading a mono text image the data is read as a gray8 image.
+
+[h3 TARGA]
+For a general overview of the BMP image file format go to the following _TARGA_Wiki_.
+
+Currently the code is able to read and write the following image types:
+
+Read: rgb8_image_t and rgba8_image_t
+Write: rgb8_image_t and rgba8_image_t
+
+The lack of having an indexed image type in gil restricts the current interface to only
+write out non-indexed images. This is subject to change soon.
+
+[h3 TIFF]
+For a general overview of the TIFF image file format go to the following _TIFF_Wiki_.
+
+This tiff extension is based on the libtiff, which can be found, _TIFF_Lib_.
+
+The user has to make sure this library is properly installed. I strongly recommend the user
+to build the library yourself. It could potentially save you a lot of trouble.
+
+TIFF images can virtually encode all kinds of channel sizes representing various color spaces. Even
+planar images are possible. For instance, rbg323 or gray7. The channels also can have specific formats, like
+integer values or floating point values. For a complete set of options please consult the following websites:
+
+* _TIFF_Base_Tags_
+* _TIFF_Extension_Tags_
+
+The author of this extension is not claiming all tiff formats are supported. This extension is
+likely to be a moving target adding new features with each new milestone. Here is an incomplete lists:
+
+* Multi-page tiffs - read only
+* Strip tiffs - read and write support
+* Tiled tiffs - read and write support with user defined tiled sizes
+* bit images tiffs - fully supported, like gray1_image_t ( minisblack )
+* planar tiffs - fully supported
+* floating point tiffs - fully supported
+* palette tiffs - supported but no indexed image type is available as of now
+
+This gil extension uses two different test image suites to test read and write capabilities. See test_image folder.
+It's advisable to use ImageMagick's test viewer to display images.
+
+[h4 Compiler Symbols]
+BOOST_GIL_EXTENSION_IO_TIFF_C_LIB_COMPILED_AS_CPLUSPLUS
+This symbol can be used to let compiler know that libjpeg was compiled as a cpp project. By default this symbol is off. 
+
+
+[h2 Extending GIL::IO with new Formats]
+Extending the gil::io with new formats is meant to be simple and straightforward. Before adding I would
+recommend to have a look at existing implementations and then trying to follow a couple of guidelines:
+
+* Create the following files for your new xxx format
+	* xxx_read.hpp // Only includes read code
+	* xxx_write.hpp // Only includes write code
+	* xxx_all.hpp // includes xxx_read.hpp and xxx_write.hpp
+* Add the code to the boost::gil::detail namespace
+* Create a tag type for the new format. Like this:
+  ``
+		struct xxx_tag : format_tag {};
+  ``
+
+* Create the image_read_info for the new format. It contains all the information that are
+  necessary to read an image. It should be filled and returned by the get_info() member of
+  the reader class. See below.
+  ``
+	  template<> struct image_read_info< xxx_tag > {};
+  ``
+
+* Create the image_write_info for the new format. It contains all the information that are
+  necessary to write an image.
+  ``
+	  template<> struct image_write_info< xxx_tag > {};
+  ``
+
+* Use the following reader skeleton as a start:
+  ``
+    template< typename Device
+            , typename ConversionPolicy
+            >
+    class reader< Device
+                , xxx_tag
+                , ConversionPolicy
+                > 
+                : public reader_base< xxx_tag
+                                    , ConversionPolicy
+                                    >
+    {
+    private:
+
+        typedef typename ConversionPolicy::color_converter_type cc_t;
+
+    public:
+
+        reader( Device& device )
+        : _io_dev( device )
+        {}
+
+        reader( Device&     device
+              , const cc_t& cc
+              )
+        : _io_dev( device )
+        , reader_base< xxx_tag
+                     , ConversionPolicy
+                     >( cc )
+        {}
+
+        image_read_info< xxx_tag > get_info()
+        {
+            // your implementation here
+        }
+
+        template< typename View >
+        void apply( const View& dst_view )
+        {
+            // your implementation here
+        }
+    };
+  `` 
+
+* The writer skeleton:
+  ``    
+    template< typename Device >
+    class writer< Device
+                , xxx_tag
+                > 
+    {
+    public:
+
+        writer( Device & file )
+        : out(file)
+        {}
+
+        template<typename View>
+        void apply( const View& view )
+        {
+            // your implementation here
+        }
+
+        template<typename View>
+        void apply( const View&                        view
+                  , const image_write_info< xxx_tag >& info )
+        {
+            // your implementation here
+        }
+    };
+  ``
+
+[endsect]
Index: boost-1.52.0/src/libs/gil/io_new/doc/jamfile.v2
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/doc/jamfile.v2	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,34 @@
+# Boost.GIL.io
+#
+# Copyright (c) 2009 Christian Henning
+#
+# Distributed under the Boost Software License, Version 1.0.
+# (See accompanying file LICENSE_1_0.txt or copy at
+# http://www.boost.org/LICENSE_1_0.txt)
+
+
+# Quickbook
+# -----------------------------------------------------------------------------
+
+import quickbook ;
+using boostbook ;
+
+xml io
+    :
+        io.qbk
+    ;
+
+path-constant images_location : html ;
+
+boostbook standalone
+    :
+        io
+	:
+        <xsl:param>boost.root=../../../../..
+        <xsl:param>boost.max.id.length=1024
+        <xsl:param>toc.max.depth=4
+        <xsl:param>toc.section.depth=4
+        <xsl:param>chunk.section.depth=2
+        <format>pdf:<xsl:param>img.src.path=$(images_location)/
+        <format>pdf:<xsl:param>boost.url.prefix=http://www.boost.org/doc/libs/release/doc/html
+    ;
Index: boost-1.52.0/src/libs/gil/io_new/test/Jamfile.v2
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/Jamfile.v2	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,88 @@
+# (C) Copyright 2012: Mateusz Loskot and Christian Henning
+# Distributed under the Boost Software License, Version 1.0.
+# (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+# Please make sure to read readme.txt!
+
+# bring in rules for testing
+import testing ;
+
+using jpeg 	    : 	 8b : C:/chhenning/jpeg-8c ;
+using zlib      : 1.2.5 : C:/chhenning/zlib-1.2.5 ;
+using png       : 1.4.4 : C:/chhenning/png/lpng154 ;
+using libtiff   : 3.9.4 : C:/chhenning/tiff/tiff-3.9.5 ;
+
+project
+    : requirements
+        <toolset>intel:<debug-symbols>off
+        <toolset>msvc-7.1:<debug-symbols>off
+        <toolset>msvc-8.0:<define>_SCL_SECURE_NO_DEPRECATE <define>_CRT_SECURE_NO_DEPRECATE <define>_CRT_NONSTDC_NO_DEPRECATE
+        <toolset>msvc-9.0:<define>_SCL_SECURE_NO_DEPRECATE <define>_CRT_SECURE_NO_WARNINGS <define>_CRT_NONSTDC_NO_DEPRECATE
+        <toolset>msvc-10.0:<define>_SCL_SECURE_NO_DEPRECATE <define>_CRT_SECURE_NO_WARNINGS <define>_CRT_NONSTDC_NO_DEPRECATE
+        <link>static
+        <library>/boost/test//boost_unit_test_framework
+		<library>/boost/system//boost_system
+		<library>/boost/filesystem//boost_filesystem
+    ;
+
+test-suite "gil::io_new"
+	:
+	[ run
+	  # sources
+      test.cpp
+	  all_formats_test.cpp
+	  bmp_old_test.cpp
+      bmp_read_test.cpp
+      bmp_test.cpp
+      bmp_write_test.cpp
+      jpeg_old_test.cpp
+      jpeg_read_test.cpp
+	  jpeg_test.cpp
+      jpeg_write_test.cpp
+	  png_file_format_test.cpp
+      png_old_test.cpp
+	  png_read_test.cpp
+	  png_test.cpp
+	  pnm_old_test.cpp
+	  pnm_read_test.cpp
+	  pnm_test.cpp
+	  pnm_write_test.cpp
+	  tiff_file_format_test.cpp
+	  tiff_old_test.cpp
+	  tiff_subimage_test.cpp
+	  tiff_test.cpp
+	  tiff_tiled_float_test.cpp
+	  tiff_tiled_minisblack_test_1-10.cpp
+	  tiff_tiled_minisblack_test_11-20.cpp
+	  tiff_tiled_minisblack_test_21-31_32-64.cpp
+	  tiff_tiled_minisblack_write_test_1-10.cpp
+	  tiff_tiled_minisblack_write_test_11-20.cpp
+	  tiff_tiled_minisblack_write_test_21-31_32-64.cpp
+	  tiff_tiled_palette_test_1-8.cpp
+	  tiff_tiled_palette_test_8-16.cpp
+	  tiff_tiled_palette_write_test_1-8.cpp
+	  tiff_tiled_palette_write_test_8-16.cpp
+	  tiff_tiled_rgb_contig_test_1-10.cpp
+	  tiff_tiled_rgb_contig_test_11-20.cpp
+	  tiff_tiled_rgb_contig_test_21-31_32_64.cpp
+	  tiff_tiled_rgb_contig_write_test_1-10.cpp
+	  tiff_tiled_rgb_contig_write_test_11-20.cpp
+	  tiff_tiled_rgb_contig_write_test_21-31_32_64.cpp
+	  tiff_tiled_rgb_planar_test_1-10.cpp
+	  tiff_tiled_rgb_planar_test_11-20.cpp
+	  tiff_tiled_rgb_planar_test_21-31_32_64.cpp
+	  tiff_tiled_test.cpp
+	  /ext/jpeg//jpeg
+	  /ext/png//png
+	  /ext/libtiff//tiff
+	  /ext/libtiff//tiffxx
+	  /ext/zlib//z
+	  : # args
+	  : # input-files
+	  :	# requirements
+	  : # target-name
+	  gil_io_new_tests
+	  : # default-build
+	]
+
+    ;
Index: boost-1.52.0/src/libs/gil/io_new/test/all_formats_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/all_formats_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,61 @@
+// Test will include all format's headers and load and write some images.
+// This test is more of a compilation test.
+
+
+#include <boost/gil/extension/io_new/png_all.hpp>
+#include <boost/gil/extension/io_new/bmp_all.hpp>
+#include <boost/gil/extension/io_new/jpeg_all.hpp>
+#include <boost/gil/extension/io_new/pnm_all.hpp>
+#include <boost/gil/extension/io_new/targa_all.hpp>
+#include <boost/gil/extension/io_new/tiff_all.hpp>
+
+#include <boost/test/unit_test.hpp>
+
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost::gil;
+
+
+BOOST_AUTO_TEST_SUITE( all_formats_test )
+
+BOOST_AUTO_TEST_CASE( non_bit_aligned_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_image( bmp_filename, img, bmp_tag() );
+        write_view( bmp_out + "all_formats_test.bmp", view( img ), bmp_tag() );
+    }
+
+    {
+        rgb8_image_t img;
+        read_image( jpeg_filename, img, jpeg_tag() );
+        write_view( jpeg_out + "all_formats_test.jpg", view( img ), jpeg_tag() );
+    }
+
+    {
+        rgba8_image_t img;
+        read_image( png_filename, img, png_tag() );
+        write_view( png_out + "all_formats_test.png", view( img ), png_tag() );
+    }
+
+    {
+        rgb8_image_t img;
+        read_image( pnm_filename, img, pnm_tag() );
+        write_view( pnm_out + "all_formats_test.pnm", view( img ), pnm_tag() );
+    }
+
+    {
+        rgb8_image_t img;
+        read_image( targa_filename, img, targa_tag() );
+        write_view( targa_out + "all_formats_test.tga", view( img ), targa_tag() );
+    }
+
+    {
+        rgb8_image_t img;
+        read_image( tiff_filename, img, tiff_tag() );
+        write_view( tiff_out + "all_formats_test.tif", view( img ), tiff_tag() );
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/bmp_old_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/bmp_old_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,96 @@
+//#define BOOST_TEST_MODULE bmp_old_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/bmp_io_old.hpp>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+BOOST_AUTO_TEST_SUITE( bmp_test )
+
+BOOST_AUTO_TEST_CASE( old_read_dimensions_test )
+{
+    {
+        point2< ptrdiff_t > dim = bmp_read_dimensions( bmp_filename );
+
+        BOOST_CHECK_EQUAL( dim.x, 127 );
+        BOOST_CHECK_EQUAL( dim.y, 64 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_image_test )
+{
+    {
+        rgb8_image_t img;
+        bmp_read_image( bmp_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 127 );
+        BOOST_CHECK_EQUAL( img.height(), 64 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        bmp_read_and_convert_image( bmp_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 127 );
+        BOOST_CHECK_EQUAL( img.height(), 64 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_view_test )
+{
+    {
+        rgb8_image_t img( 127, 64 );
+        bmp_read_view( bmp_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 127, 64 );
+        bmp_read_and_convert_view( bmp_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_write_view_test )
+{
+    {
+        bmp_write_view( bmp_out + "old_write_view_test.bmp"
+                      , create_mandel_view( 127, 64
+                                          , rgb8_pixel_t( 0,   0, 255 )
+                                          , rgb8_pixel_t( 0, 255,   0 )
+                                          )
+                      );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_dynamic_image_test )
+{
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , rgba8_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    bmp_read_image( bmp_filename.c_str()
+                  , runtime_image
+                  );
+
+    bmp_write_view( bmp_out + "old_dynamic_image_test.bmp"
+                  , view( runtime_image )
+                  );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/bmp_read_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/bmp_read_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,492 @@
+//#define BOOST_TEST_MODULE bmp_read_test_module
+#include <boost/test/unit_test.hpp>
+#include <boost/type_traits/is_same.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/bmp_all.hpp>
+
+#include "scanline_read_test.hpp"
+
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost::gil;
+
+typedef bmp_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( bmp_test )
+
+template< typename Image >
+void write( Image&        img
+          , const string& file_name
+          )
+{
+    write_view( bmp_out + file_name
+              , view( img )
+              , tag_t()
+              );
+}
+
+BOOST_AUTO_TEST_CASE( read_header_test )
+{
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( bmp_filename
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._offset               ,    54u );
+        BOOST_CHECK_EQUAL( backend._info._header_size          ,    40u );
+        BOOST_CHECK_EQUAL( backend._info._width                ,   127  );
+        BOOST_CHECK_EQUAL( backend._info._height               ,    64  );
+        BOOST_CHECK_EQUAL( backend._info._bits_per_pixel       ,    24  );
+        BOOST_CHECK_EQUAL( backend._info._compression          ,     0u );
+        BOOST_CHECK_EQUAL( backend._info._image_size           , 24576u );
+        BOOST_CHECK_EQUAL( backend._info._horizontal_resolution,     0  );
+        BOOST_CHECK_EQUAL( backend._info._vertical_resolution  ,     0  );
+        BOOST_CHECK_EQUAL( backend._info._num_colors           ,     0u );
+        BOOST_CHECK_EQUAL( backend._info._num_important_colors ,     0u );
+        BOOST_CHECK_EQUAL( backend._info._valid                ,  true  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_reference_images_test )
+{
+    // comments are taken from http://entropymine.com/jason/bmpsuite/reference/reference.html
+
+    // g01bw.bmp - black and white palette (#000000,#FFFFFF)
+    {
+        rgba8_image_t img;
+        read_image( bmp_in + "g01bw.bmp", img, tag_t() );
+    }
+
+    // g01wb.bmp - white and black palette (#FFFFFF,#000000). 
+    // Should look the same as g01bw, not inverted.
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g01wb.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g01wb.bmp" );
+    }
+
+    // g01bg.bmp - blue and green palette (#4040FF,#40FF40)
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g01bg.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g01bg.bmp" );
+    }
+
+    // g01p1.bmp - 1-color (blue) palette (#4040FF)
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g01p1.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g01p1.bmp" );
+    }
+
+    // g04.bmp - basic 4bpp (16 color) image
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g04.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g04.bmp" );
+    }
+
+    // g04rle.bmp - RLE compressed.
+    {
+        rgb8_image_t img;
+        
+        read_image( bmp_in + "g04rle.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g04rle.bmp" );
+    }
+
+    // g04p4.bmp - 4-color grayscale palette
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g04p4.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g04p4.bmp" );
+    }
+
+    // g08.bmp - basic 8bpp (256 color) image
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08.bmp" );
+    }
+
+    // g08p256.bmp - biClrUsed=256, biClrImportant=0 [=256]
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08p256.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08p256.bmp" );
+    }
+
+    // g08pi256.bmp - biClrUsed=256, biClrImportant=256
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08pi256.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08pi256.bmp" );
+    }
+
+    // g08pi64.bmp - biClrUsed=256, biClrImportant=64. It's barely possible that some 
+    // sophisticated viewers may display this image in grayscale, if there are a 
+    // limited number of colors available.
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08pi64.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08pi64.bmp" );
+    }
+
+    // g08rle.bmp - RLE compressed.
+    {
+        rgb8_image_t img;
+        
+        read_image( bmp_in + "g08rle.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08rle.bmp" );
+    }
+
+    // g08os2.bmp - OS/2-style bitmap. This is an obsolete variety of BMP 
+    // that is still encountered sometimes. It has 3-byte palette 
+    // entries (instead of 4), and 16-bit width/height fields (instead of 32).
+    {
+        rgb8_image_t img;
+        
+        read_image( bmp_in + "g08os2.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08os2.bmp" );
+    }
+
+    // g08res22.bmp - resolution 7874x7874 pixels/meter (200x200 dpi)
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08res22.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08res22.bmp" );
+    }
+
+    // g08res11.bmp - resolution 3937x3937 pixels/meter (100x100 dpi)
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08res11.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08res11.bmp" );
+    }
+
+    // g08res21.bmp resolution 7874x3937 pixels/meter (200x100 dpi). 
+    // Some programs (e.g. Imaging for Windows) may display this image 
+    // stretched vertically, which is the optimal thing to do if the 
+    // program is primarily a viewer, rather than an editor.
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08res21.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08res21.bmp" );
+    }
+
+    // g08s0.bmp - bits size not given (set to 0). This is legal for uncompressed bitmaps.
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08s0.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08s0.bmp" );
+    }
+
+    // g08offs.bmp - bfOffBits in header not set to the usual value. 
+    // There are 100 extra unused bytes between palette and bits.
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08offs.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08offs.bmp" );
+    }
+
+    // g08w126.bmp - size 126x63 (right and bottom slightly clipped)
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08w126.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 126u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  63u );
+
+        write( img, "g08w126.bmp" );
+    }
+
+    // g08w125.bmp - size 125x62
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08w125.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 125u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  62u );
+
+        write( img, "g08w125.bmp" );
+    }
+
+    // g08w124.bmp - size 124x61
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08w124.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 124u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  61u );
+
+        write( img, "g08w124.bmp" );
+    }
+
+    // g08p64.bmp - 64-color grayscale palette
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g08p64.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g08p64.bmp" );
+    }
+
+    // g16def555.bmp - 15-bit color (1 bit wasted), biCompression=BI_RGB (no bitfields, defaults to 5-5-5)
+    {
+        rgb8_image_t img;
+        
+        read_image( bmp_in + "g16def555.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g16def555.bmp" );
+    }
+
+    // g16bf555.bmp - 15-bit color, biCompression=BI_BITFIELDS (bitfields indicate 5-5-5)
+    {
+        rgb8_image_t img;
+        
+        read_image( bmp_in + "g16bf555.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g16bf555.bmp" );
+    }
+
+    // g16bf565.bmp - 16-bit color, biCompression=BI_BITFIELDS (bitfields indicate 5-6-5)
+    {
+        rgb8_image_t img;
+        
+        read_image( bmp_in + "g16bf565.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g16bf565.bmp" );
+    }
+
+    // g24.bmp - 24-bit color (BGR)
+    {
+        rgb8_image_t img;
+        
+        read_image( bmp_in + "g24.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g24.bmp" );
+    }
+
+    // g32def.bmp - 24-bit color (8 bits wasted), biCompression=BI_RGB (no bitfields, defaults to BGRx)
+    {
+        rgba8_image_t img;
+        
+        read_image( bmp_in + "g32def.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g32def.bmp" );
+    }
+
+    // g32bf.bmp - 24-bit color (8 bits wasted), biCompression=BI_BITFIELDS (bitfields indicate BGRx)
+    {
+        rgba8_image_t img;
+
+        read_image( bmp_in + "g32bf.bmp", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 127u );
+        BOOST_CHECK_EQUAL( view( img ).height(),  64u );
+
+        write( img, "g32bf.bmp" );
+    }
+}
+
+
+BOOST_AUTO_TEST_CASE( read_reference_images_image_iterator_test )
+{
+    // comments are taken from http://entropymine.com/jason/bmpsuite/reference/reference.html
+
+    // g01bw.bmp - black and white palette (#000000,#FFFFFF)
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g01bw.bmp" ).c_str() );
+
+    // g01wb.bmp - white and black palette (#FFFFFF,#000000). 
+    // Should look the same as g01bw, not inverted.
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g01wb.bmp" ).c_str() );
+
+    // g01bg.bmp - blue and green palette (#4040FF,#40FF40)
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g01bg.bmp" ).c_str() );
+
+    // g01p1.bmp - 1-color (blue) palette (#4040FF)
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g01p1.bmp" ).c_str() );
+
+    // g04.bmp - basic 4bpp (16 color) image
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g04.bmp" ).c_str() );
+
+    // not supported
+    // g04rle.bmp - RLE compressed.
+    //test_scanline_reader< bgra8_image_t, bmp_tag >( string( bmp_in + "g01bg.bmp" ).c_str() );
+
+    // g04p4.bmp - 4-color grayscale palette
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g04p4.bmp" ).c_str() );
+
+    // g08.bmp - basic 8bpp (256 color) image
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08.bmp" ).c_str() );
+
+    // g08p256.bmp - biClrUsed=256, biClrImportant=0 [=256]
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08p256.bmp" ).c_str() );
+
+    // g08pi256.bmp - biClrUsed=256, biClrImportant=256
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08pi256.bmp" ).c_str() );
+
+    // g08pi64.bmp - biClrUsed=256, biClrImportant=64. It's barely possible that some 
+    // sophisticated viewers may display this image in grayscale, if there are a 
+    // limited number of colors available.
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08pi64.bmp" ).c_str() );
+
+    // not supported
+    // g08rle.bmp - RLE compressed.
+
+    // g08os2.bmp - OS/2-style bitmap. This is an obsolete variety of BMP 
+    // that is still encountered sometimes. It has 3-byte palette 
+    // entries (instead of 4), and 16-bit width/height fields (instead of 32).
+    test_scanline_reader< rgb8_image_t, bmp_tag >( string( bmp_in + "g08os2.bmp" ).c_str() );
+
+    // g08res22.bmp - resolution 7874x7874 pixels/meter (200x200 dpi)
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08res22.bmp" ).c_str() );
+
+    // g08res11.bmp - resolution 3937x3937 pixels/meter (100x100 dpi)
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08res11.bmp" ).c_str() );
+
+    // g08res21.bmp resolution 7874x3937 pixels/meter (200x100 dpi). 
+    // Some programs (e.g. Imaging for Windows) may display this image 
+    // stretched vertically, which is the optimal thing to do if the 
+    // program is primarily a viewer, rather than an editor.
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08res21.bmp" ).c_str() );
+
+    // g08s0.bmp - bits size not given (set to 0). This is legal for uncompressed bitmaps.
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08s0.bmp" ).c_str() );
+
+    // g08offs.bmp - bfOffBits in header not set to the usual value. 
+    // There are 100 extra unused bytes between palette and bits.
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08offs.bmp" ).c_str() );
+
+    // g08w126.bmp - size 126x63 (right and bottom slightly clipped)
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08w126.bmp" ).c_str() );
+
+    // g08w125.bmp - size 125x62
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08w125.bmp" ).c_str() );
+
+    // g08w124.bmp - size 124x61
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08w124.bmp" ).c_str() );
+
+    // g08p64.bmp - 64-color grayscale palette
+    test_scanline_reader< rgba8_image_t, bmp_tag >( string( bmp_in + "g08p64.bmp" ).c_str() );
+
+    // g16def555.bmp - 15-bit color (1 bit wasted), biCompression=BI_RGB (no bitfields, defaults to 5-5-5)
+    test_scanline_reader< rgb8_image_t, bmp_tag >( string( bmp_in + "g16def555.bmp" ).c_str() );
+
+    // g16bf555.bmp - 15-bit color, biCompression=BI_BITFIELDS (bitfields indicate 5-5-5)
+    test_scanline_reader< rgb8_image_t, bmp_tag >( string( bmp_in + "g16bf555.bmp" ).c_str() );
+
+    // g16bf565.bmp - 16-bit color, biCompression=BI_BITFIELDS (bitfields indicate 5-6-5)
+    test_scanline_reader< rgb8_image_t, bmp_tag >( string( bmp_in + "g16bf565.bmp" ).c_str() );
+
+    // g24.bmp - 24-bit color (BGR)
+    test_scanline_reader< bgr8_image_t, bmp_tag >( string( bmp_in + "g24.bmp" ).c_str() );
+
+    // g32def.bmp - 24-bit color (8 bits wasted), biCompression=BI_RGB (no bitfields, defaults to BGRx)
+    test_scanline_reader< bgra8_image_t, bmp_tag >( string( bmp_in + "g32def.bmp" ).c_str() );
+
+    // g32bf.bmp - 24-bit color (8 bits wasted), biCompression=BI_BITFIELDS (bitfields indicate BGRx)
+    test_scanline_reader< bgra8_image_t, bmp_tag >( string( bmp_in + "g32bf.bmp" ).c_str() );
+}
+
+BOOST_AUTO_TEST_CASE( partial_image_test )
+{
+    const std::string filename( bmp_in + "rgb.bmp" );
+
+    {
+        rgb8_image_t img;
+        read_image( filename
+                  , img
+                  , image_read_settings< bmp_tag >( point_t( 0, 0 ), point_t( 50, 50 ) )
+                  );
+
+
+        write_view( bmp_out + "rgb_partial.bmp"
+                  , view( img )
+                  , tag_t()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/bmp_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/bmp_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,341 @@
+//#define BOOST_TEST_MODULE bmp_test_module
+#include <boost/test/unit_test.hpp>
+
+#define BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+#include <fstream>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/bmp_all.hpp>
+
+#define BOOST_FILESYSTEM_VERSION 3
+#include <boost/filesystem/convenience.hpp>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+#include "subimage_test.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+namespace fs = boost::filesystem;
+
+typedef bmp_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( bmp_test )
+
+BOOST_AUTO_TEST_CASE( read_image_info_using_string )
+{
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( bmp_filename
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 127 );
+        BOOST_CHECK_EQUAL( backend._info._height, 64 );
+    }
+
+    {
+        ifstream in( bmp_filename.c_str(), ios::binary );
+
+        typedef get_reader_backend< std::ifstream
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( in
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 127 );
+        BOOST_CHECK_EQUAL( backend._info._height, 64 );
+    }
+
+    {
+        FILE* file = fopen( bmp_filename.c_str(), "rb" );
+
+        typedef get_reader_backend< FILE*
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( file
+                                           , tag_t()
+                                           );
+        
+        BOOST_CHECK_EQUAL( backend._info._width , 127 );
+        BOOST_CHECK_EQUAL( backend._info._height, 64 );
+    }
+
+    {
+        fs::path my_path( bmp_filename );
+
+        typedef get_reader_backend< fs::path
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( my_path
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 127 );
+        BOOST_CHECK_EQUAL( backend._info._height, 64  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_image( bmp_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 127 );
+        BOOST_CHECK_EQUAL( img.height(), 64 );
+    }
+
+    {
+        ifstream in( bmp_filename.c_str(), ios::binary );
+
+        rgb8_image_t img;
+        read_image( in, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 127 );
+        BOOST_CHECK_EQUAL( img.height(), 64 );
+    }
+
+    {
+        FILE* file = fopen( bmp_filename.c_str(), "rb" );
+        
+        rgb8_image_t img;
+        read_image( file, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 127 );
+        BOOST_CHECK_EQUAL( img.height(), 64 );
+    }
+
+    {
+        fs::path my_path( bmp_filename );
+
+        rgb8_image_t img;
+        read_image( my_path, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 127 );
+        BOOST_CHECK_EQUAL( img.height(), 64 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_and_convert_image( bmp_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 127 );
+        BOOST_CHECK_EQUAL( img.height(), 64 );
+    }
+
+    {
+        ifstream in( bmp_filename.c_str(), ios::binary );
+
+        rgb8_image_t img;
+        read_and_convert_image( in, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 127 );
+        BOOST_CHECK_EQUAL( img.height(), 64 );
+    }
+
+    {
+        FILE* file = fopen( bmp_filename.c_str(), "rb" );
+        
+        rgb8_image_t img;
+        read_and_convert_image( file, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 127 );
+        BOOST_CHECK_EQUAL( img.height(), 64 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_view_test )
+{
+    {
+        rgb8_image_t img( 127, 64 );
+        read_view( bmp_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( bmp_filename.c_str(), ios::binary );
+
+        rgb8_image_t img( 127, 64 );
+        read_view( in, view( img ), tag_t() );
+    }
+
+    {
+        FILE* file = fopen( bmp_filename.c_str(), "rb" );
+        
+        rgb8_image_t img( 127, 64 );
+        read_view( file, view( img ), tag_t() );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 127, 64 );
+        read_and_convert_view( bmp_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( bmp_filename.c_str(), ios::binary );
+
+        rgb8_image_t img( 127, 64 );
+        read_and_convert_view( in, view( img ), tag_t() );
+    }
+
+    {
+        FILE* file = fopen( bmp_filename.c_str(), "rb" );
+        
+        rgb8_image_t img( 127, 64 );
+        read_and_convert_view( file
+                             , view( img )
+                             , tag_t()
+                             );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( write_view_test )
+{
+    {
+        string filename( bmp_out + "write_test_string.bmp" );
+
+        write_view( filename
+                  , create_mandel_view( 127, 64
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( bmp_out + "write_test_ofstream.bmp" );
+
+        ofstream out( filename.c_str(), ios::binary );
+
+        write_view( out
+                  , create_mandel_view( 127, 64
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( bmp_out + "write_test_file.bmp" );
+
+        FILE* file = fopen( filename.c_str(), "wb" );
+        
+        write_view( file
+                  , create_mandel_view( 127, 64
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( bmp_out + "write_test_info.bmp" );
+
+        image_write_info< tag_t > info;
+
+        FILE* file = fopen( filename.c_str(), "wb" );
+
+        write_view( file
+                  , create_mandel_view( 127, 64
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , info
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( stream_test )
+{
+    // 1. Read an image.
+    ifstream in( bmp_filename.c_str(), ios::binary );
+
+    rgb8_image_t img;
+    read_image( in, img, tag_t() );
+
+    // 2. Write image to in-memory buffer.
+    stringstream out_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    write_view( out_buffer, view( img ), tag_t() );
+
+    // 3. Copy in-memory buffer to another.
+    stringstream in_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    in_buffer << out_buffer.rdbuf();
+
+    // 4. Read in-memory buffer to gil image
+    rgb8_image_t dst;
+    read_image( in_buffer, dst, tag_t() );
+
+    // 5. Write out image.
+    string filename( bmp_out + "stream_test.bmp" );
+    ofstream out( filename.c_str(), ios_base::binary );
+    write_view( out, view( dst ), tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( stream_test_2 )
+{
+    filebuf in_buf;
+    if( !in_buf.open( bmp_filename.c_str(), ios::in | ios::binary ) )
+    {
+        BOOST_CHECK( false );
+    }
+
+    istream in( &in_buf );
+
+    rgb8_image_t img;
+    read_image( in, img, tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( subimage_test )
+{
+    run_subimage_test< rgb8_image_t, tag_t >( bmp_filename
+                                            , point_t(   0, 0 )
+                                            , point_t( 127, 1 )
+                                            );
+
+    run_subimage_test< rgb8_image_t, tag_t >( bmp_filename
+                                            , point_t( 39,  7 )
+                                            , point_t( 50, 50 )
+                                            );
+}
+
+BOOST_AUTO_TEST_CASE( dynamic_image_test )
+{
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , rgba8_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    read_image( bmp_filename.c_str()
+              , runtime_image
+              , tag_t()
+              );
+
+    write_view( bmp_out + "dynamic_image_test.bmp"
+              , view( runtime_image )
+              , tag_t()
+              );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/bmp_write_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/bmp_write_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,52 @@
+//#define BOOST_TEST_MODULE bmp_write_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/gil_all.hpp>
+
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+#include <boost/gil/extension/io_new/bmp_all.hpp>
+
+#include "cmp_view.hpp"
+#include "color_space_write_test.hpp"
+#include "mandel_view.hpp"
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost::gil;
+
+typedef bmp_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( bmp_test )
+
+BOOST_AUTO_TEST_CASE( write_test )
+{
+    // test writing all supported image types
+    {
+        write_view( bmp_out + "rgb8_test.bmp"
+                  , create_mandel_view( 200, 200
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        write_view( bmp_out + "rgba8_test.bmp"
+                  , create_mandel_view( 200, 200
+                                      , rgba8_pixel_t( 0,   0, 255, 0 )
+                                      , rgba8_pixel_t( 0, 255,   0, 0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( rgb_color_space_write_test )
+{
+    color_space_write_test< bmp_tag >( bmp_out + "rgb_color_space_test.bmp"
+                                     , bmp_out + "bgr_color_space_test.bmp"
+                                     );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/cmp_view.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/cmp_view.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,34 @@
+#ifndef BOOST_GIL_IO_UNIT_TEST_CMP_VIEW_HPP
+#define BOOST_GIL_IO_UNIT_TEST_CMP_VIEW_HPP
+
+#include <boost/gil/gil_all.hpp>
+
+template< typename View_1, typename View_2 >
+void cmp_view( const View_1& v1
+             , const View_2& v2
+             )
+{
+    if( v1.dimensions() != v2.dimensions() )
+    {
+        throw std::runtime_error( "Images are not equal." );
+    }
+
+    typename View_1::x_coord_t width  = v1.width();
+    typename View_1::y_coord_t height = v1.height();
+
+    for( typename View_1::y_coord_t y = 0; y < height; ++y )
+    {
+        const typename View_1::x_iterator src_it = v1.row_begin( y );
+        const typename View_2::x_iterator dst_it = v2.row_begin( y );
+
+        for( typename View_1::x_coord_t x = 0; x < width; ++x )
+        {
+            if( *src_it != *dst_it )
+            {
+                throw std::runtime_error( "Images are not equal." );
+            }
+        }
+    }
+}
+
+#endif // BOOST_GIL_IO_UNIT_TEST_CMP_VIEW_HPP
Index: boost-1.52.0/src/libs/gil/io_new/test/color_space_write_test.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/color_space_write_test.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,33 @@
+#ifndef BOOST_GIL_IO_UNIT_TEST_COLOR_SPACE_WRITE_TEST_HPP
+#define BOOST_GIL_IO_UNIT_TEST_COLOR_SPACE_WRITE_TEST_HPP
+
+#include <string>
+
+#include <boost/gil/gil_all.hpp>
+
+#include "cmp_view.hpp"
+
+template< typename Tag >
+void color_space_write_test( const std::string& file_name_1
+                           , const std::string& file_name_2
+                           )
+{
+    rgb8_image_t rgb( 320, 200 );
+    bgr8_image_t bgr( 320, 200 );
+
+    fill_pixels( view(rgb), rgb8_pixel_t(  0, 0, 255 ));
+    fill_pixels( view(bgr), bgr8_pixel_t(255, 0,   0 ));
+
+    write_view( file_name_1, view( rgb ), Tag() );
+    write_view( file_name_2, view( bgr ), Tag() );
+
+    rgb8_image_t rgb_1;
+    rgb8_image_t rgb_2;
+
+    read_image( file_name_1, rgb_1, Tag() );
+    read_image( file_name_2, rgb_2, Tag() );
+
+    cmp_view( view( rgb_1 ), view( rgb_2 ));
+}
+
+#endif // BOOST_GIL_IO_UNIT_TEST_COLOR_SPACE_WRITE_TEST_HPP
Index: boost-1.52.0/src/libs/gil/io_new/test/jpeg_old_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/jpeg_old_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,96 @@
+//#define BOOST_TEST_MODULE jpeg_old_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/jpeg_io_old.hpp>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+BOOST_AUTO_TEST_SUITE( jpeg_test )
+
+BOOST_AUTO_TEST_CASE( old_read_dimensions_test )
+{
+    {
+        point2< ptrdiff_t > dim = jpeg_read_dimensions( jpeg_filename );
+
+        BOOST_CHECK_EQUAL( dim.x, 136 );
+        BOOST_CHECK_EQUAL( dim.y, 98  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_image_test )
+{
+    {
+        rgb8_image_t img;
+        jpeg_read_image( jpeg_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 136 );
+        BOOST_CHECK_EQUAL( img.height(), 98 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        jpeg_read_and_convert_image( jpeg_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 136 );
+        BOOST_CHECK_EQUAL( img.height(), 98 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_view_test )
+{
+    {
+        rgb8_image_t img( 136, 98 );
+        jpeg_read_view( jpeg_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 136, 98 );
+        jpeg_read_and_convert_view( jpeg_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_write_view_test )
+{
+    {
+        jpeg_write_view( jpeg_out + "old_write_test.jpg"
+                        , create_mandel_view( 320, 240
+                                            , rgb8_pixel_t( 0,   0, 255 )
+                                            , rgb8_pixel_t( 0, 255,   0 )
+                                            )
+                        );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_dynamic_image_test )
+{
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , rgba8_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    jpeg_read_image( jpeg_filename.c_str()
+                   , runtime_image
+                   );
+
+    jpeg_write_view( jpeg_out + "old_dynamic_image_test.jpg"
+                  , view( runtime_image )
+                  );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/jpeg_read_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/jpeg_read_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,122 @@
+//#define BOOST_TEST_MODULE jpeg_read_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/jpeg_all.hpp>
+
+#include "paths.hpp"
+#include "scanline_read_test.hpp"
+
+using namespace std;
+using namespace boost::gil;
+
+typedef jpeg_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( jpeg_test )
+
+BOOST_AUTO_TEST_CASE( read_header_test )
+{
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( jpeg_filename
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width         , 136u );
+        BOOST_CHECK_EQUAL( backend._info._height        , 98u  );
+
+        BOOST_CHECK_EQUAL( backend._info._num_components, 3         );
+        BOOST_CHECK_EQUAL( backend._info._color_space   , JCS_YCbCr );
+
+        BOOST_CHECK_EQUAL( backend._info._data_precision, 8         );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_pixel_density_test )
+{
+    typedef get_reader_backend< const std::string
+                              , tag_t
+                              >::type backend_t;
+
+    backend_t backend = read_image_info( jpeg_in + "EddDawson/36dpi.jpg"
+                                       , tag_t()
+                                       );
+                                           
+    rgb8_image_t img;
+    read_image( jpeg_in + "EddDawson/36dpi.jpg", img, jpeg_tag() );
+
+    image_write_info< jpeg_tag > write_settings;
+    write_settings.set_pixel_dimensions( backend._info._width
+                                       , backend._info._height
+                                       , backend._info._pixel_width_mm
+                                       , backend._info._pixel_height_mm
+                                       );
+
+    stringstream in_memory( ios_base::in | ios_base::out | ios_base::binary );
+    write_view( in_memory, view( img ), write_settings );
+
+    typedef get_reader_backend< stringstream
+                              , tag_t
+                              >::type backend2_t;
+
+    backend2_t backend2 = read_image_info( in_memory
+                                         , tag_t()
+                                         );
+
+    // Because of rounding the two results differ slightly.
+    if(  std::abs( backend._info._pixel_width_mm  - backend2._info._pixel_width_mm  ) > 10.0
+      || std::abs( backend._info._pixel_height_mm - backend2._info._pixel_height_mm ) > 10.0
+      )
+    {
+        BOOST_CHECK_EQUAL( 0, 1 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_reference_images_test )
+{
+    {
+        typedef rgb8_image_t image_t;
+        image_t img;
+
+        read_image( jpeg_filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( jpeg_out + "rgb8_test.jpg"
+                  , view( img )
+                  , tag_t()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( dct_method_read_test )
+{
+    {
+        typedef rgb8_image_t image_t;
+        image_t img;
+
+        image_read_settings< jpeg_tag > settings;
+        settings._dct_method = jpeg_dct_method::fast;
+
+        read_image( jpeg_filename
+                  , img
+                  , settings
+                  );
+
+        write_view( jpeg_out + "fast_dct_read_test.jpg"
+                  , view( img )
+                  , tag_t()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_reference_images_image_iterator_test )
+{
+    test_scanline_reader< rgb8_image_t, jpeg_tag >( jpeg_filename.c_str() );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/jpeg_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/jpeg_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,324 @@
+//#define BOOST_TEST_MODULE jpeg_test_module
+#include <boost/test/unit_test.hpp>
+#define BOOST_FILESYSTEM_VERSION 3
+#include <boost/filesystem/path.hpp>
+
+#include <fstream>
+
+#include <boost/gil/gil_all.hpp>
+
+#define BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+#include <boost/gil/extension/io_new/jpeg_all.hpp>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+#include "subimage_test.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+using namespace filesystem;
+
+typedef jpeg_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( jpeg_test )
+
+BOOST_AUTO_TEST_CASE( read_image_info_test )
+{
+
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( jpeg_filename
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 136u );
+        BOOST_CHECK_EQUAL( backend._info._height, 98u  );
+    }
+
+    {
+        ifstream in( jpeg_filename.c_str(), ios::binary );
+
+        typedef get_reader_backend< ifstream
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( in
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 136u );
+        BOOST_CHECK_EQUAL( backend._info._height, 98u  );
+    }
+
+    {
+        FILE* file = fopen( jpeg_filename.c_str(), "rb" );
+
+        typedef get_reader_backend< FILE*
+                                  , tag_t
+                                  >::type backend_t;
+        
+        backend_t backend = boost::gil::read_image_info( file
+                                                       , tag_t()
+                                                       );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 136u );
+        BOOST_CHECK_EQUAL( backend._info._height, 98u  );
+    }
+
+    {
+        typedef get_reader_backend< path
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = boost::gil::read_image_info( path( jpeg_filename )
+                                                       , tag_t()
+                                                       );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 136u );
+        BOOST_CHECK_EQUAL( backend._info._height, 98u  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_image( jpeg_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 136u );
+        BOOST_CHECK_EQUAL( img.height(), 98u );
+    }
+
+    {
+        ifstream in( jpeg_filename.c_str(), ios::binary );
+
+        rgb8_image_t img;
+        read_image( in, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 136u );
+        BOOST_CHECK_EQUAL( img.height(), 98u );
+    }
+
+    {
+        FILE* file = fopen( jpeg_filename.c_str(), "rb" );
+        
+        rgb8_image_t img;
+        read_image( file, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 136u );
+        BOOST_CHECK_EQUAL( img.height(), 98u );
+    }
+
+    {
+        rgb8_image_t img;
+
+        image_read_settings< jpeg_tag > settings( point_t(  0,  0 )
+                                                , point_t( 10, 10 )
+                                                , jpeg_dct_method::slow
+                                                );
+
+        read_image( jpeg_filename, img, settings );
+
+        BOOST_CHECK_EQUAL( img.width() , 10u );
+        BOOST_CHECK_EQUAL( img.height(), 10u );
+    }
+
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_and_convert_image( jpeg_filename, img, tag_t() );
+    }
+
+    {
+        ifstream in( jpeg_filename.c_str(), ios::binary );
+
+        rgb8_image_t img;
+        read_and_convert_image( in, img, tag_t() );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_view_test )
+{
+    {
+        rgb8_image_t img( 136, 98 );
+        read_view( jpeg_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( jpeg_filename.c_str(), ios::binary );
+
+        rgb8_image_t img( 136, 98 );
+        read_view( in, view( img ), tag_t() );
+    }
+
+    {
+        FILE* file = fopen( jpeg_filename.c_str(), "rb" );
+        
+        rgb8_image_t img( 136, 98 );
+        read_view( file, view( img ), tag_t() );
+    }
+}
+BOOST_AUTO_TEST_CASE( read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 136, 98 );
+        read_and_convert_view( jpeg_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( jpeg_filename.c_str(), ios::binary );
+
+        rgb8_image_t img( 136, 98 );
+        read_and_convert_view( in, view( img ), tag_t() );
+    }
+
+    {
+        FILE* file = fopen( jpeg_filename.c_str(), "rb" );
+
+        rgb8_image_t img( 136, 98 );
+        read_and_convert_view( file
+                             , view( img )
+                             , tag_t()
+                             );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( write_view_test )
+{
+    {
+        string filename( jpeg_out + "write_test_string.jpg" );
+
+        write_view( filename
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( jpeg_out + "write_test_ofstream.jpg" );
+        ofstream out( filename.c_str(), ios::binary );
+
+        write_view( out
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( jpeg_out + "write_test_file.jpg" );
+
+        FILE* file = fopen( filename.c_str(), "wb" );
+        
+        write_view( file
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( jpeg_out + "write_test_info.jpg" );
+        FILE* file = fopen( filename.c_str(), "wb" );
+
+        image_write_info< jpeg_tag > info;
+        write_view( file
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , info
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( stream_test )
+{
+    // 1. Read an image.
+    ifstream in( jpeg_filename.c_str(), ios::binary );
+
+    rgb8_image_t img;
+    read_image( in, img, tag_t() );
+
+    // 2. Write image to in-memory buffer.
+    stringstream out_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    write_view( out_buffer, view( img ), tag_t() );
+
+    // 3. Copy in-memory buffer to another.
+    stringstream in_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    in_buffer << out_buffer.rdbuf();
+
+    // 4. Read in-memory buffer to gil image
+    rgb8_image_t dst;
+    read_image( in_buffer, dst, tag_t() );
+
+    // 5. Write out image.
+    string filename( jpeg_out + "stream_test.jpg" );
+    ofstream out( filename.c_str(), ios_base::binary );
+    write_view( out, view( dst ), tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( stream_test_2 )
+{
+    filebuf in_buf;
+    if( !in_buf.open( jpeg_filename.c_str(), ios::in | ios::binary ) )
+    {
+        BOOST_CHECK( false );
+    }
+
+    istream in( &in_buf );
+
+    rgb8_image_t img;
+    read_image( in, img, tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( subimage_test )
+{
+    run_subimage_test< rgb8_image_t, tag_t >( jpeg_filename
+                                            , point_t(  0,  0 )
+                                            , point_t( 50, 50 )
+                                            );
+
+    run_subimage_test< rgb8_image_t, tag_t >( jpeg_filename
+                                            , point_t( 43, 24 )
+                                            , point_t( 50, 50 )
+                                            );
+}
+
+BOOST_AUTO_TEST_CASE( dynamic_image_test )
+{
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , rgba8_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    read_image( jpeg_filename.c_str()
+              , runtime_image
+              , jpeg_tag()
+              );
+
+    write_view( jpeg_out + "old_dynamic_image_test.jpg"
+              , view( runtime_image )
+              , jpeg_tag()
+              );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/jpeg_write_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/jpeg_write_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,81 @@
+//#define BOOST_TEST_MODULE jpeg_write_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/jpeg_all.hpp>
+
+#include "color_space_write_test.hpp"
+#include "mandel_view.hpp"
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost::gil;
+
+typedef jpeg_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( jpeg_test )
+
+BOOST_AUTO_TEST_CASE( write_test )
+{
+    // test writing all supported image types
+
+    {
+        write_view( jpeg_out + "gray8_test.jpg"
+                  , create_mandel_view( 200, 200
+                                      , gray8_pixel_t( 0   )
+                                      , gray8_pixel_t( 255 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        write_view( jpeg_out + "rgb8_test.jpg"
+                  , create_mandel_view( 200, 200
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        write_view( jpeg_out + "cmyk8_test.jpg"
+                  , create_mandel_view( 200, 200
+                                      , cmyk8_pixel_t( 0,   0, 255, 127 )
+                                      , cmyk8_pixel_t( 0, 255,   0, 127 )
+                                      )
+                  , tag_t()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( dct_method_write_test )
+{
+    {
+        typedef rgb8_image_t image_t;
+        image_t img;
+
+        read_image( jpeg_filename
+                  , img
+                  , tag_t()
+                  );
+
+        image_write_info< jpeg_tag > info;
+        info._dct_method = jpeg_dct_method::fast;
+
+        write_view( jpeg_out + "fast_dct_write_test.jpg"
+                  , view( img )
+                  , info
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( rgb_color_space_write_test )
+{
+    color_space_write_test< jpeg_tag >( jpeg_out + "rgb_color_space_test.jpg"
+                                      , jpeg_out + "bgr_color_space_test.jpg"
+                                      );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/make.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/make.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,227 @@
+#include <boost/test/unit_test.hpp>
+
+#define BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+#include <fstream>
+
+#define BOOST_FILESYSTEM_VERSION 3
+#include <boost/filesystem/convenience.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/bmp_all.hpp>
+
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost::gil;
+namespace fs = boost::filesystem;
+
+BOOST_AUTO_TEST_SUITE( make_test )
+
+BOOST_AUTO_TEST_CASE( make_reader_backend_test )
+{
+    //{
+    //    BOOST_STATIC_ASSERT(( is_same< int, int >::value ));
+    //    BOOST_STATIC_ASSERT(( is_same< detail::is_read_device< bmp_tag, FILE* >::type, boost::mpl::true_ >::value ));
+    //}
+
+    //{
+    //    typedef get_reader< const char*
+    //                      , bmp_tag
+    //                      , detail::read_and_no_convert
+    //                      >::type reader_t;
+
+    //    BOOST_STATIC_ASSERT(( is_same< detail::is_reader< reader_t >::type, boost::mpl::true_ >::value ));
+    //}
+
+    {
+        auto backend_char   = make_reader_backend( bmp_filename.c_str(), bmp_tag() );
+        auto backend_string = make_reader_backend( bmp_filename, bmp_tag() );
+
+        FILE* file = fopen( bmp_filename.c_str(), "rb" );
+        auto backend_file = make_reader_backend( file, bmp_tag() );
+
+        ifstream in( bmp_filename.c_str(), ios::binary );
+        auto backend_ifstream = make_reader_backend( in, bmp_tag() );
+
+        fs::path my_path( bmp_filename );
+        auto backend_wstring = make_reader_backend( my_path.wstring(), bmp_tag() );
+        auto backend_path    = make_reader_backend( my_path          , bmp_tag() );
+    }
+
+    {
+        auto backend_char   = make_reader_backend( bmp_filename.c_str(), image_read_settings<bmp_tag>() );
+        auto backend_string = make_reader_backend( bmp_filename, image_read_settings<bmp_tag>() );
+
+        FILE* file = fopen( bmp_filename.c_str(), "rb" );
+        auto backend_file = make_reader_backend( file, image_read_settings<bmp_tag>() );
+
+        ifstream in( bmp_filename.c_str(), ios::binary );
+        auto backend_ifstream = make_reader_backend( in, image_read_settings<bmp_tag>() );
+
+        fs::path my_path( bmp_filename );
+        auto backend_wstring = make_reader_backend( my_path.wstring(), image_read_settings<bmp_tag>() );
+        auto backend_path    = make_reader_backend( my_path          , image_read_settings<bmp_tag>() );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( make_reader_test )
+{
+    {
+        auto reader_char   = make_reader( bmp_filename.c_str(), bmp_tag(), detail::read_and_no_convert() );
+        auto reader_string = make_reader( bmp_filename, bmp_tag(), detail::read_and_no_convert() );
+
+        FILE* file = fopen( bmp_filename.c_str(), "rb" );
+        auto reader_file = make_reader( file, bmp_tag(), detail::read_and_no_convert() );
+
+        ifstream in( bmp_filename.c_str(), ios::binary );
+        auto reader_ifstream = make_reader( in, bmp_tag(), detail::read_and_no_convert() );
+
+        fs::path my_path( bmp_filename );
+        auto reader_wstring = make_reader( my_path.wstring(), bmp_tag(), detail::read_and_no_convert() );
+        auto reader_path    = make_reader( my_path          , bmp_tag(), detail::read_and_no_convert() );
+    }
+
+    {
+        auto reader_char   = make_reader( bmp_filename.c_str(), image_read_settings< bmp_tag >(), detail::read_and_no_convert() );
+        auto reader_string = make_reader( bmp_filename, image_read_settings< bmp_tag >(), detail::read_and_no_convert() );
+
+        FILE* file = fopen( bmp_filename.c_str(), "rb" );
+        auto reader_file = make_reader( file, image_read_settings< bmp_tag >(), detail::read_and_no_convert() );
+
+        ifstream in( bmp_filename.c_str(), ios::binary );
+        auto reader_ifstream = make_reader( in, image_read_settings< bmp_tag >(), detail::read_and_no_convert() );
+
+        fs::path my_path( bmp_filename );
+        auto reader_wstring = make_reader( my_path.wstring(), image_read_settings< bmp_tag >(), detail::read_and_no_convert() );
+        auto reader_path    = make_reader( my_path          , image_read_settings< bmp_tag >(), detail::read_and_no_convert() );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( make_dynamic_image_reader_test )
+{
+    {
+        auto reader_char   = make_dynamic_image_reader( bmp_filename.c_str(), bmp_tag() );
+        auto reader_string = make_dynamic_image_reader( bmp_filename, bmp_tag() );
+
+        FILE* file = fopen( bmp_filename.c_str(), "rb" );
+        auto reader_file = make_dynamic_image_reader( file, bmp_tag() );
+
+        ifstream in( bmp_filename.c_str(), ios::binary );
+        auto reader_ifstream = make_dynamic_image_reader( in, bmp_tag() );
+
+        fs::path my_path( bmp_filename );
+        auto reader_wstring = make_dynamic_image_reader( my_path.wstring(), bmp_tag() );
+        auto reader_path    = make_dynamic_image_reader( my_path          , bmp_tag() );
+    }
+
+    {
+        auto reader_char   = make_dynamic_image_reader( bmp_filename.c_str(), image_read_settings< bmp_tag >() );
+        auto reader_string = make_dynamic_image_reader( bmp_filename, image_read_settings< bmp_tag >() );
+
+        FILE* file = fopen( bmp_filename.c_str(), "rb" );
+        auto reader_file = make_dynamic_image_reader( file, image_read_settings< bmp_tag >() );
+
+        ifstream in( bmp_filename.c_str(), ios::binary );
+        auto reader_ifstream = make_dynamic_image_reader( in, image_read_settings< bmp_tag >() );
+
+        fs::path my_path( bmp_filename );
+        auto reader_wstring = make_dynamic_image_reader( my_path.wstring(), image_read_settings< bmp_tag >() );
+        auto reader_path    = make_dynamic_image_reader( my_path          , image_read_settings< bmp_tag >() );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( make_writer_test )
+{
+
+    {
+        //const char file_name[] = "c:\\chhenning\\rgb.bmp";
+
+        //typedef get_write_device< const char*
+        //                        , bmp_tag
+        //                        >::type write_device_t;
+        //
+        //write_device_t f( file_name, detail::file_stream_device< bmp_tag >::write_tag() );
+
+        //typedef get_writer< const char*
+        //                  , bmp_tag
+        //                  >::type writer_t;
+
+        //writer_t w( bmp_filename.c_str(), image_write_info< bmp_tag >() );
+
+        //BOOST_STATIC_ASSERT(( is_same< detail::is_writer< writer_t >::type, boost::mpl::true_ >::value ));
+    }
+
+    {
+        typedef get_writer< const char*
+                          , bmp_tag
+                          >::type writer_t;
+
+        BOOST_STATIC_ASSERT(( is_same< detail::is_writer< writer_t >::type, boost::mpl::true_ >::value ));
+    }
+
+    {
+        auto writer_char   = make_writer( (bmp_out + string( "make_test.bmp")).c_str(), bmp_tag() );
+        auto writer_string = make_writer( bmp_out  + "make_test.bmp", bmp_tag() );
+
+        FILE* file = fopen( (bmp_out + string( "make_test.bmp")).c_str(), "wb" );
+        auto writer_file = make_writer( file, bmp_tag() );
+
+        ofstream out( bmp_out  + "make_test.bmp", ios::binary );
+        auto writer_ofstream = make_writer( out, bmp_tag() );
+
+        fs::path my_path( bmp_out  + "make_test.bmp" );
+        auto writer_wstring = make_writer( my_path.wstring(), bmp_tag() );
+        auto writer_path    = make_writer( my_path          , bmp_tag() );
+    }
+
+    {
+        auto writer_char   = make_writer( (bmp_out + string( "make_test.bmp")).c_str(), image_write_info< bmp_tag >() );
+        auto writer_string = make_writer( bmp_out  + "make_test.bmp", image_write_info< bmp_tag >() );
+
+        FILE* file = fopen( (bmp_out + string( "make_test.bmp")).c_str(), "wb" );
+        auto writer_file = make_writer( file, image_write_info< bmp_tag >() );
+
+        ofstream out( bmp_out  + "make_test.bmp", ios::binary );
+        auto writer_ofstream = make_writer( out, image_write_info< bmp_tag >() );
+
+        fs::path my_path( bmp_out  + "make_test.bmp" );
+        auto writer_wstring = make_writer( my_path.wstring(), image_write_info< bmp_tag >() );
+        auto writer_path    = make_writer( my_path          , image_write_info< bmp_tag >() );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( make_dynamic_image_writer_test )
+{
+    {
+        auto writer_char   = make_dynamic_image_writer( (bmp_out + string( "make_test.bmp")).c_str(), bmp_tag() );
+        auto writer_string = make_dynamic_image_writer( bmp_out  + "make_test.bmp", bmp_tag() );
+
+        FILE* file = fopen( (bmp_out + string( "make_test.bmp")).c_str(), "wb" );
+        auto writer_file = make_dynamic_image_writer( file, bmp_tag() );
+
+        ofstream out( bmp_out  + "make_test.bmp", ios::binary );
+        auto writer_ofstream = make_dynamic_image_writer( out, bmp_tag() );
+
+        fs::path my_path( bmp_out  + "make_test.bmp" );
+        auto writer_wstring = make_dynamic_image_writer( my_path.wstring(), bmp_tag() );
+        auto writer_path    = make_dynamic_image_writer( my_path          , bmp_tag() );
+    }
+
+    {
+        auto writer_char   = make_dynamic_image_writer( (bmp_out + string( "make_test.bmp")).c_str(), image_write_info< bmp_tag >() );
+        auto writer_string = make_dynamic_image_writer( bmp_out  + "make_test.bmp", image_write_info< bmp_tag >() );
+
+        FILE* file = fopen( (bmp_out + string( "make_test.bmp")).c_str(), "wb" );
+        auto writer_file = make_dynamic_image_writer( file, image_write_info< bmp_tag >() );
+
+        ofstream out( bmp_out  + "make_test.bmp", ios::binary );
+        auto writer_ofstream = make_dynamic_image_writer( out, image_write_info< bmp_tag >() );
+
+        fs::path my_path( bmp_out  + "make_test.bmp" );
+        auto writer_wstring = make_dynamic_image_writer( my_path.wstring(), image_write_info< bmp_tag >() );
+        auto writer_path    = make_dynamic_image_writer( my_path          , image_write_info< bmp_tag >() );
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/mandel_view.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/mandel_view.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,90 @@
+#ifndef BOOST_GIL_IO_UNIT_TEST_MANDEL_HPP
+#define BOOST_GIL_IO_UNIT_TEST_MANDEL_HPP
+
+#include <boost/gil/gil_all.hpp>
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+// Models a Unary Function
+template <typename P>   // Models PixelValueConcept
+struct mandelbrot_fn {
+    typedef point2<ptrdiff_t>    point_t;
+
+    typedef mandelbrot_fn        const_t;
+    typedef P                    value_type;
+    typedef value_type           reference;
+    typedef value_type           const_reference;
+    typedef point_t              argument_type;
+    typedef reference            result_type;
+    BOOST_STATIC_CONSTANT(bool, is_mutable=false);
+
+    value_type                    _in_color,_out_color;
+    point_t                       _img_size;
+    static const int MAX_ITER=100;        // max number of iterations
+
+    mandelbrot_fn() {}
+    mandelbrot_fn(const point_t& sz, const value_type& in_color, const value_type& out_color) : _in_color(in_color), _out_color(out_color), _img_size(sz) {}
+
+    ptrdiff_t width()  { return _img_size.x; }
+    ptrdiff_t height() { return _img_size.y; }
+
+    result_type operator()(const point_t& p) const {
+        // normalize the coords to (-2..1, -1.5..1.5)
+        // (actually make y -1.0..2 so it is asymmetric, so we can verify some view factory methods)
+        double t=get_num_iter(point2<double>(p.x/(double)_img_size.x*3-2, p.y/(double)_img_size.y*3-1.0f));//1.5f));
+        t=pow(t,0.2);
+
+        value_type ret;
+        for (int k=0; k<num_channels<P>::value; ++k)
+            ret[k]=(typename channel_type<P>::type)(_in_color[k]*t + _out_color[k]*(1-t));
+        return ret;
+    }
+
+private:
+    double get_num_iter(const point2<double>& p) const {
+        point2<double> Z(0,0);
+        for (int i=0; i<MAX_ITER; ++i) {
+            Z = point2<double>(Z.x*Z.x - Z.y*Z.y + p.x, 2*Z.x*Z.y + p.y);
+            if (Z.x*Z.x + Z.y*Z.y > 4)
+                return i/(double)MAX_ITER;
+        }
+        return 0;
+    }
+};
+
+template< typename Pixel >
+struct mandel_view
+{
+    typedef mandelbrot_fn< Pixel > deref_t;
+    typedef virtual_2d_locator<deref_t,false> locator_t;
+    typedef image_view<locator_t> my_virt_view_t;
+
+    typedef my_virt_view_t type;
+};
+
+template< typename Pixel >
+typename mandel_view< Pixel >::type create_mandel_view( unsigned int width
+                                                      , unsigned int height
+                                                      , const Pixel& in
+                                                      , const Pixel& out
+                                                      )
+{
+    typedef typename mandel_view< Pixel >::type      view_t;
+    typedef typename mandel_view< Pixel >::deref_t   deref_t;
+    typedef typename mandel_view< Pixel >::locator_t locator_t;
+
+    point_t dims( width, height );
+    return view_t( dims
+                 , locator_t( point_t( 0, 0 )
+                            , point_t( 1, 1 )
+                            , deref_t( dims
+                                     , in
+                                     , out
+                                     )
+                            )
+                 );
+}
+
+#endif // BOOST_GIL_IO_UNIT_TEST_MANDEL_HPP
Index: boost-1.52.0/src/libs/gil/io_new/test/paths.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/paths.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,36 @@
+#ifndef BOOST_GIL_IO_UNIT_TEST_PATHS_HPP
+#define BOOST_GIL_IO_UNIT_TEST_PATHS_HPP
+
+static const std::string base = "../../../";
+
+static const std::string bmp_in  = base + "test_images/bmp/";
+static const std::string bmp_out = base + "output/bmp/";
+
+static const std::string jpeg_in  = base + "test_images/jpg/";
+static const std::string jpeg_out = base + "output/jpeg/";
+
+static const std::string png_base_in = base + "test_images/png/";
+static const std::string png_in      = png_base_in + "PngSuite/";
+static const std::string png_out     = base + "output/png/";
+
+static const std::string pnm_in  = base + "test_images/pnm/";
+static const std::string pnm_out = base + "output/pnm/";
+
+static const std::string raw_in  = base + "test_images/raw/";
+
+static const std::string targa_in  = base + "test_images/targa/";
+static const std::string targa_out = base + "output/targa/";
+
+static const std::string tiff_in    = base + "test_images/tiff/";
+static const std::string tiff_out   = base + "output/tiff/";
+static const std::string tiff_in_GM = tiff_in + "GraphicsMagick/tiff-sample-images/";
+
+static const std::string bmp_filename  ( bmp_in    + "rgb.bmp"                            );
+static const std::string jpeg_filename ( jpeg_in   + "found online/test.jpg"              );
+static const std::string png_filename  ( base      + "test_images/png/wikipedia/test.png" );
+static const std::string pnm_filename  ( pnm_in    + "rgb.pnm"                            );
+static const std::string raw_filename  ( raw_in    + "RAW_CANON_D30_SRGB.CRW"             );
+static const std::string targa_filename( targa_in  + "24BPP_compressed.tga"               );
+static const std::string tiff_filename ( tiff_in   + "test.tif"                           );
+
+#endif // BOOST_GIL_IO_UNIT_TEST_PATHS_HPP
Index: boost-1.52.0/src/libs/gil/io_new/test/png_file_format_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/png_file_format_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,66 @@
+//#define BOOST_TEST_MODULE png_file_format_test_module
+#include <boost/test/unit_test.hpp>
+
+#define BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+#define BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+#define BOOST_FILESYSTEM_VERSION 3
+#include <boost/filesystem/convenience.hpp>
+
+#include <boost/gil/extension/io_new/png_all.hpp>
+
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost::gil;
+namespace fs = boost::filesystem;
+
+typedef png_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( png_test )
+
+// Test will loop through the "in" folder to read and convert
+// the png's to rgb8_image_t's. Which then will be written in
+// the "out" folder.
+// 
+// The file name structure is as followed:
+// 
+// g04i2c08.png
+// || |||+---- bit-depth
+// || ||+----- color-type (descriptive)
+// || |+------ color-type (numerical)
+// || +------- interlaced or non-interlaced
+// |+--------- parameter of test (in this case gamma-value)
+// +---------- test feature (in this case gamma)
+
+BOOST_AUTO_TEST_CASE( file_format_test )
+{
+   string in ( png_in + "PngSuite\\" );
+
+   fs::path in_path = fs::system_complete( fs::path( in, fs::native ) );
+
+   if ( fs::is_directory( in_path ) )
+   {
+      fs::directory_iterator end_iter;
+      for( fs::directory_iterator dir_itr( in_path )
+         ; dir_itr != end_iter
+         ; ++dir_itr
+         )
+      {
+         if ( fs::is_regular( dir_itr->status() ) 
+            && ( fs::extension( dir_itr->path() ) == ".PNG" ))
+         {
+            rgb8_image_t img;
+            string filename = in + dir_itr->path().leaf().string();
+            read_and_convert_image( filename, img, tag_t() );
+
+            write_view( png_out + fs::basename( dir_itr->path() ) + ".png"
+                      , view( img )
+                      , png_tag()
+                      );
+         }
+      }
+   }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/png_old_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/png_old_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,96 @@
+//#define BOOST_TEST_MODULE png_old_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/png_io_old.hpp>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+BOOST_AUTO_TEST_SUITE( png_test )
+
+BOOST_AUTO_TEST_CASE( old_read_dimensions_test )
+{
+    {
+        point2< ptrdiff_t > dim = png_read_dimensions( png_filename );
+
+        BOOST_CHECK_EQUAL( dim.x, 320 );
+        BOOST_CHECK_EQUAL( dim.y, 240 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_image_test )
+{
+    {
+        rgba8_image_t img;
+        png_read_image( png_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 320 );
+        BOOST_CHECK_EQUAL( img.height(), 240 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        png_read_and_convert_image( png_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 320 );
+        BOOST_CHECK_EQUAL( img.height(), 240 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_view_test )
+{
+    {
+        rgba8_image_t img( 320, 240 );
+        png_read_view( png_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 320, 240 );
+        png_read_and_convert_view( png_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_write_view_test )
+{
+    {
+        png_write_view( png_out + "old_write_view_test.png"
+                      , create_mandel_view( 320, 240
+                                          , rgb8_pixel_t( 0,   0, 255 )
+                                          , rgb8_pixel_t( 0, 255,   0 )
+                                          )
+                      );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_dynamic_image_test )
+{
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , rgba8_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    png_read_image( png_filename.c_str()
+                  , runtime_image
+                  );
+
+    png_write_view( png_out + "old_dynamic_image_test.png"
+                  , view( runtime_image )
+                  );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/png_read_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/png_read_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,497 @@
+//#define BOOST_TEST_MODULE png_read_test_module
+#include <boost/test/unit_test.hpp>
+
+#define BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+#define BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+#include <boost/cstdint.hpp>
+
+#define BOOST_FILESYSTEM_VERSION 3
+#include <boost/filesystem/convenience.hpp>
+
+#include <boost/gil/extension/io_new/png_all.hpp>
+
+#include <iostream>
+
+#include "paths.hpp"
+#include "scanline_read_test.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+using namespace boost::gil::detail;
+namespace fs = boost::filesystem;
+
+typedef png_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( png_test )
+
+typedef pixel< uint8_t, gray_alpha_layout_t > gray_alpha8_pixel_t;
+typedef image< gray_alpha8_pixel_t, false   > gray_alpha8_image_t;
+
+typedef pixel< uint16_t, gray_alpha_layout_t > gray_alpha16_pixel_t;
+typedef image< gray_alpha16_pixel_t, false   > gray_alpha16_image_t;
+
+template< typename Image >
+void test_file( string filename )
+{
+    Image src, dst;
+
+    image_read_settings< png_tag > settings;
+    settings._read_file_gamma        = true;
+    settings._read_transparency_data = true;
+
+
+    typedef get_reader_backend< const std::string
+                              , tag_t
+                              >::type backend_t;
+
+    backend_t backend = read_image_info( png_in + filename
+                                        , settings
+                                        );
+
+    read_image( png_in + filename
+              , src
+              , settings
+              );
+
+    image_write_info< png_tag > write_info;
+    write_info._file_gamma = backend._info._file_gamma;
+
+    write_view( png_out + filename
+              , view( src )
+              , write_info
+              );
+
+    read_image( png_out + filename
+              , dst
+              , settings
+              );
+
+
+    BOOST_CHECK( equal_pixels( const_view( src )
+                             , const_view( dst )
+                             )
+               );
+}
+
+template< typename Image >
+void test_png_scanline_reader( string filename )
+{
+    test_scanline_reader<Image, png_tag>( string( png_in + filename ).c_str() );
+}
+
+BOOST_AUTO_TEST_CASE( read_header_test )
+{
+    typedef get_reader_backend< const std::string
+                              , tag_t
+                              >::type backend_t;
+
+    backend_t backend = read_image_info( png_filename
+                                       , tag_t()
+                                       );
+
+    BOOST_CHECK_EQUAL( backend._info._width , 320u );
+    BOOST_CHECK_EQUAL( backend._info._height, 240u );
+
+    BOOST_CHECK_EQUAL( backend._info._num_channels, 4                   );
+    BOOST_CHECK_EQUAL( backend._info._bit_depth   , 8                   );
+    BOOST_CHECK_EQUAL( backend._info._color_type  , PNG_COLOR_TYPE_RGBA );
+
+    BOOST_CHECK_EQUAL( backend._info._interlace_method  , PNG_INTERLACE_NONE        );
+    BOOST_CHECK_EQUAL( backend._info._compression_method, PNG_COMPRESSION_TYPE_BASE );
+    BOOST_CHECK_EQUAL( backend._info._filter_method     , PNG_FILTER_TYPE_BASE      );
+
+
+    BOOST_CHECK_EQUAL( backend._info._file_gamma, 1 );
+}
+
+BOOST_AUTO_TEST_CASE( read_pixel_per_meter )
+{
+    image_read_settings< png_tag > settings;
+    settings.set_read_members_true();
+
+    typedef get_reader_backend< const std::string
+                              , tag_t
+                              >::type backend_t;
+
+    backend_t backend = read_image_info( png_base_in + "EddDawson/36dpi.png"
+                                       , settings
+                                       );
+
+    BOOST_CHECK_EQUAL( backend._info._pixels_per_meter, 1417 );
+
+}
+
+BOOST_AUTO_TEST_CASE( BASIc_format_test )
+{
+    // Basic format test files (non-interlaced)
+
+    // BASN0g01    -   black & white
+    test_file< gray1_image_t >( "BASN0G01.PNG" );
+    test_png_scanline_reader< gray1_image_t >( "BASN0G01.PNG" );
+
+    // BASN0g02    -   2 bit (4 level) grayscale
+    test_file< gray2_image_t >( "BASN0G02.PNG" );
+    test_png_scanline_reader< gray2_image_t >( "BASN0G02.PNG" );
+
+    // BASN0g04    -   4 bit (16 level) grayscale
+    test_file< gray4_image_t >( "BASN0G04.PNG" );
+    test_png_scanline_reader< gray4_image_t >( "BASN0G04.PNG" );
+
+    // BASN0g08    -   8 bit (256 level) grayscale
+    test_file< gray8_image_t >( "BASN0G08.PNG" );
+    test_png_scanline_reader< gray8_image_t >( "BASN0G08.PNG" );
+
+    // BASN0g16    -   16 bit (64k level) grayscale
+    test_file< gray16_image_t >( "BASN0G16.PNG" );
+    test_png_scanline_reader< gray16_image_t >( "BASN0G16.PNG" );
+
+    // BASN2c08    -   3x8 bits rgb color
+    test_file< rgb8_image_t >( "BASN2C08.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "BASN2C08.PNG" );
+
+    // BASN2c16    -   3x16 bits rgb color
+    test_file< rgb16_image_t >( "BASN2C16.PNG" );
+    test_png_scanline_reader< rgb16_image_t >( "BASN2C16.PNG" );
+
+    // BASN3p01    -   1 bit (2 color) paletted
+    test_file< rgb8_image_t >( "BASN3P01.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "BASN3P01.PNG" );
+
+    // BASN3p02    -   2 bit (4 color) paletted
+    test_file< rgb8_image_t >( "BASN3P02.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "BASN3P02.PNG" );
+
+    // BASN3p04    -   4 bit (16 color) paletted
+    test_file< rgb8_image_t >( "BASN3P04.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "BASN3P04.PNG" );
+
+    // BASN3p08    -   8 bit (256 color) paletted
+    test_file< rgb8_image_t >( "BASN3P08.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "BASN3P08.PNG" );
+
+    // BASN4a08    -   8 bit grayscale + 8 bit alpha-channel
+    test_file< gray_alpha8_image_t >( "BASN4A08.PNG" );
+    test_png_scanline_reader< gray_alpha8_image_t >( "BASN4A08.PNG" );
+
+    // BASN4a16    -   16 bit grayscale + 16 bit alpha-channel
+    test_file< gray_alpha16_image_t >( "BASN4A16.PNG" );
+    test_png_scanline_reader< gray_alpha16_image_t >( "BASN4A16.PNG" );
+
+    // BASN6a08    -   3x8 bits rgb color + 8 bit alpha-channel
+    test_file< rgba8_image_t >( "BASN6A08.PNG" );
+    test_png_scanline_reader< rgba8_image_t >( "BASN6A08.PNG" );
+
+    // BASN6a16    -   3x16 bits rgb color + 16 bit alpha-channel
+    test_file< rgba16_image_t >( "BASN6A16.PNG" );
+    test_png_scanline_reader< rgba16_image_t >( "BASN6A16.PNG" );
+}
+
+BOOST_AUTO_TEST_CASE( BASIc_format_interlaced_test )
+{
+    // Basic format test files (Adam-7 interlaced)
+
+    // BASI0g01    -   black & white
+    test_file< gray1_image_t >( "BASI0G01.PNG" );
+
+    // BASI0g02    -   2 bit (4 level) grayscale
+    test_file< gray2_image_t >( "BASI0G02.PNG" );
+
+    // BASI0g04    -   4 bit (16 level) grayscale
+    test_file< gray4_image_t >( "BASI0G04.PNG" );
+
+    // BASI0g08    -   8 bit (256 level) grayscale
+    test_file< gray8_image_t >( "BASI0G08.PNG" );
+
+    // BASI0g16    -   16 bit (64k level) grayscale
+    test_file< gray16_image_t >( "BASI0G16.PNG" );
+
+    // BASI2c08    -   3x8 bits rgb color
+    test_file< rgb8_image_t >( "BASI2C08.PNG" );
+
+    // BASI2c16    -   3x16 bits rgb color
+    test_file< rgb16_image_t >( "BASI2C16.PNG" );
+
+    // BASI3p01    -   1 bit (2 color) paletted
+    test_file< rgb8_image_t >( "BASI3P01.PNG" );
+
+    // BASI3p02    -   2 bit (4 color) paletted
+    test_file< rgb8_image_t >( "BASI3P02.PNG" );
+
+    // BASI3p04    -   4 bit (16 color) paletted
+    test_file< rgb8_image_t >( "BASI3P04.PNG" );
+
+    // BASI3p08    -   8 bit (256 color) paletted
+    test_file< rgb8_image_t >( "BASI3P08.PNG" );
+
+    // BASI4a08    -   8 bit grayscale + 8 bit alpha-channel
+    test_file< gray_alpha8_image_t >( "BASI4A08.PNG" );
+
+    // BASI4a16    -   16 bit grayscale + 16 bit alpha-channel
+    test_file< gray_alpha16_image_t >( "BASI4A16.PNG" );
+
+    // BASI6a08    -   3x8 bits rgb color + 8 bit alpha-channel
+    test_file< rgba8_image_t >( "BASI6A08.PNG" );
+
+    // BASI6a16    -   3x16 bits rgb color + 16 bit alpha-channel
+    test_file< rgba16_image_t >( "BASI6A16.PNG" );
+}
+
+BOOST_AUTO_TEST_CASE( odd_sizes_test )
+{
+    // S01I3P01 - 1x1 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S01I3P01.PNG" );
+
+    // S01N3P01 - 1x1 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S01N3P01.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S01N3P01.PNG" );
+
+    // S02I3P01 - 2x2 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S02I3P01.PNG" );
+
+    // S02N3P01 - 2x2 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S02N3P01.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S02N3P01.PNG" );
+
+    // S03I3P01 - 3x3 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S03I3P01.PNG" );
+
+    // S03N3P01 - 3x3 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S03N3P01.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S03N3P01.PNG" );
+
+    // S04I3P01 - 4x4 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S04I3P01.PNG" );
+
+    // S04N3P01 - 4x4 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S04N3P01.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S04N3P01.PNG" );
+
+    // S05I3P02 - 5x5 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S05I3P02.PNG" );
+
+    // S05N3P02 - 5x5 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S05N3P02.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S05N3P02.PNG" );
+
+    // S06I3P02 - 6x6 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S06I3P02.PNG" );
+
+    // S06N3P02 - 6x6 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S06N3P02.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S06N3P02.PNG" );
+
+    // S07I3P02 - 7x7 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S07I3P02.PNG" );
+
+    // S07N3P02 - 7x7 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S07N3P02.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S07N3P02.PNG" );
+
+    // S08I3P02 - 8x8 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S08I3P02.PNG" );
+
+    // S08N3P02 - 8x8 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S08N3P02.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S08N3P02.PNG" );
+
+    // S09I3P02 - 9x9 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S09I3P02.PNG" );
+
+    // S09N3P02 - 9x9 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S09N3P02.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S09N3P02.PNG" );
+
+    // S32I3P04 - 32x32 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S32I3P04.PNG" );
+
+    // S32N3P04 - 32x32 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S32N3P04.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S32N3P04.PNG" );
+
+    // S33I3P04 - 33x33 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S33I3P04.PNG" );
+
+    // S33N3P04 - 33x33 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S33N3P04.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S33N3P04.PNG" );
+
+    // S34I3P04 - 34x34 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S34I3P04.PNG" );
+
+    // S34N3P04 - 34x34 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S34N3P04.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S34N3P04.PNG" );
+
+    // S35I3P04 - 35x35 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S35I3P04.PNG" );
+
+    // S35N3P04 - 35x35 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S35N3P04.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S35N3P04.PNG" );
+
+    // S36I3P04 - 36x36 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S36I3P04.PNG" );
+
+    // S36N3P04 - 36x36 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S36N3P04.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S36N3P04.PNG" );
+
+    // S37I3P04 - 37x37 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S37I3P04.PNG" );
+
+    // S37N3P04 - 37x37 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S37N3P04.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S37N3P04.PNG" );
+
+    // S38I3P04 - 38x38 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S38I3P04.PNG" );
+
+    // S38N3P04 - 38x38 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S38N3P04.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S38N3P04.PNG" );
+
+    // S39I3P04 - 39x39 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S39I3P04.PNG" );
+
+    // S39N3P04 - 39x39 paletted file, no interlacing 
+    test_file< rgb8_image_t >( "S39N3P04.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S39N3P04.PNG" );
+
+    // S40I3P04 - 40x40 paletted file, interlaced 
+    test_file< rgb8_image_t >( "S40I3P04.PNG" );
+
+    // S40N3P04 - 40x40 paletted file, no interlacing
+    test_file< rgb8_image_t >( "S40N3P04.PNG" );
+    test_png_scanline_reader< rgb8_image_t >( "S40N3P04.PNG" );
+}
+
+BOOST_AUTO_TEST_CASE( background_test )
+{
+    // BGAI4A08 - 8 bit grayscale, alpha, no background chunk, interlaced 
+    test_file< gray_alpha8_image_t >( "BGAI4A08.PNG" );
+
+    // BGAI4A16 - 16 bit grayscale, alpha, no background chunk, interlaced 
+    test_file< gray_alpha16_image_t >( "BGAI4A16.PNG" );
+
+    // BGAN6A08 - 3x8 bits rgb color, alpha, no background chunk 
+    test_file< rgba8_image_t >( "BGAN6A08.PNG" );
+
+    // BGAN6A16 - 3x16 bits rgb color, alpha, no background chunk 
+    test_file< rgba16_image_t >( "BGAN6A16.PNG" );
+
+    // BGBN4A08 - 8 bit grayscale, alpha, black background chunk 
+    test_file< gray_alpha8_image_t >( "BGBN4A08.PNG" );
+
+    // BGGN4A16 - 16 bit grayscale, alpha, gray background chunk 
+    test_file< gray_alpha16_image_t >( "BGGN4A16.PNG" );
+
+    // BGWN6A08 - 3x8 bits rgb color, alpha, white background chunk 
+    test_file< rgba8_image_t >( "BGWN6A08.PNG" );
+
+    // BGYN6A16 - 3x16 bits rgb color, alpha, yellow background chunk
+    test_file< rgba16_image_t >( "BGYN6A16.PNG" );
+}
+
+BOOST_AUTO_TEST_CASE( transparency_test )
+{
+    // TBBN1G04 - transparent, black background chunk 
+    // file missing
+    //test_file< gray_alpha8_image_t >( "TBBN1G04.PNG" );
+
+    // TBBN2C16 - transparent, blue background chunk 
+    test_file< rgba16_image_t >( "TBBN2C16.PNG" );
+
+    // TBBN3P08 - transparent, black background chunk 
+    test_file< rgba8_image_t >( "TBBN3P08.PNG" );
+
+    // TBGN2C16 - transparent, green background chunk 
+    test_file< rgba16_image_t >( "TBGN2C16.PNG" );
+
+    // TBGN3P08 - transparent, light-gray background chunk 
+    test_file< rgba8_image_t >( "TBGN3P08.PNG" );
+
+    // TBRN2C08 - transparent, red background chunk 
+    test_file< rgba8_image_t >( "TBRN2C08.PNG" );
+
+    // TBWN1G16 - transparent, white background chunk 
+    test_file< gray_alpha16_image_t >( "TBWN1G16.PNG" );
+
+    // TBWN3P08 - transparent, white background chunk 
+    test_file< rgba8_image_t >( "TBWN3P08.PNG" );
+
+    // TBYN3P08 - transparent, yellow background chunk 
+    test_file< rgba8_image_t >( "TBYN3P08.PNG" );
+
+    // TP0N1G08 - not transparent for reference (logo on gray) 
+    test_file< gray8_image_t >( "TP0N1G08.PNG" );
+
+    // TP0N2C08 - not transparent for reference (logo on gray) 
+    test_file< rgb8_image_t >( "TP0N2C08.PNG" );
+
+    // TP0N3P08 - not transparent for reference (logo on gray) 
+    test_file< rgb8_image_t >( "TP0N3P08.PNG" );
+
+    // TP1N3P08 - transparent, but no background chunk
+    test_file< rgba8_image_t >( "TP1N3P08.PNG" );
+}
+
+BOOST_AUTO_TEST_CASE( gamma_test )
+{
+    // G03N0G16 - grayscale, file-gamma = 0.35 
+    test_file< gray16_image_t >( "G03N0G16.PNG" );
+
+    // G03N2C08 - color, file-gamma = 0.35 
+    test_file< rgb8_image_t >( "G03N2C08.PNG" );
+
+    // G03N3P04 - paletted, file-gamma = 0.35 
+    test_file< rgb8_image_t >( "G03N3P04.PNG" );
+
+    // G04N0G16 - grayscale, file-gamma = 0.45 
+    test_file< gray16_image_t >( "G04N0G16.PNG" );
+
+    // G04N2C08 - color, file-gamma = 0.45 
+    test_file< rgb8_image_t >( "G04N2C08.PNG" );
+
+    // G04N3P04 - paletted, file-gamma = 0.45 
+    test_file< rgb8_image_t >( "G04N3P04.PNG" );
+
+    // G05N0G16 - grayscale, file-gamma = 0.55 
+    test_file< gray16_image_t >( "G05N0G16.PNG" );
+
+    // G05N2C08 - color, file-gamma = 0.55 
+    test_file< rgb8_image_t >( "G05N2C08.PNG" );
+
+    // G05N3P04 - paletted, file-gamma = 0.55 
+    test_file< rgb8_image_t >( "G05N3P04.PNG" );
+
+    // G07N0G16 - grayscale, file-gamma = 0.70 
+    test_file< gray16_image_t >( "G07N0G16.PNG" );
+
+    // G07N2C08 - color, file-gamma = 0.70 
+    test_file< rgb8_image_t >( "G07N2C08.PNG" );
+
+    // G07N3P04 - paletted, file-gamma = 0.70 
+    test_file< rgb8_image_t >( "G07N3P04.PNG" );
+
+    // G10N0G16 - grayscale, file-gamma = 1.00 
+    test_file< gray16_image_t >( "G10N0G16.PNG" );
+
+    // G10N2C08 - color, file-gamma = 1.00 
+    test_file< rgb8_image_t >( "G10N2C08.PNG" );
+
+    // G10N3P04 - paletted, file-gamma = 1.00 
+    test_file< rgb8_image_t >( "G10N3P04.PNG" );
+
+    // G25N0G16 - grayscale, file-gamma = 2.50 
+    test_file< gray16_image_t >( "G25N0G16.PNG" );
+
+    // G25N2C08 - color, file-gamma = 2.50 
+    test_file< rgb8_image_t >( "G25N2C08.PNG" );
+
+    // G25N3P04 - paletted, file-gamma = 2.50
+    test_file< rgb8_image_t >( "G25N3P04.PNG" );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/png_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/png_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,333 @@
+//#define BOOST_TEST_MODULE png_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <fstream>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/png_all.hpp>
+
+#include <boost/type_traits/is_same.hpp>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+#include "subimage_test.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+typedef png_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( png_test )
+
+BOOST_AUTO_TEST_CASE( read_image_info_using_string )
+{
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( png_filename
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 320u );
+        BOOST_CHECK_EQUAL( backend._info._height, 240u );
+    }
+
+    {
+        ifstream in( png_filename.c_str(), ios::binary );
+
+        typedef get_reader_backend< ifstream
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( in
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 320u );
+        BOOST_CHECK_EQUAL( backend._info._height, 240u );
+    }
+
+    {
+        FILE* file = fopen( png_filename.c_str(), "rb" );
+        
+        typedef get_reader_backend< FILE*
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( file
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 320u );
+        BOOST_CHECK_EQUAL( backend._info._height, 240u );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_image_test )
+{
+    {
+        rgba8_image_t img;
+        read_image( png_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 320u );
+        BOOST_CHECK_EQUAL( img.height(), 240u );
+    }
+
+    {
+        ifstream in( png_filename.c_str(), ios::binary );
+
+        rgba8_image_t img;
+        read_image( in, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 320u );
+        BOOST_CHECK_EQUAL( img.height(), 240u );
+    }
+
+    {
+        FILE* file = fopen( png_filename.c_str(), "rb" );
+        
+        rgba8_image_t img;
+        read_image( file, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 320u );
+        BOOST_CHECK_EQUAL( img.height(), 240u );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_and_convert_image( png_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 320u );
+        BOOST_CHECK_EQUAL( img.height(), 240u );
+    }
+
+    {
+        rgba8_image_t img;
+        read_and_convert_image( png_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 320u );
+        BOOST_CHECK_EQUAL( img.height(), 240u );
+    }
+
+    {
+        ifstream in( png_filename.c_str(), ios::binary );
+
+        rgb8_image_t img;
+        read_and_convert_image( in, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 320u );
+        BOOST_CHECK_EQUAL( img.height(), 240u );
+    }
+
+    {
+        FILE* file = fopen( png_filename.c_str(), "rb" );
+        
+        rgb8_image_t img;
+        read_and_convert_image( file, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 320u );
+        BOOST_CHECK_EQUAL( img.height(), 240u );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_view_test )
+{
+    {
+        rgba8_image_t img( 320, 240 );
+        read_view( png_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( png_filename.c_str(), ios::binary );
+
+        rgba8_image_t img( 320, 240 );
+        read_view( in, view( img ), tag_t() );
+    }
+
+    {
+        FILE* file = fopen( png_filename.c_str(), "rb" );
+        
+        rgba8_image_t img( 320, 240 );
+        read_view( file, view( img ), tag_t() );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 320, 240 );
+        read_and_convert_view( png_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( png_filename.c_str(), ios::binary );
+
+        rgb8_image_t img( 320, 240 );
+        read_and_convert_view( in, view( img ), tag_t() );
+    }
+
+    {
+        FILE* file = fopen( png_filename.c_str(), "rb" );
+        
+        rgb8_image_t img( 320, 240 );
+
+        read_and_convert_view( file
+                             , view( img )
+                             , tag_t()
+                             );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( write_view_test )
+{
+    {
+        string filename( png_out + "write_test_string.png" );
+
+        write_view( filename
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( png_out + "write_test_string_bgr.png" );
+
+        write_view( filename
+                  , create_mandel_view( 320, 240
+                                      , bgr8_pixel_t( 255, 0, 0 )
+                                      , bgr8_pixel_t( 0, 255, 0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( png_out + "write_test_ofstream.png" );
+
+        ofstream out( filename.c_str(), ios::out | ios::binary );
+
+        write_view( out
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( png_out + "write_test_file.png" );
+
+        FILE* file = fopen( filename.c_str(), "wb" );
+        
+        write_view( file
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( png_out + "write_test_info.png" );
+        FILE* file = fopen( filename.c_str(), "wb" );
+
+        image_write_info< png_tag > info;
+
+        write_view( file
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , info
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( stream_test )
+{
+    // 1. Read an image.
+    ifstream in( png_filename.c_str(), ios::binary );
+
+    rgba8_image_t img;
+    read_image( in, img, tag_t() );
+
+    // 2. Write image to in-memory buffer.
+    stringstream out_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    write_view( out_buffer, view( img ), tag_t() );
+
+    // 3. Copy in-memory buffer to another.
+    stringstream in_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    in_buffer << out_buffer.rdbuf();
+
+    // 4. Read in-memory buffer to gil image
+    rgba8_image_t dst;
+    read_image( in_buffer, dst, tag_t() );
+
+    // 5. Write out image.
+    string filename( png_out + "stream_test.png" );
+    ofstream out( filename.c_str(), ios_base::binary );
+    write_view( out, view( dst ), tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( stream_test_2 )
+{
+    filebuf in_buf;
+    if( !in_buf.open( png_filename.c_str(), ios::in | ios::binary ) )
+    {
+        BOOST_CHECK( false );
+    }
+
+    istream in( &in_buf );
+
+    rgba8_image_t img;
+    read_image( in, img, tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( subimage_test )
+{
+    run_subimage_test< rgba8_image_t, tag_t >( png_filename
+                                             , point_t(  0,  0 )
+                                             , point_t( 50, 50 )
+                                             );
+
+
+    run_subimage_test< rgba8_image_t, tag_t >( png_filename
+                                             , point_t( 135, 95 )
+                                             , point_t(  50, 50 )
+                                             );
+}
+
+BOOST_AUTO_TEST_CASE( dynamic_image_test )
+{
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , rgba8_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    read_image( png_filename.c_str()
+              , runtime_image
+              , tag_t()
+              );
+
+    write_view( png_out + "dynamic_image_test.png"
+              , view( runtime_image )
+              , tag_t()
+              );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/png_write_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/png_write_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,37 @@
+//#define BOOST_TEST_MODULE png_read_test_module
+#include <boost/test/unit_test.hpp>
+
+#define BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+#define BOOST_GIL_IO_ENABLE_GRAY_ALPHA
+
+#include <boost/cstdint.hpp>
+
+#define BOOST_FILESYSTEM_VERSION 3
+#include <boost/filesystem/convenience.hpp>
+
+#include <boost/gil/extension/io_new/png_all.hpp>
+
+#include <iostream>
+
+#include "color_space_write_test.hpp"
+#include "paths.hpp"
+#include "scanline_read_test.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+using namespace boost::gil::detail;
+namespace fs = boost::filesystem;
+
+typedef png_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( png_test )
+
+BOOST_AUTO_TEST_CASE( rgb_color_space_write_test )
+{
+    color_space_write_test< tag_t >( png_out + "rgb_color_space_test.png"
+                                   , png_out + "bgr_color_space_test.png"
+                                   );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/pnm_old_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/pnm_old_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,93 @@
+//#define BOOST_TEST_MODULE pnm_old_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/pnm_io_old.hpp>
+
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+BOOST_AUTO_TEST_SUITE( pnm_test )
+
+BOOST_AUTO_TEST_CASE( old_read_dimensions_test )
+{
+    {
+        point2< ptrdiff_t > dim = pnm_read_dimensions( pnm_filename );
+
+        BOOST_CHECK_EQUAL( dim.x, 256 );
+        BOOST_CHECK_EQUAL( dim.y, 256 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_image_test )
+{
+    {
+        rgb8_image_t img;
+        pnm_read_image( pnm_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 256 );
+        BOOST_CHECK_EQUAL( img.height(), 256 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        pnm_read_and_convert_image( pnm_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 256 );
+        BOOST_CHECK_EQUAL( img.height(), 256 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_view_test )
+{
+    {
+        rgb8_image_t img( 256, 256 );
+        pnm_read_view( pnm_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 256, 256 );
+        pnm_read_and_convert_view( pnm_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_write_view_test )
+{
+    {
+        string filename( pnm_out + "test5.pnm" );
+
+        gray8_image_t img( 256, 256);
+        pnm_write_view( filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_dynamic_image_test )
+{
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , gray1_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    pnm_read_image( pnm_filename.c_str()
+                  , runtime_image
+                  );
+
+    pnm_write_view( pnm_out + "old_dynamic_image_test.pnm"
+                  , view( runtime_image )
+                  );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/pnm_read_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/pnm_read_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,132 @@
+//#define BOOST_TEST_MODULE pnm_read_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/extension/io_new/pnm_all.hpp>
+
+#include "paths.hpp"
+#include "scanline_read_test.hpp"
+
+using namespace std;
+using namespace boost::gil;
+
+typedef pnm_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( pnm_test )
+
+template< typename Image >
+void write( Image&        img
+          , const string& file_name
+          )
+{
+    write_view( pnm_out + file_name
+              , view( img )
+              , tag_t()
+              );
+}
+
+template< typename Image >
+void test_pnm_scanline_reader( string filename )
+{
+    test_scanline_reader<Image, pnm_tag>( string( pnm_in + filename ).c_str() );
+}
+
+BOOST_AUTO_TEST_CASE( read_header_test )
+{
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( pnm_filename
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._type     , pnm_image_type::color_asc_t::value );
+        BOOST_CHECK_EQUAL( backend._info._width    , 256u                               );
+        BOOST_CHECK_EQUAL( backend._info._height   , 256u                               );
+        BOOST_CHECK_EQUAL( backend._info._max_value, 255u                               );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_reference_images_test )
+{
+    // p1.pnm
+    {
+        gray8_image_t img;
+        
+        read_image( pnm_in + "p1.pnm", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 200u );
+        BOOST_CHECK_EQUAL( view( img ).height(), 200u );
+
+        write( img, "p1.pnm" );
+
+        test_pnm_scanline_reader< gray8_image_t >( "p1.pnm" );
+    }
+
+    // p2.pnm
+    {
+        gray8_image_t img;
+        
+        read_image( pnm_in + "p2.pnm", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 200u );
+        BOOST_CHECK_EQUAL( view( img ).height(), 200u );
+
+        write( img, "p2.pnm" );
+
+        test_pnm_scanline_reader< gray8_image_t >( "p2.pnm" );
+    }
+
+    // p3.pnm
+    {
+        rgb8_image_t img;
+        
+        read_image( pnm_in + "p3.pnm", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 256u );
+        BOOST_CHECK_EQUAL( view( img ).height(), 256u );
+
+        write( img, "p3.pnm" );
+
+        test_pnm_scanline_reader< rgb8_image_t >( "p3.pnm" );
+    }
+
+    // p4.pnm
+    {
+        gray1_image_t img;
+        
+        read_image( pnm_in + "p4.pnm", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 200u );
+        BOOST_CHECK_EQUAL( view( img ).height(), 200u );
+
+        write( img, "p4.pnm" );
+
+        test_pnm_scanline_reader< gray1_image_t >( "p4.pnm" );
+    }
+
+    // p5.pnm
+    {
+        gray8_image_t img;
+        
+        read_image( pnm_in + "p5.pnm", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 200u );
+        BOOST_CHECK_EQUAL( view( img ).height(), 200u );
+
+        write( img, "p5.pnm" );
+
+        test_pnm_scanline_reader< gray8_image_t >( "p5.pnm" );
+    }
+
+    // p6.pnm
+    {
+        rgb8_image_t img;
+        
+        read_image( pnm_in + "p6.pnm", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 256u );
+        BOOST_CHECK_EQUAL( view( img ).height(), 256u );
+
+        write( img, "p6.pnm" );
+
+        test_pnm_scanline_reader< rgb8_image_t >( "p6.pnm" );
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/pnm_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/pnm_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,312 @@
+//#define BOOST_TEST_MODULE pnm_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <fstream>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/pnm_all.hpp>
+
+#include <boost/type_traits/is_same.hpp>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+#include "subimage_test.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+typedef pnm_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( pnm_test )
+
+BOOST_AUTO_TEST_CASE( read_image_info_using_string )
+{
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( pnm_filename
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 256u );
+        BOOST_CHECK_EQUAL( backend._info._height, 256u );
+    }
+
+    {
+        ifstream in( pnm_filename.c_str(), ios::binary );
+
+        typedef get_reader_backend< ifstream
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( in
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 256u );
+        BOOST_CHECK_EQUAL( backend._info._height, 256u );
+    }
+
+    {
+        FILE* file = fopen( pnm_filename.c_str(), "rb" );
+        
+        typedef get_reader_backend< FILE*
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( file
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 256u );
+        BOOST_CHECK_EQUAL( backend._info._height, 256u );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_image( pnm_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 256u );
+        BOOST_CHECK_EQUAL( img.height(), 256u );
+    }
+
+    {
+        ifstream in( pnm_filename.c_str(), ios::binary );
+
+        rgb8_image_t img;
+        read_image( in, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 256u );
+        BOOST_CHECK_EQUAL( img.height(), 256u );
+    }
+
+    {
+        FILE* file = fopen( pnm_filename.c_str(), "rb" );
+        
+        rgb8_image_t img;
+        read_image( file, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 256u );
+        BOOST_CHECK_EQUAL( img.height(), 256u );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_and_convert_image( pnm_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 256u );
+        BOOST_CHECK_EQUAL( img.height(), 256u );
+    }
+
+    {
+        ifstream in( pnm_filename.c_str(), ios::binary );
+
+        rgb8_image_t img;
+        read_and_convert_image( in, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 256u );
+        BOOST_CHECK_EQUAL( img.height(), 256u );
+    }
+
+    {
+        FILE* file = fopen( pnm_filename.c_str(), "rb" );
+        
+        rgb8_image_t img;
+        read_and_convert_image( file, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 256u );
+        BOOST_CHECK_EQUAL( img.height(), 256u );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_view_test )
+{
+    {
+        rgb8_image_t img( 256, 256 );
+        read_view( pnm_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( pnm_filename.c_str(), ios::binary );
+
+        rgb8_image_t img( 256, 256 );
+        read_view( in, view( img ), tag_t() );
+    }
+
+    {
+        FILE* file = fopen( pnm_filename.c_str(), "rb" );
+        
+        rgb8_image_t img( 256, 256 );
+        read_view( file, view( img ), tag_t() );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 256, 256 );
+        read_and_convert_view( pnm_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( pnm_filename.c_str(), ios::binary );
+
+        rgb8_image_t img( 256, 256 );
+        read_and_convert_view( in, view( img ), tag_t() );
+    }
+
+    {
+        FILE* file = fopen( pnm_filename.c_str(), "rb" );
+        
+        rgb8_image_t img( 256, 256 );
+
+        read_and_convert_view( file
+                             , view( img )
+                             , tag_t()
+                             );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( write_view_test )
+{
+    {
+        string filename( pnm_out + "write_test_string.pnm" );
+
+        write_view( filename
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( pnm_out + "write_test_ofstream.pnm" );
+
+        ofstream out( filename.c_str(), ios::out | ios::binary );
+
+        write_view( out
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( pnm_out + "write_test_file.pnm" );
+
+        FILE* file = fopen( filename.c_str(), "wb" );
+        
+        write_view( file
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( pnm_out + "write_test_info.pnm" );
+        FILE* file = fopen( filename.c_str(), "wb" );
+
+        image_write_info< tag_t > info;
+
+        write_view( file
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , info
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( stream_test )
+{
+    // 1. Read an image.
+    ifstream in( pnm_filename.c_str(), ios::binary );
+
+    rgb8_image_t img;
+    read_image( in, img, tag_t() );
+
+    // 2. Write image to in-memory buffer.
+    stringstream out_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    write_view( out_buffer, view( img ), tag_t() );
+
+    // 3. Copy in-memory buffer to another.
+    stringstream in_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    in_buffer << out_buffer.rdbuf();
+
+    // 4. Read in-memory buffer to gil image
+    rgb8_image_t dst;
+    read_image( in_buffer, dst, tag_t() );
+
+    // 5. Write out image.
+    string filename( pnm_out + "stream_test.pnm" );
+    ofstream out( filename.c_str(), ios_base::binary );
+    write_view( out, view( dst ), tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( stream_test_2 )
+{
+    filebuf in_buf;
+    if( !in_buf.open( pnm_filename.c_str(), ios::in | ios::binary ) )
+    {
+        BOOST_CHECK( false );
+    }
+
+    istream in( &in_buf );
+
+    rgb8_image_t img;
+    read_image( in, img, tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( subimage_test )
+{
+    run_subimage_test< rgb8_image_t, tag_t >( pnm_filename
+                                            , point_t(  0,  0 )
+                                            , point_t( 50, 50 )
+                                            );
+
+    run_subimage_test< rgb8_image_t, tag_t >( pnm_filename
+                                            , point_t( 103, 103 )
+                                            , point_t(  50,  50 )
+                                            );
+}
+
+BOOST_AUTO_TEST_CASE( dynamic_image_test )
+{
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , gray1_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    read_image( pnm_filename.c_str()
+              , runtime_image
+              , tag_t()
+              );
+
+    write_view( pnm_out + "dynamic_image_test.pnm"
+              , view( runtime_image )
+              , tag_t()
+              );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/pnm_write_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/pnm_write_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,63 @@
+//#define BOOST_TEST_MODULE pnm_write_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/extension/io_new/pnm_all.hpp>
+
+#include "color_space_write_test.hpp"
+#include "mandel_view.hpp"
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost::gil;
+
+typedef pnm_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( pnm_test )
+
+BOOST_AUTO_TEST_CASE( write_test )
+{
+    mandel_view< rgb8_pixel_t >::type v = create_mandel_view( 200, 200
+                                                            , rgb8_pixel_t( 0,   0, 255 )
+                                                            , rgb8_pixel_t( 0, 255,   0 )
+                                                            );
+
+    // test writing all supported image types
+    {
+        typedef bit_aligned_image1_type< 1, gray_layout_t >::type gray1_image_t;
+        gray1_image_t dst( 200, 200 );
+
+        copy_and_convert_pixels( v, view( dst ));
+
+        write_view( pnm_out + "p4_write_test.pnm"
+                  , view( dst )
+                  , pnm_tag()
+                  );
+    }
+
+    {
+        gray8_image_t dst( 200, 200 );
+
+        copy_and_convert_pixels( v, view( dst ));
+
+        write_view( pnm_out + "p5_write_test.pnm"
+                  , view( dst )
+                  , pnm_tag()
+                  );
+    }
+
+    {
+        write_view( pnm_out + "p6_write_test.pnm"
+                  , v
+                  , pnm_tag()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( rgb_color_space_write_test )
+{
+    color_space_write_test< pnm_tag >( pnm_out + "rgb_color_space_test.pnm"
+                                     , pnm_out + "bgr_color_space_test.pnm"
+                                     );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/raw_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/raw_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,137 @@
+//#define BOOST_TEST_MODULE raw_test_module
+#include <boost/test/unit_test.hpp>
+
+#define BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+#include <fstream>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/raw_all.hpp>
+
+#define BOOST_FILESYSTEM_VERSION 3
+#include <boost/filesystem/convenience.hpp>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+#include "subimage_test.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+namespace fs = boost::filesystem;
+
+typedef raw_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( raw_test )
+
+BOOST_AUTO_TEST_CASE( read_image_info_using_string )
+{
+
+    {
+        /// raw_tag reader's can only constructed with char*, std::string, and LibRaw object
+
+        typedef get_reader_backend< const char*
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t b = make_reader_backend( raw_filename.c_str()
+                                         , image_read_settings< raw_tag >()
+                                         );
+
+        backend_t backend = read_image_info( raw_filename
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 2176 );
+        BOOST_CHECK_EQUAL( backend._info._height, 1448 );
+    }
+
+    {
+        fs::path my_path( raw_filename );
+
+        typedef get_reader_backend< fs::path
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( my_path
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 2176 );
+        BOOST_CHECK_EQUAL( backend._info._height, 1448 );
+    }
+}
+
+//BOOST_AUTO_TEST_CASE( read_image_test )
+//{
+//    {
+//        rgb8_image_t img;
+//        read_image( raw_filename, img, tag_t() );
+//
+//        BOOST_CHECK_EQUAL( img.width() , 2176 );
+//        BOOST_CHECK_EQUAL( img.height(), 1448 );
+//    }
+//
+//    {
+//        fs::path my_path( raw_filename );
+//
+//        rgb8_image_t img;
+//        read_image( my_path, img, tag_t() );
+//
+//        BOOST_CHECK_EQUAL( img.width() , 2176 );
+//        BOOST_CHECK_EQUAL( img.height(), 1448 );
+//    }
+//}
+//
+//BOOST_AUTO_TEST_CASE( read_and_convert_image_test )
+//{
+//    rgb8_image_t img;
+//    read_and_convert_image( raw_filename, img, tag_t() );
+//
+//    BOOST_CHECK_EQUAL( img.width() , 2176 );
+//    BOOST_CHECK_EQUAL( img.height(), 1448 );
+//}
+//
+//BOOST_AUTO_TEST_CASE( read_view_test )
+//{
+//    rgb8_image_t img( 2176, 1448 );
+//    read_view( raw_filename, view( img ), tag_t() );
+//}
+//
+//BOOST_AUTO_TEST_CASE( read_and_convert_view_test )
+//{
+//    rgb8_image_t img( 2176, 1448 );
+//    read_and_convert_view( raw_filename, view( img ), tag_t() );
+//}
+
+//BOOST_AUTO_TEST_CASE( subimage_test )
+//{
+//    run_subimage_test< rgb8_image_t, tag_t >( raw_filename
+//                                            , point_t(   0, 0 )
+//                                            , point_t( 127, 1 )
+//                                            );
+//
+//    run_subimage_test< rgb8_image_t, tag_t >( raw_filename
+//                                            , point_t( 39,  7 )
+//                                            , point_t( 50, 50 )
+//                                            );
+//}
+
+//BOOST_AUTO_TEST_CASE( dynamic_image_test )
+//{
+//    typedef mpl::vector< gray8_image_t
+//                       , gray16_image_t
+//                       , rgb8_image_t
+//                       , rgba8_image_t
+//                       > my_img_types;
+//
+//
+//    any_image< my_img_types > runtime_image;
+//
+//    read_image( raw_filename.c_str()
+//              , runtime_image
+//              , tag_t()
+//              );
+//}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/readme.txt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/readme.txt	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,59 @@
+Step-by-step tutorial to have the test suite build using MS VC 10 on Windows 7
+
+
+1. Get boost, preferably latest version or trunk
+	http://svn.boost.org/svn/boost/trunk
+
+1.1 Get bjam.exe
+	
+2. Build boost
+		debug:
+		bjam -j4 --toolset=msvc --without-mpi variant=debug define=_CRT_NONSTDC_NO_DEPRECATE define=_CRT_SECURE_NO_DEPRECATE define=_SCL_SECURE_NO_DEPRECATE stage
+		
+3. Get boost build extension
+		http://svn.boost.org/svn/boost/sandbox/tools/build_extensions/
+
+3.1 Apply patch to boost_build extension
+		http://mateusz.loskot.net/download/patches/boost-build_extensions-r66346-update.patch
+		
+4. Get image libs
+	jpeg: http://www.ijg.org/
+	tiff: http://www.remotesensing.org/libtiff/
+	zlib: http://www.zlib.net/
+	png: http://www.libpng.org/pub/png/libpng.html
+
+	- rename tiffconf.vc.h into tiffconf.h
+	
+5. Set environment variables
+	BOOST_ROOT=C:\boost
+	BOOST_BUILD=C:\boost\tools\build\v2
+	BOOST_BUILD_PATH=C:\boost_build\ext
+
+6. Get io_new
+	http://gil-contributions.googlecode.com/svn/trunk/
+
+6.1 Copy io_new into boost source tree
+	C:\gil_contribution\gil_2\boost\gil\extension\*.*  to C:\boost\boost\gil\extension
+	C:\gil_contribution\gil_2\libs\gil\io_new\*.*	   to C:\boost\libs\gil\io_new
+	
+7. Create empty jamroot file in C:\boost\libs\gil
+	- needs to be removed when building gil's unit tests
+
+8. copy bjam.exe into gil test and gil::io_new test folders
+	C:\boost\libs\gil\test
+	C:\boost\libs\gil\io_new\test
+
+9. copy C:\boost\tools\build\v2\user-config.jam to user root ( C:\Users\your_user_name )
+	- needs to be removed when building any boost lib unit tests
+
+	9.1 add line user-config.jam
+	use-project boost : C:/boost/ ;
+
+10. change main path in path.hpp
+	
+10. run bjam in in C:\boost\libs\gil\io_new\test
+	debug:
+	bjam -j4 --toolset=msvc threading=multi
+
+	release:
+	bjam -j4 --toolset=msvc variant=release threading=multi define=_SECURE_SCL=0 define=_HAS_ITERATOR_DEBUGGING=0
Index: boost-1.52.0/src/libs/gil/io_new/test/scanline_read_test.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/scanline_read_test.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,50 @@
+#ifndef BOOST_GIL_IO_UNIT_TEST_SCANLINE_READ_TEST_HPP
+#define BOOST_GIL_IO_UNIT_TEST_SCANLINE_READ_TEST_HPP
+
+#include <boost/gil/gil_all.hpp>
+
+#include "cmp_view.hpp"
+
+template< typename Image
+        , typename FormatTag
+        >
+void test_scanline_reader( const char* file_name )
+{
+
+    // read image using scanline_read_iterator
+    typedef scanline_reader< typename get_read_device< const char*
+                                                     , FormatTag
+                                                     >::type
+                           , FormatTag
+                           > reader_t;
+
+    reader_t reader = make_scanline_reader( file_name, FormatTag() );
+
+    Image dst( reader._info._width, reader._info._height );
+    byte_t* buffer = new byte_t[ reader._scanline_length ];
+
+    auto it  = scanline_read_iterator< reader_t >( reader, buffer );
+    auto end = scanline_read_iterator< reader_t >();
+
+    int row = 0;
+    while( it != end )
+    {
+        *it;
+
+        copy_pixels( interleaved_view( reader._info._width, 1, ( typename Image::view_t::x_iterator ) buffer, reader._scanline_length )
+                   , subimage_view( view( dst    ), 0, row, reader._info._width, 1 )
+                   );
+
+        ++row;
+    }
+
+    delete[] buffer;
+
+    //compare
+    Image img;
+    read_image( file_name, img, FormatTag() );
+
+    cmp_view( view( dst ), view( img ) );
+}
+
+#endif // BOOST_GIL_IO_UNIT_TEST_SCANLINE_READ_TEST_HPP
Index: boost-1.52.0/src/libs/gil/io_new/test/subimage_test.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/subimage_test.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,44 @@
+#ifndef BOOST_GIL_IO_UNIT_TEST_SUBIMAGE_TEST_HPP
+#define BOOST_GIL_IO_UNIT_TEST_SUBIMAGE_TEST_HPP
+
+#include <boost/gil/gil_all.hpp>
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+template< typename Image
+        , typename Format
+        >
+void run_subimage_test( string filename
+                      , const point_t& top_left
+                      , const point_t& dimension
+                      )
+{
+    Image original, subimage;
+
+    read_image( filename
+              , original
+              , Format()
+              );
+
+    image_read_settings< Format > settings( top_left
+                                           , dimension
+                                           );
+
+
+    read_image( filename
+              , subimage
+              , settings
+              );
+
+    BOOST_CHECK( equal_pixels( const_view( subimage )
+                             , subimage_view( const_view( original )
+                                            , top_left
+                                            , dimension
+                                            )
+                             )
+               );
+}
+
+#endif // BOOST_GIL_IO_UNIT_TEST_SUBIMAGE_TEST_HPP
Index: boost-1.52.0/src/libs/gil/io_new/test/targa_old_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/targa_old_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,96 @@
+//#define BOOST_TEST_MODULE targa_old_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/targa_io_old.hpp>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+BOOST_AUTO_TEST_SUITE( targa_test )
+
+BOOST_AUTO_TEST_CASE( old_read_dimensions_test )
+{
+    {
+        point2< ptrdiff_t > dim = targa_read_dimensions( targa_filename );
+
+        BOOST_CHECK_EQUAL( dim.x, 124 );
+        BOOST_CHECK_EQUAL( dim.y, 124 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_image_test )
+{
+    {
+        rgb8_image_t img;
+        targa_read_image( targa_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 124 );
+        BOOST_CHECK_EQUAL( img.height(), 124 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        targa_read_and_convert_image( targa_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 124 );
+        BOOST_CHECK_EQUAL( img.height(), 124 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_view_test )
+{
+    {
+        rgb8_image_t img( 124, 124 );
+        targa_read_view( targa_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 124, 124 );
+        targa_read_and_convert_view( targa_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_write_view_test )
+{
+    {
+        targa_write_view( targa_out + "old_write_view_test.tga"
+                        , create_mandel_view( 124, 124
+                                            , rgb8_pixel_t( 0,   0, 255 )
+                                            , rgb8_pixel_t( 0, 255,   0 )
+                                            )
+                        );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_dynamic_image_test )
+{
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , rgba8_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    targa_read_image( targa_filename.c_str()
+                    , runtime_image
+                    );
+
+    targa_write_view( targa_out + "old_dynamic_image_test.tga"
+                    , view( runtime_image )
+                    );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/targa_read_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/targa_read_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,132 @@
+//#define BOOST_TEST_MODULE targa_read_test_module
+#include <boost/test/unit_test.hpp>
+#include <boost/type_traits/is_same.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/targa_all.hpp>
+
+#include "paths.hpp"
+#include "scanline_read_test.hpp"
+
+using namespace std;
+using namespace boost::gil;
+
+typedef targa_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( targa_test )
+
+template< typename Image >
+void test_targa_scanline_reader( string filename )
+{
+    test_scanline_reader<Image, targa_tag>( string( targa_in + filename ).c_str() );
+}
+
+template< typename Image >
+void write( Image&        img
+          , const string& file_name
+          )
+{
+    write_view( targa_out + file_name
+              , view( img )
+              , tag_t()
+              );
+}
+
+BOOST_AUTO_TEST_CASE( read_header_test )
+{
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( targa_filename
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._header_size     , 18  );
+        BOOST_CHECK_EQUAL( backend._info._offset          , 18  );
+        BOOST_CHECK_EQUAL( backend._info._color_map_type  , 0   );
+        BOOST_CHECK_EQUAL( backend._info._image_type      , 10  );
+        BOOST_CHECK_EQUAL( backend._info._color_map_start , 0   );
+        BOOST_CHECK_EQUAL( backend._info._color_map_length, 0   );
+        BOOST_CHECK_EQUAL( backend._info._color_map_depth , 0   );
+        BOOST_CHECK_EQUAL( backend._info._x_origin        , 0   );
+        BOOST_CHECK_EQUAL( backend._info._y_origin        , 0   );
+        BOOST_CHECK_EQUAL( backend._info._width           , 124 );
+        BOOST_CHECK_EQUAL( backend._info._height          , 124 );
+        BOOST_CHECK_EQUAL( backend._info._bits_per_pixel  , 24  );
+        BOOST_CHECK_EQUAL( backend._info._descriptor      , 0   );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_reference_images_test )
+{
+    // 24BPP_compressed.tga
+    {
+        rgb8_image_t img;
+        
+        read_image( targa_in + "24BPP_compressed.tga", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 124 );
+        BOOST_CHECK_EQUAL( view( img ).height(), 124 );
+
+        write( img, "24BPP_compressed_out.tga" );
+    }
+
+    // 24BPP_uncompressed.tga
+    {
+        rgb8_image_t img;
+        
+        read_image( targa_in + "24BPP_uncompressed.tga", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 124 );
+        BOOST_CHECK_EQUAL( view( img ).height(), 124 );
+
+        write( img, "24BPP_uncompressed_out.tga" );
+
+        test_targa_scanline_reader< bgr8_image_t >( "24BPP_uncompressed.tga" );
+    }
+
+    // 32BPP_compressed.tga
+    {
+        rgba8_image_t img;
+        
+        read_image( targa_in + "32BPP_compressed.tga", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 124 );
+        BOOST_CHECK_EQUAL( view( img ).height(), 124 );
+
+        write( img, "32BPP_compressed_out.tga" );
+    }
+
+    // 32BPP_uncompressed.tga
+    {
+        rgba8_image_t img;
+        
+        read_image( targa_in + "32BPP_uncompressed.tga", img, tag_t() );
+        BOOST_CHECK_EQUAL( view( img ).width() , 124 );
+        BOOST_CHECK_EQUAL( view( img ).height(), 124 );
+
+        write( img, "32BPP_uncompressed_out.tga" );
+
+        test_targa_scanline_reader< bgra8_image_t >( "32BPP_uncompressed.tga" );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( partial_image_test )
+{
+    const std::string filename( targa_in + "24BPP_compressed.tga" );
+
+    {
+        rgb8_image_t img;
+        read_image( filename
+                  , img
+                  , image_read_settings< targa_tag >( point_t( 0, 0 ), point_t( 50, 50 ) )
+                  );
+
+
+        write_view( targa_out + "targa_partial.tga"
+                  , view( img )
+                  , tag_t()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/targa_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/targa_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,320 @@
+//#define BOOST_TEST_MODULE targa_test_module
+#include <boost/test/unit_test.hpp>
+
+#define BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+
+#include <fstream>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/targa_all.hpp>
+
+#include <boost/filesystem/convenience.hpp>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+#include "subimage_test.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+namespace fs = boost::filesystem;
+
+typedef targa_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( targa_test )
+
+BOOST_AUTO_TEST_CASE( read_image_info_using_string )
+{
+
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( targa_filename
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 124 );
+        BOOST_CHECK_EQUAL( backend._info._height, 124 );
+    }
+
+    {
+        ifstream in( targa_filename.c_str(), ios::binary );
+
+        typedef get_reader_backend< ifstream
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( in
+                                           , tag_t()
+                                           );
+                                           
+        BOOST_CHECK_EQUAL( backend._info._width , 124 );
+        BOOST_CHECK_EQUAL( backend._info._height, 124 );
+    }
+
+    {
+        FILE* file = fopen( targa_filename.c_str(), "rb" );
+        
+        typedef get_reader_backend< FILE*
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( file
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 124 );
+        BOOST_CHECK_EQUAL( backend._info._height, 124 );
+    }
+
+    {
+        fs::path my_path( targa_filename );
+
+        typedef get_reader_backend< fs::path
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( my_path
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 124 );
+        BOOST_CHECK_EQUAL( backend._info._height, 124  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_image( targa_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 124 );
+        BOOST_CHECK_EQUAL( img.height(), 124 );
+    }
+
+    {
+        ifstream in( targa_filename.c_str(), ios::binary );
+
+        rgb8_image_t img;
+        read_image( in, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 124 );
+        BOOST_CHECK_EQUAL( img.height(), 124 );
+    }
+
+    {
+        FILE* file = fopen( targa_filename.c_str(), "rb" );
+        
+        rgb8_image_t img;
+        read_image( file, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 124 );
+        BOOST_CHECK_EQUAL( img.height(), 124 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_and_convert_image( targa_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 124 );
+        BOOST_CHECK_EQUAL( img.height(), 124 );
+    }
+
+    {
+        ifstream in( targa_filename.c_str(), ios::binary );
+
+        rgb8_image_t img;
+        read_and_convert_image( in, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 124 );
+        BOOST_CHECK_EQUAL( img.height(), 124 );
+    }
+
+    {
+        FILE* file = fopen( targa_filename.c_str(), "rb" );
+        
+        rgb8_image_t img;
+        read_and_convert_image( file, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 124 );
+        BOOST_CHECK_EQUAL( img.height(), 124 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_view_test )
+{
+    {
+        rgb8_image_t img( 124, 124 );
+        read_view( targa_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( targa_filename.c_str(), ios::binary );
+
+        rgb8_image_t img( 124, 124 );
+        read_view( in, view( img ), tag_t() );
+    }
+
+    {
+        FILE* file = fopen( targa_filename.c_str(), "rb" );
+        
+        rgb8_image_t img( 124, 124 );
+        read_view( file, view( img ), tag_t() );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 124, 124 );
+        read_and_convert_view( targa_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( targa_filename.c_str(), ios::binary );
+
+        rgb8_image_t img( 124, 124 );
+        read_and_convert_view( in, view( img ), tag_t() );
+    }
+
+    {
+        FILE* file = fopen( targa_filename.c_str(), "rb" );
+        
+        rgb8_image_t img( 124, 124 );
+        read_and_convert_view( file
+                             , view( img )
+                             , tag_t()
+                             );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( write_view_test )
+{
+    {
+        string filename( targa_out + "write_test_ofstream.tga" );
+
+        ofstream out( filename.c_str(), ios::binary );
+
+        write_view( out
+                  , create_mandel_view( 124, 124
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( targa_out + "write_test_file.tga" );
+
+        FILE* file = fopen( filename.c_str(), "wb" );
+        
+        write_view( file
+                  , create_mandel_view( 124, 124
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( targa_out + "write_test_info.tga" );
+
+        image_write_info< tag_t > info;
+
+        FILE* file = fopen( filename.c_str(), "wb" );
+
+        write_view( file
+                  , create_mandel_view( 124, 124
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , info
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( stream_test )
+{
+    // 1. Read an image.
+    ifstream in( targa_filename.c_str(), ios::binary );
+
+    rgb8_image_t img;
+    read_image( in, img, tag_t() );
+
+    // 2. Write image to in-memory buffer.
+    stringstream out_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    write_view( out_buffer, view( img ), tag_t() );
+
+    // 3. Copy in-memory buffer to another.
+    stringstream in_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    in_buffer << out_buffer.rdbuf();
+
+    // 4. Read in-memory buffer to gil image
+    rgb8_image_t dst;
+    read_image( in_buffer, dst, tag_t() );
+
+    // 5. Write out image.
+    string filename( targa_out + "stream_test.tga" );
+    ofstream out( filename.c_str(), ios_base::binary );
+    write_view( out, view( dst ), tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( stream_test_2 )
+{
+    filebuf in_buf;
+    if( !in_buf.open( targa_filename.c_str(), ios::in | ios::binary ) )
+    {
+        BOOST_CHECK( false );
+    }
+
+    istream in( &in_buf );
+
+    rgb8_image_t img;
+    read_image( in, img, tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( subimage_test )
+{
+    run_subimage_test< rgb8_image_t, tag_t >( targa_filename
+                                            , point_t(  0,  0 )
+                                            , point_t( 50, 50 )
+                                            );
+
+    // not working
+    //run_subimage_test< rgb8_image_t, tag_t >( targa_filename
+    //                                        , point_t( 39,  7 )
+    //                                        , point_t( 50, 50 )
+    //                                        );
+}
+
+BOOST_AUTO_TEST_CASE( dynamic_image_test )
+{
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , rgba8_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    read_image( targa_filename.c_str()
+              , runtime_image
+              , tag_t()
+              );
+
+    write_view( targa_out + "dynamic_image_test.tga"
+              , view( runtime_image )
+              , tag_t()
+              );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/targa_write_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/targa_write_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,51 @@
+//#define BOOST_TEST_MODULE targa_write_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/gil_all.hpp>
+
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+#include <boost/gil/extension/io_new/targa_all.hpp>
+
+#include "color_space_write_test.hpp"
+#include "mandel_view.hpp"
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost::gil;
+
+typedef targa_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( targa_test )
+
+BOOST_AUTO_TEST_CASE( write_test )
+{
+    // test writing all supported image types
+    {
+        write_view( targa_out + "rgb8_test.tga"
+                  , create_mandel_view( 200, 200
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        write_view( targa_out + "rgba8_test.tga"
+                  , create_mandel_view( 200, 200
+                                      , rgba8_pixel_t( 0,   0, 255, 0 )
+                                      , rgba8_pixel_t( 0, 255,   0, 0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( rgb_color_space_write_test )
+{
+    color_space_write_test< tag_t >( targa_out + "rgb_color_space_test.tga"
+                                   , targa_out + "bgr_color_space_test.tga"
+                                   );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,2 @@
+#define BOOST_TEST_MAIN
+#include <boost/test/unit_test.hpp>
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_file_format_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_file_format_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,918 @@
+/**************************************************
+ *
+ * This test file will read and write various
+ * tiff formats. 
+ *
+ **************************************************/
+//#define BOOST_TEST_MODULE tiff_file_format_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/extension/io_new/tiff_all.hpp>
+
+#include "paths.hpp"
+#include "scanline_read_test.hpp"
+
+using namespace std;
+using namespace boost::gil;
+
+typedef tiff_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+template< typename Image >
+void test_tiff_scanline_reader( string filename )
+{
+    test_scanline_reader<Image, tag_t>( filename.c_str() );
+}
+
+// 73x43 2-bit minisblack gray image
+BOOST_AUTO_TEST_CASE( two_bit_minisblack_gray_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-minisblack-02.tif" );
+
+    {
+        typedef bit_aligned_image1_type< 2, gray_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test4.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-minisblack-04.tif	73x43 4-bit minisblack gray image
+BOOST_AUTO_TEST_CASE( four_bit_minisblack_gray_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-minisblack-04.tif" );
+
+    {
+        typedef bit_aligned_image1_type< 4, gray_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test5.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-minisblack-06.tif 73x43 6-bit minisblack gray image
+BOOST_AUTO_TEST_CASE( six_bit_minisblack_gray_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-minisblack-06.tif" );
+
+    {
+        typedef bit_aligned_image1_type< 6, gray_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test6.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-minisblack-08.tif	73x43 8-bit minisblack gray image
+BOOST_AUTO_TEST_CASE( eight_bit_minisblack_gray_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-minisblack-08.tif" );
+
+    {
+        typedef gray8_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test7.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-minisblack-10.tif	73x43 10-bit minisblack gray image
+BOOST_AUTO_TEST_CASE( ten_bit_minisblack_gray_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-minisblack-10.tif" );
+
+    {
+        typedef bit_aligned_image1_type< 10, gray_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test8.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-minisblack-12.tif	73x43 12-bit minisblack gray image
+BOOST_AUTO_TEST_CASE( twelve_bit_minisblack_gray_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-minisblack-12.tif" );
+
+    {
+        typedef bit_aligned_image1_type< 12, gray_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test9.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-minisblack-14.tif	73x43 14-bit minisblack gray image
+BOOST_AUTO_TEST_CASE( fourteen_bit_minisblack_gray_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-minisblack-14.tif" );
+
+    {
+        typedef bit_aligned_image1_type< 14, gray_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test10.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-minisblack-16.tif	73x43 16-bit minisblack gray image
+BOOST_AUTO_TEST_CASE( sixteen_bit_minisblack_gray_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-minisblack-16.tif" );
+
+    {
+        typedef gray16_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test11.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-minisblack-24.tif	73x43 24-bit minisblack gray image
+BOOST_AUTO_TEST_CASE( twentyfour_bit_minisblack_gray_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-minisblack-24.tif" );
+
+    {
+        typedef bit_aligned_image1_type< 24, gray_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test12.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-minisblack-32.tif	73x43 32-bit minisblack gray image
+BOOST_AUTO_TEST_CASE( thirtytwo_bit_minisblack_gray_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-minisblack-32.tif" );
+
+    {
+        typedef gray32_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test13.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-palette-02.tif 73x43 4-entry colormapped image
+BOOST_AUTO_TEST_CASE( four_entry_colormapped_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-palette-02.tif" );
+
+    {
+        typedef rgb16_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test14.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-palette-04.tif	73x43 16-entry colormapped image
+BOOST_AUTO_TEST_CASE( sixteen_entry_colormapped_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-palette-04.tif" );
+
+    {
+        typedef rgb16_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test15.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-palette-08.tif	73x43 256-entry colormapped image
+BOOST_AUTO_TEST_CASE( twohundred_twenty_five_entry_colormapped_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-palette-08.tif" );
+
+    {
+        typedef rgb16_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test16.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-palette-16.tif	73x43 65536-entry colormapped image
+BOOST_AUTO_TEST_CASE( sixtyfive_thousand_entry_colormapped_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-palette-16.tif" );
+
+    {
+        typedef rgb16_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test17.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-rgb-contig-02.tif	73x43 2-bit contiguous RGB image
+BOOST_AUTO_TEST_CASE( two_bit_contiguous_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-contig-02.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 2, 2, 2, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test18.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-rgb-contig-04.tif	73x43 4-bit contiguous RGB image
+BOOST_AUTO_TEST_CASE( four_bit_contiguous_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-contig-04.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 4, 4, 4, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test19.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-rgb-contig-08.tif	73x43 8-bit contiguous RGB image
+BOOST_AUTO_TEST_CASE( eight_bit_contiguous_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-contig-08.tif" );
+
+    {
+        typedef rgb8_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test20.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-rgb-contig-10.tif	73x43 10-bit contiguous RGB image
+BOOST_AUTO_TEST_CASE( ten_bit_contiguous_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-contig-10.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 10, 10, 10, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test21.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-rgb-contig-12.tif	73x43 12-bit contiguous RGB image
+BOOST_AUTO_TEST_CASE( twelve_bit_contiguous_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-contig-12.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 12, 12, 12, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test22.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-rgb-contig-14.tif	73x43 14-bit contiguous RGB image
+BOOST_AUTO_TEST_CASE( fourteen_bit_contiguous_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-contig-14.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 14, 14, 14, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test23.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-rgb-contig-16.tif	73x43 16-bit contiguous RGB image
+BOOST_AUTO_TEST_CASE( sixteen_bit_contiguous_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-contig-16.tif" );
+
+    {
+        typedef rgb16_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test24.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-rgb-contig-24.tif	73x43 24-bit contiguous RGB image
+BOOST_AUTO_TEST_CASE( twenty_four_bit_contiguous_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-contig-24.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 24, 24, 24, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test25.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-rgb-contig-32.tif	73x43 32-bit contiguous RGB image
+BOOST_AUTO_TEST_CASE( thirty_two_bit_contiguous_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-contig-32.tif" );
+
+    {
+        typedef rgb32_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test26.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-rgb-planar-02.tif	73x43 2-bit seperated RGB image
+BOOST_AUTO_TEST_CASE( two_bit_seperated_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-planar-02.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 2, 2, 2, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test27.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+    }
+}
+
+// flower-rgb-planar-04.tif	73x43 4-bit seperated RGB image
+BOOST_AUTO_TEST_CASE( four_bit_seperated_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-planar-04.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 4, 4, 4, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test28.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+    }
+}
+
+// flower-rgb-planar-08.tif	73x43 8-bit seperated RGB image
+BOOST_AUTO_TEST_CASE( eight_bit_seperated_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-planar-08.tif" );
+
+    {
+        typedef rgb8_planar_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test29.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+    }
+}
+
+// flower-rgb-planar-10.tif	73x43 10-bit seperated RGB image
+BOOST_AUTO_TEST_CASE( ten_bit_seperated_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-planar-10.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 10, 10, 10, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test30.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+    }
+}
+
+// flower-rgb-planar-12.tif	73x43 12-bit seperated RGB image
+BOOST_AUTO_TEST_CASE( twelve_bit_seperated_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-planar-12.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 12, 12, 12, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test31.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+    }
+}
+
+// flower-rgb-planar-14.tif	73x43 14-bit seperated RGB image
+BOOST_AUTO_TEST_CASE( fourteen_bit_seperated_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-planar-14.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 14, 14, 14, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test32.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+    }
+}
+
+// flower-rgb-planar-16.tif	73x43 16-bit seperated RGB image
+BOOST_AUTO_TEST_CASE( sixteen_bit_seperated_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-planar-16.tif" );
+
+    {
+        typedef rgb16_planar_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test33.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+    }
+}
+
+// flower-rgb-planar-24.tif	73x43 24-bit seperated RGB image
+BOOST_AUTO_TEST_CASE( twenty_four_bit_seperated_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-planar-24.tif" );
+
+    {
+        typedef bit_aligned_image3_type< 24, 24, 24, rgb_layout_t >::type image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test34.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+    }
+}
+
+// flower-rgb-planar-32.tif	73x43 32-bit seperated RGB image
+BOOST_AUTO_TEST_CASE( thirty_two_bit_seperated_RGB_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-rgb-planar-32.tif" );
+
+    {
+        typedef rgb32_planar_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test35.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+    }
+}
+
+// flower-separated-contig-08.tif	73x43 8-bit contiguous CMYK image
+BOOST_AUTO_TEST_CASE( eight_bit_contiguous_CMYK_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-separated-contig-08.tif" );
+
+    {
+        typedef cmyk8_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test36.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-separated-contig-16.tif	73x43 16-bit contiguous CMYK image
+BOOST_AUTO_TEST_CASE( sixteen_bit_contiguous_CMYK_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-separated-contig-16.tif" );
+
+    {
+        typedef cmyk16_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test37.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+        test_tiff_scanline_reader< image_t >( filename );
+    }
+}
+
+// flower-separated-planar-08.tif	73x43 8-bit separated CMYK image
+BOOST_AUTO_TEST_CASE( eight_bit_separated_CMYK_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-separated-planar-08.tif" );
+
+    {
+        typedef cmyk8_planar_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test38.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+    }
+}
+
+// flower-separated-planar-16.tif	73x43 16-bit separated CMYK image
+BOOST_AUTO_TEST_CASE( sixteen_bit_separated_CMYK_image_test )
+{
+    std::string filename( tiff_in + "libtiffpic/depth/flower-separated-planar-16.tif" );
+
+    {
+        typedef cmyk16_planar_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test39.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( tiger_separated_strip_contig_08 )
+{
+    std::string filename( tiff_in_GM + "tiger-separated-strip-contig-08.tif" );
+
+    {
+        typedef cmyk8_planar_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test40.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+
+    }
+}
+
+BOOST_AUTO_TEST_CASE( tiger_separated_strip_contig_16 )
+{
+    std::string filename( tiff_in_GM + "tiger-separated-strip-contig-16.tif" );
+
+    {
+        typedef cmyk16_planar_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test41.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( tiger_separated_strip_planar_08 )
+{
+    std::string filename( tiff_in_GM + "tiger-separated-strip-planar-08.tif" );
+
+    {
+        typedef cmyk8_planar_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test42.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( tiger_separated_strip_planar_16 )
+{
+    std::string filename( tiff_in_GM + "tiger-separated-strip-planar-16.tif" );
+
+    {
+        typedef cmyk16_planar_image_t image_t;
+        image_t img;
+
+        read_image( filename
+                  , img
+                  , tag_t()
+                  );
+
+        write_view( tiff_out + "test43.tif"
+                  , view( img )
+                  , tiff_tag()
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_old_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_old_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,101 @@
+/**************************************************
+ *
+ * This test file will only test the old library's
+ * interface. It's more of a compile time test
+ * than a runtime test.
+ *
+ **************************************************/
+
+//#define BOOST_TEST_MODULE tiff_old_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/tiff_io_old.hpp>
+
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_AUTO_TEST_CASE( old_read_dimensions_test )
+{
+    {
+        point2< ptrdiff_t > dim = tiff_read_dimensions( tiff_filename );
+
+        BOOST_CHECK_EQUAL( dim.x, 200 );
+        BOOST_CHECK_EQUAL( dim.y, 133 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_image_test )
+{
+    {
+        rgb8_image_t img;
+        tiff_read_image( tiff_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 200 );
+        BOOST_CHECK_EQUAL( img.height(), 133 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        tiff_read_and_convert_image( tiff_filename, img );
+
+        BOOST_CHECK_EQUAL( img.width() , 200 );
+        BOOST_CHECK_EQUAL( img.height(), 133 );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_view_test )
+{
+    {
+        rgb8_image_t img( 200, 133 );
+        tiff_read_view( tiff_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 200, 133 );
+        tiff_read_and_convert_view( tiff_filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_write_view_test )
+{
+    {
+        string filename( tiff_out + "tiff_test_old.tif" );
+
+        gray8_image_t img( 320, 240 );
+        tiff_write_view( filename, view( img ) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( old_dynamic_image_test )
+{
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , gray1_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    tiff_read_image( tiff_filename.c_str()
+                   , runtime_image
+                   );
+
+    tiff_write_view( tiff_out + "old_dynamic_image_test.tif"
+                   , view( runtime_image )
+                   );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_subimage_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_subimage_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,108 @@
+//#define BOOST_TEST_MODULE tiff_subimage_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/extension/io_new/tiff_all.hpp>
+
+#include <fstream>
+#include <sstream>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+#include "subimage_test.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+typedef tiff_tag tag_t;
+
+#include <boost/preprocessor/cat.hpp>
+#include <boost/preprocessor/stringize.hpp>
+#include <boost/preprocessor/tuple/elem.hpp>
+#include <boost/preprocessor/comparison/less.hpp>
+#include <boost/preprocessor/repetition/repeat_from_to.hpp>
+#define GENERATE_SUBIMAGE_TEST(z, n, data)\
+    BOOST_AUTO_TEST_CASE( BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_CAT(subimage_test,data),n), bit_bit_aligned) )\
+    { \
+      using namespace std; \
+      using namespace boost; \
+      using namespace gil; \
+      string filename_strip( tiff_in_GM + "tiger-" + BOOST_PP_STRINGIZE(data) + "-strip-" ); \
+      string filename_tile ( tiff_in_GM + "tiger-" + BOOST_PP_STRINGIZE(data) + "-tile-"  ); \
+      string padding(""); \
+      if(BOOST_PP_LESS(n, 10)==1) \
+        padding = "0"; \
+      filename_strip = filename_strip + padding + BOOST_PP_STRINGIZE(n) + ".tif"; \
+      filename_tile  = filename_tile  + padding + BOOST_PP_STRINGIZE(n) + ".tif"; \
+      bit_aligned_image1_type< n, gray_layout_t >::type img1, img2, img3; \
+      point_t top_left( 10, 10 ); \
+      point_t dim( 32, 32 ); \
+      image_read_settings< tag_t > settings( top_left, dim ); \
+      read_image( filename_strip, img1, settings ); \
+      read_image( filename_tile, img2 , settings ); \
+      read_image( filename_strip, img3, tag_t() ); \
+      BOOST_CHECK( equal_pixels( const_view( img1 ), const_view( img2 ))); \
+      BOOST_CHECK( equal_pixels( const_view( img1 ), subimage_view( view( img3 ), top_left, dim ))); \
+    } \
+
+BOOST_AUTO_TEST_SUITE( tiff_subimage_test )
+
+BOOST_PP_REPEAT_FROM_TO(  1,  8, GENERATE_SUBIMAGE_TEST, minisblack )
+BOOST_PP_REPEAT_FROM_TO(  9, 16, GENERATE_SUBIMAGE_TEST, minisblack )
+BOOST_PP_REPEAT_FROM_TO( 17, 27, GENERATE_SUBIMAGE_TEST, minisblack )
+// @todo: there is a bug somewhere when the number of bits is 27 up to 31.
+
+
+BOOST_AUTO_TEST_CASE( subimage_test_8 )
+{
+    gray8_image_t img1, img2, img3;
+
+    point_t top_left( 10, 10 );
+    point_t dim( 32, 32 );
+
+    image_read_settings< tag_t > settings( top_left, dim );
+
+    read_image( tiff_in_GM + "tiger-minisblack-strip-08.tif", img1, settings );
+    read_image( tiff_in_GM + "tiger-minisblack-tile-08.tif" , img2, settings );
+    read_image( tiff_in_GM + "tiger-minisblack-strip-08.tif", img3, tag_t()  );
+    
+    BOOST_CHECK( equal_pixels( const_view( img1 ), const_view( img2 )));
+    BOOST_CHECK( equal_pixels( const_view( img1 ), subimage_view( view( img3 ), top_left, dim )));
+}
+
+BOOST_AUTO_TEST_CASE( subimage_test_16 )
+{
+    gray16_image_t img1, img2, img3;
+
+    point_t top_left( 10, 10 );
+    point_t dim( 32, 32 );
+
+    image_read_settings< tag_t > settings( top_left, dim );
+
+    read_image( tiff_in_GM + "tiger-minisblack-strip-16.tif", img1, settings );
+    read_image( tiff_in_GM + "tiger-minisblack-tile-16.tif" , img2, settings );
+    read_image( tiff_in_GM + "tiger-minisblack-strip-16.tif", img3, tag_t()  );
+    
+    BOOST_CHECK( equal_pixels( const_view( img1 ), const_view( img2 )));
+    BOOST_CHECK( equal_pixels( const_view( img1 ), subimage_view( view( img3 ), top_left, dim )));
+}
+
+BOOST_AUTO_TEST_CASE( subimage_test_32 )
+{
+    typedef pixel< unsigned int, gray_layout_t > gray32_pixel_t;
+    image< gray32_pixel_t, false > img1, img2, img3;
+
+    point_t top_left( 10, 10 );
+    point_t dim( 32, 32 );
+
+    image_read_settings< tag_t > settings( top_left, dim );
+
+    read_image( tiff_in_GM + "tiger-minisblack-strip-32.tif", img1, settings );
+    read_image( tiff_in_GM + "tiger-minisblack-tile-32.tif" , img2, settings );
+    read_image( tiff_in_GM + "tiger-minisblack-strip-32.tif", img3, tag_t()  );
+    
+    BOOST_CHECK( equal_pixels( const_view( img1 ), const_view( img2 )));
+    BOOST_CHECK( equal_pixels( const_view( img1 ), subimage_view( view( img3 ), top_left, dim )));
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,359 @@
+
+/**************************************************
+ *
+ * This test file will only test the library's
+ * interface. It's more of a compile time test
+ * than a runtime test.
+ *
+ **************************************************/
+
+//#define BOOST_TEST_MODULE tiff_test_module
+#include <boost/test/unit_test.hpp>
+
+#define BOOST_GIL_IO_ADD_FS_PATH_SUPPORT
+#define BOOST_FILESYSTEM_VERSION 3
+#include <boost/filesystem/convenience.hpp>
+
+#include <boost/gil/extension/io_new/tiff_all.hpp>
+
+#include <fstream>
+#include <sstream>
+
+#include "mandel_view.hpp"
+#include "paths.hpp"
+#include "subimage_test.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+namespace fs = boost::filesystem;
+
+typedef tiff_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_AUTO_TEST_CASE( read_image_info_test )
+{
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( tiff_filename
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 200u );
+        BOOST_CHECK_EQUAL( backend._info._height, 133u );
+    }
+
+    {
+        ifstream in( tiff_filename.c_str(), ios::binary );
+
+        typedef get_reader_backend< ifstream
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( in
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._width , 200u );
+        BOOST_CHECK_EQUAL( backend._info._height, 133u );
+    }
+
+    {
+        TIFF* file = TIFFOpen( tiff_filename.c_str(), "r" );
+
+        typedef get_reader_backend< FILE*
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( file
+                                           , tag_t()
+                                           );
+                                           
+        BOOST_CHECK_EQUAL( backend._info._width , 200u );
+        BOOST_CHECK_EQUAL( backend._info._height, 133u );
+    }
+
+    {
+        fs::path my_path( tiff_filename );
+
+        typedef get_reader_backend< fs::path
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( my_path
+                                           , tag_t()
+                                           );
+
+
+        BOOST_CHECK_EQUAL( backend._info._width , 200u );
+        BOOST_CHECK_EQUAL( backend._info._height, 133u );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_image( tiff_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 200u );
+        BOOST_CHECK_EQUAL( img.height(), 133u );
+    }
+
+    {
+
+        ifstream in( tiff_filename.c_str(), ios::binary );
+
+        rgb8_image_t img;
+        read_image( in, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 200u );
+        BOOST_CHECK_EQUAL( img.height(), 133u );
+    }
+
+    {
+        TIFF* file = TIFFOpen( tiff_filename.c_str(), "r" );
+
+        rgb8_image_t img;
+        read_image( file, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 200u );
+        BOOST_CHECK_EQUAL( img.height(), 133u );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_image_test )
+{
+    {
+        rgb8_image_t img;
+        read_and_convert_image( tiff_filename, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 200u );
+        BOOST_CHECK_EQUAL( img.height(), 133u );
+    }
+
+    {
+        ifstream in( tiff_filename.c_str(), ios::binary );
+
+        rgb8_image_t img;
+        read_and_convert_image( in, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 200u );
+        BOOST_CHECK_EQUAL( img.height(), 133u );
+    }
+
+    {
+        TIFF* file = TIFFOpen( tiff_filename.c_str(), "r" );
+
+        rgb8_image_t img;
+        read_and_convert_image( file, img, tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 200u );
+        BOOST_CHECK_EQUAL( img.height(), 133u );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_image_test_2 )
+{
+    gray8_image_t img;
+    read_and_convert_image( tiff_filename, img, tag_t() );
+
+    rgb8_image_t img2;
+    read_image( tiff_filename, img2, tag_t() );
+
+
+    BOOST_CHECK( equal_pixels( const_view( img )
+                             , color_converted_view< gray8_pixel_t>( const_view( img2 ) )
+                             )
+               );
+}
+
+BOOST_AUTO_TEST_CASE( read_view_test )
+{
+    {
+        rgb8_image_t img( 200, 133 );
+        read_view( tiff_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( tiff_filename.c_str(), ios::binary );
+
+        rgb8_image_t img( 200, 133 );
+        read_view( in, view( img ), tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 200u );
+        BOOST_CHECK_EQUAL( img.height(), 133u );
+    }
+
+    {
+        TIFF* file = TIFFOpen( tiff_filename.c_str(), "r" );
+
+        rgb8_image_t img( 200, 133 );
+        read_view( file, view( img ), tag_t() );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( read_and_convert_view_test )
+{
+    {
+        rgb8_image_t img( 200, 133 );
+        read_and_convert_view( tiff_filename, view( img ), tag_t() );
+    }
+
+    {
+        ifstream in( tiff_filename.c_str(), ios::binary );
+
+        rgb8_image_t img( 200, 133 );
+        read_and_convert_view( in, view( img ), tag_t() );
+
+        BOOST_CHECK_EQUAL( img.width() , 200u );
+        BOOST_CHECK_EQUAL( img.height(), 133u );
+    }
+
+    {
+        TIFF* file = TIFFOpen( tiff_filename.c_str(), "r" );
+
+        rgb8_image_t img( 200, 133 );
+        read_and_convert_view( file, view( img ), tag_t() );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( write_view_test )
+{
+    rgb8_image_t img( 320, 240 );
+
+    {
+        string filename( tiff_out + "write_test_string.tif" );
+
+        write_view( filename
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( tiff_out + "write_test_ofstream.tif" );
+        ofstream out( filename.c_str(), ios_base::binary );
+
+        write_view( out
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( tiff_out + "write_test_tiff.tif" );
+        TIFF* file = TIFFOpen( filename.c_str(), "w" );
+        
+        write_view( file
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , tag_t()
+                  );
+    }
+
+    {
+        string filename( tiff_out + "write_test_info.tif" );
+
+        image_write_info< tiff_tag > info;
+        write_view( filename
+                  , create_mandel_view( 320, 240
+                                      , rgb8_pixel_t( 0,   0, 255 )
+                                      , rgb8_pixel_t( 0, 255,   0 )
+                                      )
+                  , info
+                  );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( stream_test )
+{
+    // 1. Read an image.
+    ifstream in( tiff_filename.c_str(), ios::binary );
+
+    rgb8_image_t img;
+    read_image( in, img, tag_t() );
+
+    // 2. Write image to in-memory buffer.
+    stringstream out_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    write_view( out_buffer, view( img ), tag_t() );
+
+    // 3. Copy in-memory buffer to another.
+    stringstream in_buffer( ios_base::in | ios_base::out | ios_base::binary );
+    in_buffer << out_buffer.rdbuf();
+
+    // 4. Read in-memory buffer to gil image
+    rgb8_image_t dst;
+    read_image( in_buffer, dst, tag_t() );
+
+    // 5. Write out image.
+    string filename( tiff_out + "stream_test.tif" );
+    ofstream out( filename.c_str(), ios_base::binary );
+    write_view( out, view( dst ), tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( stream_test_2 )
+{
+    filebuf in_buf;
+    if( !in_buf.open( tiff_filename.c_str(), ios::in | ios::binary ) )
+    {
+        BOOST_CHECK( false );
+    }
+
+    istream in( &in_buf );
+
+    rgb8_image_t img;
+    read_image( in, img, tag_t() );
+}
+
+BOOST_AUTO_TEST_CASE( subimage_test )
+{
+    run_subimage_test< rgb8_image_t, tag_t >( tiff_filename
+                                            , point_t(  0,  0 )
+                                            , point_t( 50, 50 )
+                                            );
+
+    run_subimage_test< rgb8_image_t, tag_t >( tiff_filename
+                                            , point_t(  50,  50 )
+                                            , point_t(  50,  50 )
+                                            );
+}
+
+BOOST_AUTO_TEST_CASE( dynamic_image_test )
+{
+    // This test has been disabled for now because of 
+    // compilation issues with MSVC10.
+
+    typedef mpl::vector< gray8_image_t
+                       , gray16_image_t
+                       , rgb8_image_t
+                       , gray1_image_t
+                       > my_img_types;
+
+
+    any_image< my_img_types > runtime_image;
+
+    read_image( tiff_filename.c_str()
+              , runtime_image
+              , tag_t()
+              );
+
+    write_view( tiff_out + "dynamic_image_test.tif"
+              , view( runtime_image )
+              , tag_t()
+              );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_float_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_float_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,99 @@
+/********************************************************
+ *
+ * This test file will test float tiled tiff reading
+ *
+ *******************************************************/
+
+//#define BOOST_TEST_MODULE tiff_tiled_float_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/extension/io_new/tiff_all.hpp>
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+typedef tiff_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_AUTO_TEST_CASE( read_minisblack_float_tile_and_strip32 )
+{
+    std::string filename_strip( tiff_in_GM + "tiger-minisblack-float-strip-32.tif" );
+    std::string filename_tile ( tiff_in_GM + "tiger-minisblack-float-tile-32.tif"  );
+
+    gray32f_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_CASE( read_minisblack_float_tile_and_strip64 )
+{
+    std::string filename_strip( tiff_in_GM + "tiger-minisblack-float-strip-64.tif" );
+    std::string filename_tile ( tiff_in_GM + "tiger-minisblack-float-tile-64.tif"  );
+
+    gray64f_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_CASE( read_rgb_float_tile_and_strip_planar32 )
+{
+    std::string filename_strip( tiff_in_GM + "tiger-rgb-float-strip-planar-32.tif" );
+    std::string filename_tile ( tiff_in_GM + "tiger-rgb-float-tile-planar-32.tif"  );
+
+    rgb32f_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_CASE( read_rgb_float_tile_and_strip_contig32 )
+{
+    std::string filename_strip( tiff_in_GM + "tiger-rgb-float-strip-contig-32.tif" );
+    std::string filename_tile ( tiff_in_GM + "tiger-rgb-float-tile-contig-32.tif"  );
+
+    rgb32f_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_CASE( read_rgb_float_tile_and_strip64 )
+{
+    std::string filename_strip( tiff_in_GM + "tiger-rgb-float-strip-planar-64.tif" );
+    std::string filename_tile ( tiff_in_GM + "tiger-rgb-float-tile-planar-64.tif"  );
+
+    rgb64f_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_CASE( read_rgb_float_tile_and_strip_contig64 )
+{
+    std::string filename_strip( tiff_in_GM + "tiger-rgb-float-strip-contig-64.tif" );
+    std::string filename_tile ( tiff_in_GM + "tiger-rgb-float-tile-contig-64.tif"  );
+
+    rgb64f_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_test_1-10.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_test_1-10.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,34 @@
+/********************************************************
+ *
+ * This test file will test gray tiled tiff reading
+ *
+ *******************************************************/
+
+//#define BOOST_TEST_MODULE tiff_tiled_miniblack_test_1_10_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_read_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO( 1,  8, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_MINISBLACK, minisblack )
+BOOST_PP_REPEAT_FROM_TO( 9, 11, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_MINISBLACK, minisblack )
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_minisblack_strip_8 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-minisblack-strip-08.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-minisblack-tile-08.tif"  );
+
+    gray8_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_test_11-20.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_test_11-20.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,35 @@
+/********************************************************
+ *
+ * This test file will test gray tiled tiff writing
+ *
+ *******************************************************/
+
+//#define BOOST_TEST_MODULE tiff_tiled_miniblack_test_11_20_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/cstdint.hpp>
+#include "tiff_tiled_read_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(11, 16, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_MINISBLACK, minisblack )
+BOOST_PP_REPEAT_FROM_TO(17, 21, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_MINISBLACK, minisblack )
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_minisblack_strip_16 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-minisblack-strip-16.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-minisblack-tile-16.tif"  );
+
+    gray16_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_test_21-31_32-64.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_test_21-31_32-64.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,53 @@
+/********************************************************
+ *
+ * This test file will test gray tiled tiff reading
+ *
+ *******************************************************/
+
+//#define BOOST_TEST_MODULE tiff_tiled_miniblack_test_21_31_32_64_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/cstdint.hpp>
+#include "tiff_tiled_read_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(21, 32, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_MINISBLACK, minisblack )
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_minisblack_strip_32 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-minisblack-strip-32.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-minisblack-tile-32.tif"  );
+
+    typedef pixel< unsigned int, gray_layout_t > gray32_pixel_t;
+    image< gray32_pixel_t, false > img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_minisblack_strip_64 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-minisblack-strip-64.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-minisblack-tile-64.tif"  );
+
+    typedef pixel< uint64_t, gray_layout_t > gray64_pixel_t;
+    image< gray64_pixel_t, false > img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_write_test_1-10.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_write_test_1-10.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,40 @@
+/********************************************************
+ *
+ * This test file will test gray tiled tiff writing
+ *
+ *******************************************************/
+
+//#define BOOST_TEST_MODULE tiff_tiled_miniblack_write_test_1_10_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_write_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(1, 8 , GENERATE_WRITE_TILE_BIT_ALIGNED_MINISBLACK, minisblack )
+BOOST_PP_REPEAT_FROM_TO(9, 11, GENERATE_WRITE_TILE_BIT_ALIGNED_MINISBLACK, minisblack )
+
+BOOST_AUTO_TEST_CASE( write_minisblack_tile_and_compare_with_8 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-minisblack-strip-08.tif" );
+
+    gray8_image_t img_strip, img_saved;
+
+    read_image( filename_strip, img_strip, tag_t() );
+
+    image_write_info<tag_t> info;
+
+    info._is_tiled = true;
+    info._tile_width = info._tile_length = 16;
+
+    write_view( tiff_out + "write_minisblack_tile_and_compare_with_8.tif", view(img_strip), info );
+    read_image( tiff_out + "write_minisblack_tile_and_compare_with_8.tif", img_saved, tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_saved) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_write_test_11-20.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_write_test_11-20.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,38 @@
+/********************************************************
+ *
+ * This test file will test gray tiled tiff writing
+ *
+ *******************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_miniblack_write_test_11_20_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_write_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(11, 16, GENERATE_WRITE_TILE_BIT_ALIGNED_MINISBLACK, minisblack )
+BOOST_PP_REPEAT_FROM_TO(17, 21, GENERATE_WRITE_TILE_BIT_ALIGNED_MINISBLACK, minisblack )
+
+BOOST_AUTO_TEST_CASE( write_minisblack_tile_and_compare_with_16 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-minisblack-strip-16.tif" );
+
+    gray16_image_t img_strip, img_saved;
+
+    read_image( filename_strip, img_strip, tag_t() );
+
+    image_write_info<tag_t> info;
+
+    info._is_tiled = true;
+    info._tile_width = info._tile_length = 16;
+
+    write_view( tiff_out + "write_minisblack_tile_and_compare_with_16.tif", view(img_strip), info );
+    read_image( tiff_out + "write_minisblack_tile_and_compare_with_16.tif", img_saved, tag_t() );
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_saved) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_write_test_21-31_32-64.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_minisblack_write_test_21-31_32-64.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,62 @@
+/********************************************************
+ *
+ * This test file will test gray tiled tiff writing
+ *
+ *******************************************************/
+
+//#define BOOST_TEST_MODULE tiff_tiled_miniblack_write_test_21_31_32_64_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_write_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(21, 32, GENERATE_WRITE_TILE_BIT_ALIGNED_MINISBLACK, minisblack )
+
+BOOST_AUTO_TEST_CASE( write_tile_and_compare_with_minisblack_strip_32 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-minisblack-strip-32.tif" );
+
+    typedef pixel< unsigned int, gray_layout_t > gray32_pixel_t;
+    image< gray32_pixel_t, false > img_strip, img_saved;
+
+    read_image( filename_strip, img_strip, tag_t() );
+
+    image_write_info<tag_t> info;
+    info._is_tiled = true;
+    info._tile_width = info._tile_length = 16;
+
+    write_view( tiff_out + "write_minisblack_tile_and_compare_with_32.tif", view(img_strip), info );
+    read_image( tiff_out + "write_minisblack_tile_and_compare_with_32.tif", img_saved, tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_saved) ), true);
+}
+
+BOOST_AUTO_TEST_CASE( write_tile_and_compare_with_minisblack_strip_64 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-minisblack-strip-64.tif" );
+
+    typedef pixel< uint64_t, gray_layout_t > gray64_pixel_t;
+    image< gray64_pixel_t, false > img_strip, img_saved;
+
+    read_image( filename_strip, img_strip, tag_t() );
+
+    image_write_info<tag_t> info;
+    info._is_tiled = true;
+    info._tile_width = info._tile_length = 16;
+
+    write_view( tiff_out + "write_minisblack_tile_and_compare_with_64.tif", view(img_strip), info );
+    read_image( tiff_out + "write_minisblack_tile_and_compare_with_64.tif", img_saved, tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_saved) ), true); \
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_palette_test_1-8.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_palette_test_1-8.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,15 @@
+/********************************************************
+ *
+ * This test file will test palette tiled tiff reading
+ *
+ *******************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_palette_test_1_8_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_read_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(1, 9, GENERATE_TILE_STRIP_COMPARISON_PALETTE, palette )
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_palette_test_8-16.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_palette_test_8-16.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,16 @@
+/********************************************************
+ *
+ * This test file will test palette tiled tiff reading
+ *
+ *******************************************************/
+
+//#define BOOST_TEST_MODULE tiff_tiled_palette_test_8_16_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_read_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(9, 17, GENERATE_TILE_STRIP_COMPARISON_PALETTE, palette )
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_palette_write_test_1-8.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_palette_write_test_1-8.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,16 @@
+/********************************************************
+ *
+ * This test file will test palette tiled tiff writing
+ *
+ *******************************************************/
+
+//#define BOOST_TEST_MODULE tiff_tiled_palette_write_test_1_8_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_write_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(1, 9, GENERATE_WRITE_TILE_BIT_ALIGNED_PALETTE, palette )
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_palette_write_test_8-16.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_palette_write_test_8-16.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,16 @@
+/********************************************************
+ *
+ * This test file will test palette tiled tiff writing
+ *
+ *******************************************************/
+
+//#define BOOST_TEST_MODULE tiff_tiled_palette_write_test_8_16_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_write_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(9, 17, GENERATE_WRITE_TILE_BIT_ALIGNED_PALETTE, palette )
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_read_macros.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_read_macros.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,94 @@
+#ifndef BOOST_GIL_TIFF_TILED_READ_MACROS_HPP
+#define BOOST_GIL_TIFF_TILED_READ_MACROS_HPP
+
+#include <boost/mpl/vector.hpp>
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/tiff_read.hpp>
+
+#include "paths.hpp"
+
+#include <boost/preprocessor/cat.hpp>
+#include <boost/preprocessor/stringize.hpp>
+#include <boost/preprocessor/tuple/elem.hpp>
+#include <boost/preprocessor/comparison/less.hpp>
+#include <boost/preprocessor/repetition/repeat_from_to.hpp>
+
+typedef boost::gil::tiff_tag tag_t;
+
+#define GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_RGB(z, n, data)\
+    BOOST_AUTO_TEST_CASE( BOOST_PP_CAT( \
+                                BOOST_PP_CAT( \
+                                    BOOST_PP_CAT( \
+                                        BOOST_PP_CAT( \
+                                            BOOST_PP_CAT( read_tile_and_compare_with_ \
+                                                        , BOOST_PP_TUPLE_ELEM(2,0,data) \
+                                                        ) \
+                                                , BOOST_PP_TUPLE_ELEM(2,1,data) \
+                                                ) \
+                                            ,_strip_ \
+                                            ) \
+                                        ,n \
+                                        ) \
+                                      , bit_bit_aligned \
+                                      ) \
+                        )\
+    { \
+      using namespace std; \
+      using namespace boost; \
+      using namespace gil; \
+      string filename_strip( tiff_in_GM + "tiger-" + BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(2,0,data)) + "-strip-" + BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(2,1,data)) + "-" ); \
+      string filename_tile ( tiff_in_GM + "tiger-" + BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(2,0,data)) + "-tile-"  + BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(2,1,data)) + "-" ); \
+      string padding(""); \
+      if(BOOST_PP_LESS(n, 10)==1) \
+        padding = "0"; \
+      filename_strip = filename_strip + padding + BOOST_PP_STRINGIZE(n) + ".tif"; \
+      filename_tile  = filename_tile  + padding + BOOST_PP_STRINGIZE(n) + ".tif"; \
+      bit_aligned_image3_type< n, n, n, rgb_layout_t >::type img_strip, img_tile; \
+      read_image( filename_strip, img_strip, tag_t() ); \
+      read_image( filename_tile,  img_tile,  tag_t() ); \
+      BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true); \
+    } \
+
+// Special case for minisblack images
+#define GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_MINISBLACK(z, n, data)\
+    BOOST_AUTO_TEST_CASE( BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_CAT(read_tile_and_compare_with_,data),_strip_),n), bit_bit_aligned) )\
+    { \
+      using namespace std; \
+      using namespace boost; \
+      using namespace gil; \
+      string filename_strip( tiff_in_GM + "tiger-" + BOOST_PP_STRINGIZE(data) + "-strip-" ); \
+      string filename_tile ( tiff_in_GM + "tiger-" + BOOST_PP_STRINGIZE(data) + "-tile-"  ); \
+      string padding(""); \
+      if(BOOST_PP_LESS(n, 10)==1) \
+        padding = "0"; \
+      filename_strip = filename_strip + padding + BOOST_PP_STRINGIZE(n) + ".tif"; \
+      filename_tile  = filename_tile  + padding + BOOST_PP_STRINGIZE(n) + ".tif"; \
+      bit_aligned_image1_type< n, gray_layout_t >::type img_strip, img_tile; \
+      read_image( filename_strip, img_strip, tag_t() ); \
+      read_image( filename_tile,  img_tile,  tag_t() ); \
+      BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true); \
+    } \
+
+// Special case for palette images
+#define GENERATE_TILE_STRIP_COMPARISON_PALETTE(z, n, data)\
+    BOOST_AUTO_TEST_CASE( BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_CAT(read_tile_and_compare_with_,data),_strip_),n), bit) )\
+    { \
+      using namespace std; \
+      using namespace boost; \
+      using namespace gil; \
+      string filename_strip( tiff_in_GM + "tiger-" + BOOST_PP_STRINGIZE(data) + "-strip-" ); \
+      string filename_tile ( tiff_in_GM + "tiger-" + BOOST_PP_STRINGIZE(data) + "-tile-"  ); \
+      string padding(""); \
+      if(BOOST_PP_LESS(n, 10)==1) \
+        padding = "0"; \
+      filename_strip = filename_strip + padding + BOOST_PP_STRINGIZE(n) + ".tif"; \
+      filename_tile  = filename_tile  + padding + BOOST_PP_STRINGIZE(n) + ".tif"; \
+      rgb16_image_t img_strip, img_tile; \
+      read_image( filename_strip, img_strip, tag_t() ); \
+      read_image( filename_tile,  img_tile,  tag_t() ); \
+      BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true); \
+    } \
+
+
+
+#endif // BOOST_GIL_TIFF_TILED_READ_MACROS_HPP
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_test_1-10.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_test_1-10.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,33 @@
+/********************************************************
+ *
+ * This test file will test RGB contig tiled tiff reading
+ *
+ *******************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_rgb_contig_test_1_10_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_read_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(1,  8, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_RGB, (rgb,contig) )
+BOOST_PP_REPEAT_FROM_TO(9, 11, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_RGB, (rgb,contig) )
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_rgb_contig_strip_8 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-contig-08.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-rgb-tile-contig-08.tif"  );
+
+    rgb8_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_test_11-20.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_test_11-20.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,33 @@
+/********************************************************
+ *
+ * This test file will test RGB contig tiled tiff reading
+ *
+ *******************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_rgb_contig_test_11_20_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_read_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(11, 16, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_RGB, (rgb,contig) )
+BOOST_PP_REPEAT_FROM_TO(17, 21, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_RGB, (rgb,contig) )
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_rgb_contig_strip_16 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-contig-16.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-rgb-tile-contig-16.tif"  );
+
+    rgb16_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_test_21-31_32_64.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_test_21-31_32_64.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,51 @@
+/********************************************************
+ *
+ * This test file will test RGB contig tiled tiff reading
+ *
+ *******************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_rgb_contig_test_21_31_32_64_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_read_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(21, 32, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_RGB, (rgb,contig) )
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_rgb_contig_strip_32 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-contig-32.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-rgb-tile-contig-32.tif"  );
+
+    typedef pixel< unsigned int, rgb_layout_t > rgb32_pixel_t;
+    image< rgb32_pixel_t, false > img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_rgb_contig_strip_64 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-contig-64.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-rgb-tile-contig-64.tif"  );
+
+    typedef pixel< uint64_t, rgb_layout_t > rgb64_pixel_t;
+    image< rgb64_pixel_t, false > img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_write_test_1-10.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_write_test_1-10.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,38 @@
+/********************************************************
+ *
+ * This test file will test rgb contig tiled tiff writing
+ *
+ *******************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_rgb_contig_write_test_1_10_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_write_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(1,  8, GENERATE_WRITE_TILE_BIT_ALIGNED_RGB, rgb )
+BOOST_PP_REPEAT_FROM_TO(9, 11, GENERATE_WRITE_TILE_BIT_ALIGNED_RGB, rgb )
+
+BOOST_AUTO_TEST_CASE( write_tile_and_compare_with_rgb_strip_contig_8 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-contig-08.tif" );
+
+    rgb8_image_t img_strip, img_saved;
+
+    read_image( filename_strip, img_strip, tag_t() );
+
+    image_write_info<tag_t> info;
+    info._is_tiled = true;
+    info._tile_width = info._tile_length = 16;
+
+    write_view( tiff_out + "write_tile_and_compare_with_rgb_strip_contig_8.tif", view(img_strip), info );
+    read_image( tiff_out + "write_tile_and_compare_with_rgb_strip_contig_8.tif", img_saved, tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_saved) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_write_test_11-20.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_write_test_11-20.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,38 @@
+/********************************************************
+ *
+ * This test file will test rgb contig tiled tiff writing
+ *
+ *******************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_rgb_contig_write_test_11_20_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_write_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(11, 16, GENERATE_WRITE_TILE_BIT_ALIGNED_RGB, rgb )
+BOOST_PP_REPEAT_FROM_TO(17, 21, GENERATE_WRITE_TILE_BIT_ALIGNED_RGB, rgb )
+
+BOOST_AUTO_TEST_CASE( write_tile_and_compare_with_rgb_strip_contig_16 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-contig-16.tif" );
+
+    rgb16_image_t img_strip, img_saved;
+
+    read_image( filename_strip, img_strip, tag_t() );
+
+    image_write_info<tag_t> info;
+    info._is_tiled = true;
+    info._tile_width = info._tile_length = 16;
+
+    write_view( tiff_out + "write_tile_and_compare_with_rgb_strip_contig_16.tif", view(img_strip), info );
+    read_image( tiff_out + "write_tile_and_compare_with_rgb_strip_contig_16.tif", img_saved, tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_saved) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_write_test_21-31_32_64.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_contig_write_test_21-31_32_64.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,61 @@
+/********************************************************
+ *
+ * This test file will test rgb contig tiled tiff writing
+ *
+ *******************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_rgb_contig_write_test_21_31_32_64_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_write_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(21, 31, GENERATE_WRITE_TILE_BIT_ALIGNED_RGB, rgb )
+
+BOOST_AUTO_TEST_CASE( write_tile_and_compare_with_rgb_strip_contig_32 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-contig-32.tif" );
+
+    typedef pixel< unsigned int, rgb_layout_t > rgb32_pixel_t;
+    image< rgb32_pixel_t, false > img_strip, img_saved;
+
+    read_image( filename_strip, img_strip, tag_t() );
+
+    image_write_info<tag_t> info;
+    info._is_tiled = true;
+    info._tile_width = info._tile_length = 16;
+
+    write_view( tiff_out + "write_tile_and_compare_with_rgb_strip_contig_32.tif", view(img_strip), info );
+    read_image( tiff_out + "write_tile_and_compare_with_rgb_strip_contig_32.tif", img_saved, tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_saved) ), true);
+}
+
+BOOST_AUTO_TEST_CASE( write_tile_and_compare_with_rgb_strip_contig_64 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-contig-64.tif" );
+
+    typedef pixel< uint64_t, rgb_layout_t > rgb64_pixel_t;
+    image< rgb64_pixel_t, false > img_strip, img_saved;
+
+    read_image( filename_strip, img_strip, tag_t() );
+
+    image_write_info<tag_t> info;
+    info._is_tiled = true;
+    info._tile_width = info._tile_length = 16;
+
+    write_view( tiff_out + "write_tile_and_compare_with_rgb_strip_contig_64.tif", view(img_strip), info );
+    read_image( tiff_out + "write_tile_and_compare_with_rgb_strip_contig_64.tif", img_saved, tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_saved) ), true); \
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_planar_test_1-10.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_planar_test_1-10.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,33 @@
+/********************************************************
+ *
+ * This test file will test RGB planar tiled tiff reading
+ *
+ *******************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_rgb_planar_test_1_10_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_read_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(1,  8, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_RGB, (rgb,planar) )
+BOOST_PP_REPEAT_FROM_TO(9, 11, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_RGB, (rgb,planar) )
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_rgb_planar_strip_8 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-planar-08.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-rgb-tile-planar-08.tif"  );
+
+    rgb8_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_planar_test_11-20.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_planar_test_11-20.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,33 @@
+/********************************************************
+ *
+ * This test file will test RGB planar tiled tiff reading
+ *
+ *******************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_rgb_planar_test_11_20_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_read_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(11, 16, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_RGB, (rgb,planar) )
+BOOST_PP_REPEAT_FROM_TO(17, 21, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_RGB, (rgb,planar) )
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_rgb_planar_strip_16 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-planar-16.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-rgb-tile-planar-16.tif"  );
+
+    rgb16_image_t img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_planar_test_21-31_32_64.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_rgb_planar_test_21-31_32_64.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,51 @@
+/********************************************************
+ *
+ * This test file will test RGB planar tiled tiff reading
+ *
+ *******************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_rgb_planar_test_21_31_32_64_module
+#include <boost/test/unit_test.hpp>
+
+#include "tiff_tiled_read_macros.hpp"
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_PP_REPEAT_FROM_TO(21, 32, GENERATE_TILE_STRIP_COMPARISON_BIT_ALIGNED_RGB, (rgb,planar) )
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_rgb_planar_strip_32 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-planar-32.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-rgb-tile-planar-32.tif"  );
+
+    typedef pixel< unsigned int, rgb_layout_t > rgb32_pixel_t;
+    image< rgb32_pixel_t, false > img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_CASE( read_tile_and_compare_with_rgb_planar_strip_64 )
+{
+    using namespace std;
+    using namespace boost;
+    using namespace gil;
+
+    string filename_strip( tiff_in_GM + "tiger-rgb-strip-planar-64.tif" );
+    string filename_tile ( tiff_in_GM + "tiger-rgb-tile-planar-64.tif"  );
+
+    typedef pixel< uint64_t, rgb_layout_t > rgb64_pixel_t;
+    image< rgb64_pixel_t, false > img_strip, img_tile;
+
+    read_image( filename_strip, img_strip, tag_t() );
+    read_image( filename_tile,  img_tile,  tag_t() );
+
+    BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_tile) ), true);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,89 @@
+
+/**************************************************
+ *
+ * This test file will test tiled tiff reading
+ *
+ **************************************************/
+//#define BOOST_TEST_MODULE tiff_tiled_test_module
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/extension/io_new/tiff_read.hpp>
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+typedef tiff_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_AUTO_TEST_CASE( read_tile_infos_test )
+{
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( tiff_in_GM + "tiger-minisblack-float-tile-16.tif"
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._tile_width , 16 );
+        BOOST_CHECK_EQUAL( backend._info._tile_length, 16 );
+    }
+
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( tiff_in_GM + "tiger-minisblack-tile-08.tif"
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._tile_width , 16 );
+        BOOST_CHECK_EQUAL( backend._info._tile_length, 16 );
+    }
+
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( tiff_in_GM + "tiger-palette-tile-08.tif"
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._tile_width , 16 );
+        BOOST_CHECK_EQUAL( backend._info._tile_length, 16 );
+    }
+
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( tiff_in_GM + "tiger-rgb-tile-contig-08.tif"
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._tile_width , 16 );
+        BOOST_CHECK_EQUAL( backend._info._tile_length, 16 );
+    }
+
+    {
+        typedef get_reader_backend< const std::string
+                                  , tag_t
+                                  >::type backend_t;
+
+        backend_t backend = read_image_info( tiff_in_GM + "tiger-rgb-tile-planar-08.tif"
+                                           , tag_t()
+                                           );
+
+        BOOST_CHECK_EQUAL( backend._info._tile_width , 16 );
+        BOOST_CHECK_EQUAL( backend._info._tile_length, 16 );
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_write_macros.hpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_tiled_write_macros.hpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,91 @@
+#ifndef BOOST_GIL_TIFF_TILED_WRITE_MACROS_HPP
+#define BOOST_GIL_TIFF_TILED_WRITE_MACROS_HPP
+
+#include <boost/mpl/vector.hpp>
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/io_new/tiff_all.hpp>
+
+#include "paths.hpp"
+
+#include <boost/preprocessor/cat.hpp>
+#include <boost/preprocessor/stringize.hpp>
+#include <boost/preprocessor/tuple/elem.hpp>
+#include <boost/preprocessor/comparison/less.hpp>
+#include <boost/preprocessor/repetition/repeat_from_to.hpp>
+
+typedef boost::gil::tiff_tag tag_t;
+
+#define GENERATE_WRITE_TILE_BIT_ALIGNED_RGB(z, n, data)\
+    BOOST_AUTO_TEST_CASE( BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_CAT(write_rgb_tile_and_compare_with_,data),_strip_),n), bit_bit_aligned) )\
+    { \
+      using namespace std; \
+      using namespace boost; \
+      using namespace gil; \
+      string filename( string( "tiger-" ) + BOOST_PP_STRINGIZE(data) + "-strip-contig-" ); \
+      string path( tiff_in_GM ); \
+      string padding(""); \
+      if(BOOST_PP_LESS(n, 10)==1) \
+        padding = "0"; \
+      filename += padding + BOOST_PP_STRINGIZE(n) + ".tif"; \
+      path += filename; \
+      bit_aligned_image3_type< n, n, n, rgb_layout_t >::type img_strip, img_saved; \
+      read_image( path, img_strip, tag_t() ); \
+      image_write_info<tag_t> info; \
+      info._is_tiled = true; \
+      info._tile_width = info._tile_length = 16; \
+      write_view( tiff_out + filename, view(img_strip), info ); \
+      read_image( tiff_out + filename, img_saved, tag_t() ); \
+      BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_saved) ), true); \
+    } \
+
+// Special case for minisblack images
+#define GENERATE_WRITE_TILE_BIT_ALIGNED_MINISBLACK(z, n, data)\
+    BOOST_AUTO_TEST_CASE( BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_CAT(write_minisblack_tile_and_compare_with_,data),_strip_),n), bit_bit_aligned) )\
+    { \
+      using namespace std; \
+      using namespace boost; \
+      using namespace gil; \
+      string filename( string( "tiger-" ) + BOOST_PP_STRINGIZE(data) + "-strip-" ); \
+      string path( tiff_in_GM ); \
+      string padding(""); \
+      if(BOOST_PP_LESS(n, 10)==1) \
+        padding = "0"; \
+      filename = filename + padding + BOOST_PP_STRINGIZE(n) + ".tif"; \
+      path += filename; \
+      bit_aligned_image1_type< n, gray_layout_t >::type img_strip, img_saved; \
+      read_image( path, img_strip, tag_t() ); \
+      image_write_info<tag_t> info; \
+      info._is_tiled = true; \
+      info._tile_width = info._tile_length = 16; \
+      write_view( tiff_out + filename, view(img_strip), info ); \
+      read_image( tiff_out + filename, img_saved, tag_t() ); \
+      BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_saved) ), true); \
+    } \
+
+// Special case for palette images
+#define GENERATE_WRITE_TILE_BIT_ALIGNED_PALETTE(z, n, data)\
+    BOOST_AUTO_TEST_CASE( BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_CAT(write_palette_tile_and_compare_with_,data),_strip_),n), bit) )\
+    { \
+      using namespace std; \
+      using namespace boost; \
+      using namespace gil; \
+      string filename( string( "tiger-" ) + BOOST_PP_STRINGIZE(data) + "-strip-" ); \
+      string path( tiff_in_GM ); \
+      string padding(""); \
+      if(BOOST_PP_LESS(n, 10)==1) \
+        padding = "0"; \
+      filename = filename + padding + BOOST_PP_STRINGIZE(n) + ".tif"; \
+      path += filename; \
+      rgb16_image_t img_strip, img_saved; \
+      read_image( path, img_strip, tag_t() ); \
+      image_write_info<tag_t> info; \
+      info._is_tiled = true; \
+      info._tile_width = info._tile_length = 16; \
+      write_view( tiff_out + filename, view(img_strip), info ); \
+      read_image( tiff_out + filename, img_saved, tag_t() ); \
+      BOOST_CHECK_EQUAL( equal_pixels( const_view(img_strip), const_view(img_saved) ), true); \
+    } \
+
+
+
+#endif // BOOST_GIL_TIFF_TILED_READ_MACROS_HPP
Index: boost-1.52.0/src/libs/gil/io_new/test/tiff_write_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/test/tiff_write_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,27 @@
+
+#include <boost/test/unit_test.hpp>
+
+#include <boost/gil/gil_all.hpp>
+
+#include <boost/gil/extension/io_new/detail/typedefs.hpp>
+#include <boost/gil/extension/io_new/tiff_all.hpp>
+
+#include "color_space_write_test.hpp"
+#include "mandel_view.hpp"
+#include "paths.hpp"
+
+using namespace std;
+using namespace boost::gil;
+
+typedef tiff_tag tag_t;
+
+BOOST_AUTO_TEST_SUITE( tiff_test )
+
+BOOST_AUTO_TEST_CASE( rgb_color_space_write_test )
+{
+    color_space_write_test< tag_t >( tiff_out + "rgb_color_space_test.tif"
+                                   , tiff_out + "bgr_color_space_test.tif"
+                                   );
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/io_new/todo.txt
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/io_new/todo.txt	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,146 @@
+todo list
+
+* add planar bit_aligned image support - not so easy
+* when reading an indexed tiff image, it's better to use a virtual view.
+* incorporate Phil Endecott suggestions ( email 04/27/2008 )
+* also add John Femiani suggestions ( same date )
+
+
+* dynamic image needs to call is_allowed
+* try to test all interface functions seperately
+* make sure all fields are set in the read info structure
+* add one test file that includes all headers
+
+* there is a bug in when reading bmp that have negative height
+	- see check_coordinates()
+	- email by Joerg Gonska 05/08/2009
+
+* new tests
+	* make sure all members in all image_read_info<> are set when reading header information
+	* read and write tests using read_image and write_view
+	* all formats must have a subimage read tests
+
+
+* implement is_allowed for all types
+	* how do we do that with dynamic images???
+
+* reading p4.pnm is incorrect, reading 1bit binary pnm
+
+* add read_image_info for any_image
+
+
+* dynamic_writer don't take the settings. -FIXED- But need to wait for codes in boost/gil dynamic image extension
+
+* see libjpeg for cropping support
+
+* make sure to read all tiff properties
+
+* add a log facility for all image formats
+
+* add Kenneth Riddile targa support, see email from 12/02/2010
+
+* provide better documentation for adding new device types. 
+
+* throw boost::errinfo_file_name when file name is incorrect. Use compiler symbol for backward compatibility.
+
+* add file name to exception message
+
+* add a flag which would read an image in opposite direction. See Szymon email from 07/11/2011
+
+* add Edd Dawson's test image from jpegxx
+
+----------------------------------------------
+
+review related todo's
+
+* add some tests which read errorneous images to test error handling
+	- see Fabio Fracassi email from 12/06/2010
+	- esspecially test longjmp though different platform behavior can be tested
+
+* build and boostify the documentation
+
+Kenny review ( email from 12/06/2010 )
+* FIXED: rename read_intXX to read_uintXX, see io_device.hpp
+
+Edd review ( email from 12/06/2010 )
+* FIXED: Is there support for obtaining the real-world dimensions of a loaded
+  raster in millimetres, say? I work on CAD/graphics applications which
+  need this functionality in order to generate reasonable texture coordinates.
+  
+  * FIXED: In the case of libjpeg, the information is exposed/advertised in the jpeg_decompress_struct and jpeg_compress_struct structures. 
+    You can see how I use them here:
+    http://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/read.cpp#cl-62
+    http://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/write.cpp#cl-75
+
+  * FIXED: use the image under EddDawson/ in test_images folder
+	
+  * FIXED: In libpng, have a look in the docs for e.g. png_get_x_pixels_per_meter.
+
+* Add something similar to JPEGXX_C_LIB_COMPILED_AS_CPLUSPLUS and JPEGXX_CAN_THROW_EXCEPTIONS_ to io_new
+    * see above links and download jpegxx
+
+* Allow to open file with unicode filenames. See wfopen.
+
+* Exception safty
+   * They might not have a chance when an exception is thrown from a function that is called from C (one of the callbacks 
+     installed in jpeg_decompress_struct, for example). All (portable) bets are off in this situation, as far as I know. 
+	 This is where the boost::current_exception() suggestion comes from. You can catch and store the exception inside the 
+	 callback (as best as possible) and then rethrow it when you're safely back in C++ land.
+   * I don't actually use boost::current_exception in my code (it doesn't depend on boost at all, currently), but I do 
+     something very similar. Here, for instance:
+     http://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/read.cpp#cl-166
+
+     The exact type and behaviour of the ex_store_ object there depends on the preprocessor definitions that are present 
+	 when the library is built. See:
+     http://bitbucket.org/edd/jpegxx/src/ea2492a1a4a6/src/best_exception_store.hpp
+
+     And for the various exception_store implementations:
+     http://bitbucket.org/edd/imagexx/src/5c44e8ad57e7/include/imagexx/exceptions/
+
+
+  
+Lubomir review ( email from  ):
+* Support for reading images whose file format is unknown at compile time. That 
+  involves the ability to register file formats / backends, associate them with 
+  given extensions and then call the appropriate reader based on the extension 
+  of the filename.
+
+* Support for efficient reading/writing of parts of images that are too large to 
+  fit in memory. There are two ways to proceed: one is to have an input/output iterator 
+  that enforces sequential access, and another is to allow for user-driven access at the 
+  cost of sometimes severe performance. I'd like to hear the opinion of people who would 
+  use this more advanced options.
+
+* Support for efficient reading/writing of parts of images that are too large to fit 
+  in memory. There are two ways to proceed: one is to have an input/output iterator 
+  that enforces sequential access, and another is to allow for user-driven access at 
+  the cost of sometimes severe performance. I'd like to hear the opinion of people who 
+  would use this more advanced options.
+
+* Optional: I would like to have a GIL virtual image view associated with a given file. That would allow 
+  reading/writing to simply be copy_pixels, and reading into a different format to be copy_and_convert_pixels.
+  Reading a given ROI could simply be done by creating a subimage_view. The cool thing about this is one 
+  could in theory make changes to images without even loading them in memory. The caviat is that doing 
+  this right and efficiently is very hard, requires clever caching, plus a wrong access pattern 
+  can result in horribly bad performance.
+  
+Roland review ( email from 12/11/2010 )
+
+* There seem to be broken links:
+  * "section Extending GIL::IO with new Formats" links to index.html
+  * "Please see section Supported Image Formats." links to index.html
+  * "sections _Supported_Formats_ for more details." links to /
+
+* It would be good to have code samples for read_and_convert_image, read_view
+  and read_and_convert_view in the tutorial. The "Using IO" section seems to
+  assume that they are already documented: "As the Tutorial demonstrated there
+  are a few ways to read images."
+
+* Additionally, it would be great to have a reference section. :-)
+
+* I stumbled over a few typos and grammatically unusual sentences (IMHO):
+  * s/supoorted/supported/
+  * FIXED: "Before we can read or write image one thing." I know what that means in German, but does this make sense in English?
+  * FIXED: "If the user doesn't know what he is dealing with it can use read_and_convert_image()." s/it/he/  
+
+  
\ No newline at end of file
Index: boost-1.52.0/src/libs/gil/opencv/in/in.png
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/libs/gil/opencv/in/in.png	2012-11-09 15:21:15.000000000 +0100 differ
Index: boost-1.52.0/src/libs/gil/opencv/rgb.bmp
===================================================================
Binary files /dev/null	1970-01-01 00:00:00.000000000 +0000 and boost-1.52.0/src/libs/gil/opencv/rgb.bmp	2012-11-09 15:21:15.000000000 +0100 differ
Index: boost-1.52.0/src/libs/gil/opencv/test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,7 @@
+
+
+int main()
+{
+
+   return 0;
+}
\ No newline at end of file
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/convert_color.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/convert_color.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,57 @@
+#include "stdafx.h"
+
+#include <boost\test\unit_test.hpp>
+
+#include <boost\gil\extension\opencv\convert_color.hpp>
+
+#include <boost\gil\extension\io_new\png_all.hpp>
+
+using namespace boost::gil;
+using namespace boost::gil::opencv;
+
+BOOST_AUTO_TEST_CASE( test_convert_color )
+{
+    rgb32f_image_t src;
+    read_and_convert_image( "..\\in\\in.png", src, png_tag() ); 
+
+    xyz32f_image_t dst( src.dimensions() );
+
+    cvtcolor( view( src )
+            , view( dst )
+            );
+
+    rgb32f_image_t out( src.dimensions() );
+
+    cvtcolor( view( dst )
+            , view( out )
+            );
+
+    write_view( "..\\out\\convert_color.png"
+              , color_converted_view< rgb8_pixel_t >( view( out ))
+              , png_tag()
+              );
+}
+
+BOOST_AUTO_TEST_CASE( test_convert_color_bit_aligned )
+{
+    bgr565_image_t src;
+    rgba8_image_t dst( src.dimensions() );
+
+/*
+    // @todo: not implemented yet
+    cvtcolor( view( src )
+            , view( dst )
+            );
+*/
+}
+/*
+BOOST_AUTO_TEST_CASE( test_convert_color_using_xyz_colorspace )
+{
+    xyz32f_image_t src;
+    rgb32f_image_t dst( src.dimensions() );
+
+    cvtcolor( view( src )
+            , view( dst )
+            );
+}
+*/
\ No newline at end of file
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/convert_scale.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/convert_scale.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,38 @@
+#include "stdafx.h"
+
+#include <boost\test\unit_test.hpp>
+
+#include <boost\gil\extension\opencv\opencv_all.hpp>
+
+#include <boost\gil\extension\io_new\png_all.hpp>
+
+using namespace boost::gil;
+using namespace boost::gil::opencv;
+
+BOOST_AUTO_TEST_CASE( test_convert_scale )
+{
+    rgb32f_image_t src( 640, 480 );
+    fill_pixels( view( src ), rgb32f_pixel_t( 1000.0, 0.0, 34.0 ) );
+
+    rgb16_image_t dst( view( src ).dimensions() );
+
+    convert_scale( view( src )
+                 , view( dst )
+                 );
+
+    write_view( "..\\out\\convert_scale.png", view( dst ), png_tag() );
+}
+
+BOOST_AUTO_TEST_CASE( test_convert_scale_abs )
+{
+    rgb32f_image_t src( 640, 480 );
+    fill_pixels( view( src ), rgb32f_pixel_t( 1000.0, 0.0, 34.0 ) );
+
+    rgb8_image_t dst( view( src ).dimensions() );
+
+    convert_scale( view( src )
+                 , view( dst )
+                 );
+
+    write_view( "..\\out\\convert_scale_abs.png", view( dst ), png_tag() );
+}
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/drawing_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/drawing_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,170 @@
+#include "stdafx.h"
+
+#include <boost\function.hpp>
+
+#include <boost\test\unit_test.hpp>
+
+#include <boost\gil\extension\opencv\drawing.hpp>
+
+#include <boost\gil\extension\io_new\png_write.hpp>
+
+using namespace boost::gil;
+using namespace boost::gil::opencv;
+
+template< typename Color
+        , typename Line_Type
+        >
+struct draw_rectangle
+{
+    draw_rectangle( const boost::gil::opencv::point_t& start
+                  , const boost::gil::opencv::point_t& end
+                  , const Color&                       color
+                  , std::size_t                        thickness
+                  , const Line_Type&                   line_type )
+    : _start( start )
+    , _end  ( end   )
+    , _color( color )
+    , _thickness( thickness )
+    , _line_type( line_type )
+    {}
+
+    void operator() ( ipl_image_wrapper img )
+    {
+        drawRectangle( img
+                     , _start
+                     , _end
+                     , _color
+                     , _thickness
+                     , _line_type  );
+    }
+
+    const boost::gil::opencv::point_t _start;
+    const boost::gil::opencv::point_t _end;
+
+    const Color _color;
+
+    const std::size_t _thickness;
+
+    const Line_Type _line_type;
+};
+
+template< typename View >
+struct draw
+{
+    typedef boost::function< void ( ipl_image_wrapper ) > operation_t;
+    typedef std::vector< operation_t > operation_vec_t;
+    operation_vec_t operations;
+
+    void add( operation_t op )
+    {
+        operations.push_back( op );
+    }
+
+    void operator()( View v )
+    {
+        ipl_image_wrapper ipl_img = create_ipl_image( v );
+
+        operation_vec_t::const_iterator it  = operations.begin();
+        operation_vec_t::const_iterator end = operations.end();
+        
+        for( ; it != end ; ++it )
+        {
+            const operation_t& o = *it;
+            o( ipl_img );
+        }
+    }
+};
+
+
+BOOST_AUTO_TEST_CASE( test_draw_rectangle )
+{
+    rgb8_image_t img( 640, 480 );
+
+    fill_pixels( view( img ), rgb8_pixel_t( 0, 0, 0 ));
+
+    typedef boost::function< void (ipl_image_wrapper) > operation_t;
+
+/*
+    draw< rgb8_view_t > d;
+    d.add( draw_rectangle< rgb8_pixel_t
+                         , four_connected_line
+                         >( boost::gil::opencv::point_t( 300, 200 )
+                         , boost::gil::opencv::point_t( 240, 100 )
+                         , rgb8_pixel_t( 245, 100, 33 )
+                         , 2
+                         , four_connected_line()
+                         ) );
+
+
+    d.add( draw_rectangle< rgb8_pixel_t
+                                  , four_connected_line
+                                  >( boost::gil::opencv::point_t( 10, 10 )
+                                   , boost::gil::opencv::point_t( 500, 100 )
+                                   , rgb8_pixel_t( 245, 100, 33 )
+                                   , cv_fill::type::value
+                                   , four_connected_line()
+                                   ) );
+    d( view( img ));
+*/
+
+
+    drawCircle( view( img )
+              , boost::gil::opencv::point_t( 250, 400 )
+              , 75
+              , rgb8_pixel_t( 0, 100, 88 )
+              , 10
+              , cv_aa()
+              );
+
+    drawLine( view( img )
+            , boost::gil::opencv::point_t( 400, 400 )
+            , boost::gil::opencv::point_t( 300, 200 )
+            , rgb8_pixel_t( 245, 100, 33 )
+            , 1
+            , eight_connected_line()
+            );
+
+    drawEllipse( view( img )
+               , boost::gil::opencv::point_t( 400, 400 ) // center
+               , boost::gil::opencv::point_t( 50, 40 ) // axes
+               , 185
+               , 20
+               , 90
+               , rgb8_pixel_t( 25, 10, 88 )
+               , 25
+               , eight_connected_line()
+               );
+
+    curve_t c;
+    c.push_back( boost::gil::opencv::point_t( 10,10 ));
+    c.push_back( boost::gil::opencv::point_t( 10,100 ));
+    c.push_back( boost::gil::opencv::point_t( 100,100 ));
+    c.push_back( boost::gil::opencv::point_t( 100,10 ));
+
+    curve_t c2;
+    c2.push_back( boost::gil::opencv::point_t( 300,300 ));
+    c2.push_back( boost::gil::opencv::point_t( 300,330 ));
+    c2.push_back( boost::gil::opencv::point_t( 330,330 ));
+    c2.push_back( boost::gil::opencv::point_t( 330,300 ));
+    c2.push_back( boost::gil::opencv::point_t( 450,310 ));
+    
+    curve_vec_t cv;
+    cv.push_back( c );
+    cv.push_back( c2 );
+/*
+    drawPolyLine( view( img )
+                , cv
+                , true
+                , rgb8_pixel_t( 245, 100, 33 )
+                , 2
+                , eight_connected_line()
+                );
+*/
+    drawFillPoly( view( img )
+                , cv
+                , rgb8_pixel_t( 245, 100, 33 )
+                , cv_aa()
+                );
+
+    write_view( "..\\out\\rectangle.png", view( img ), png_tag() );
+}
\ No newline at end of file
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/edge_detection.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/edge_detection.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,113 @@
+#include "stdafx.h"
+
+#include <boost\test\unit_test.hpp>
+
+#include <boost\gil\extension\opencv\edge_detection.hpp>
+
+#include <boost\gil\extension\io_new\png_all.hpp>
+
+using namespace boost::gil;
+using namespace boost::gil::opencv;
+
+BOOST_AUTO_TEST_CASE( test_sobel )
+{
+    gray8_image_t src;
+    read_and_convert_image( "..\\in\\in.png", src, png_tag() ); 
+
+    gray8_image_t dst( view( src ).dimensions() );
+
+    sobel( view( src )
+         , view( dst )
+         , aperture3()
+         );
+
+    write_view( "..\\out\\sobel.png", view( dst ), png_tag() );
+}
+
+BOOST_AUTO_TEST_CASE( test_laplace )
+{
+    rgb8_image_t src;
+    read_image( "..\\in\\in.png", src, png_tag() ); 
+
+    rgb32f_image_t dst( view( src ).dimensions() );
+
+    laplace( view( src )
+           , view( dst )
+           , aperture3()
+           );
+
+    write_view( "..\\out\\laplace.png"
+              , color_converted_view< rgb8_pixel_t >( view( dst ))
+              , png_tag()
+              );
+}
+
+BOOST_AUTO_TEST_CASE( test_canny )
+{
+    gray8_image_t src;
+    read_and_convert_image( "..\\in\\in.png", src, png_tag() ); 
+
+    gray8_image_t edges( view( src ).dimensions() );
+
+    canny( view( src   )
+         , view( edges )
+         , 60
+         , 180
+         , aperture3()
+         );
+
+    write_view( "..\\out\\canny.png", view( edges ), png_tag() );
+}
+
+BOOST_AUTO_TEST_CASE( test_pre_corner_detect )
+{
+    gray8_image_t src;
+    read_and_convert_image( "..\\in\\in.png", src, png_tag() ); 
+
+    gray32f_image_t corners( view( src ).dimensions() );
+
+    precorner_detect( view( src     )
+                    , view( corners )
+                    , aperture3()
+                    );
+
+    write_view( "..\\out\\precorner_detect.png"
+              , color_converted_view< rgb8_pixel_t >( view( corners ))
+              , png_tag()
+              );
+
+    // try this for testing
+    /*
+    // assume that the image is floating-point
+    IplImage* corners = cvCloneImage(image);
+    IplImage* dilated_corners = cvCloneImage(image);
+    IplImage* corner_mask = cvCreateImage( cvGetSize(image), 8, 1 );
+    cvPreCornerDetect( image, corners, 3 );
+    cvDilate( corners, dilated_corners, 0, 1 );
+    cvSubS( corners, dilated_corners, corners );
+    cvCmpS( corners, 0, corner_mask, CV_CMP_GE );
+    cvReleaseImage( &corners );
+    cvReleaseImage( &dilated_corners );
+    */
+}
+
+BOOST_AUTO_TEST_CASE( test_corner_eigen_vals_and_vecs )
+{
+    gray8_image_t src;
+    read_and_convert_image( "..\\in\\in.png", src, png_tag() ); 
+
+    gray32f_image_t eigen( view( src ).dimensions().x * 6
+                       , view( src ).dimensions().y
+                       );
+
+    corner_eigen_vals_and_vecs( view( src   )
+                              , view( eigen )
+                              , 3
+                              , aperture3()
+                              );
+
+    write_view( "..\\out\\corner_eigen_vals_and_vecs.png"
+              , color_converted_view< rgb8_pixel_t >( view( eigen ))
+              , png_tag()
+              );
+}
\ No newline at end of file
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/geometry_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/geometry_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,39 @@
+#include "stdafx.h"
+
+#include <boost\test\unit_test.hpp>
+
+#include <geometry\geometry.hpp>
+
+
+#include <boost\gil\extension\io_new\png_all.hpp>
+
+using namespace boost;
+using namespace gil;
+//using namespace boost::gil::opencv;
+
+template< typename Geometry, typename View >
+struct draw {};
+
+template< typename View, typename Point >
+struct draw< geometry::box< Point >, View > { static void d() {} };
+
+
+
+BOOST_AUTO_TEST_CASE( test_geometry )
+{
+	typedef geometry::point_xy<double> P;
+
+	geometry::box< P > b( P( 10, 10 )
+	                    , P( 35, 70 )
+	                    );
+
+    rgb8_image_t img;
+    int i;
+    //draw( i, view( img ) );
+
+    draw< geometry::box< P >, double >::d();
+    
+
+
+    //write_view( "..\\out\\geometry.png", view( dst ), png_tag() );
+}
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/ipl_image_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/ipl_image_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,44 @@
+#include "stdafx.h"
+
+#include <boost\test\unit_test.hpp>
+
+#include <boost\gil\extension\opencv\ipl_image_wrapper.hpp>
+
+#include <boost\gil\extension\io_new\png_write.hpp>
+
+using namespace boost::gil;
+using namespace boost::gil::opencv;
+
+BOOST_AUTO_TEST_CASE( test_ipl_image )
+{
+    rgb8_image_t img( 640, 480 );
+    fill_pixels( view( img ), rgb8_pixel_t( 255, 255, 255 ) );
+
+    ipl_image_wrapper ipl_img = create_ipl_image( view( img ));
+
+    IplImage* ipl_img_p = ipl_img.get();
+
+    rgb8_view_t v = interleaved_view( 640, 480
+                                    , (rgb8_pixel_t*) ipl_img_p->imageData
+                                    , 640 * 3
+                                    );
+
+    write_view( "..\\out\\ipl_image.png"
+              , v
+              , png_tag()
+              );
+
+    return;
+}
+
+BOOST_AUTO_TEST_CASE( test_value_semantics )
+{
+    rgb8_image_t img( 640, 480 );
+    fill_pixels( view( img ), rgb8_pixel_t( 255, 255, 255 ) );
+
+    ipl_image_wrapper ipl_img = create_ipl_image( view( img ));
+
+    ipl_image_wrapper ipl_img_2( ipl_img );
+
+    return;
+}
\ No newline at end of file
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/resize.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/resize.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,70 @@
+#include "stdafx.h"
+
+#include <boost\test\unit_test.hpp>
+
+#include <boost\gil\extension\opencv\resize.hpp>
+
+#include <boost\gil\extension\io_new\png_all.hpp>
+
+using namespace boost::gil;
+using namespace boost::gil::opencv;
+
+BOOST_AUTO_TEST_CASE( test_resize_nn )
+{
+    rgb8_image_t src;
+//    read_image( "..\\in\\in.png", src, png_tag() ); 
+
+    rgb8_image_t dst( 640, 480 );
+
+    resize( view( src )
+          , view( dst )
+          , nearest_neigbor()
+          );
+
+    write_view( "..\\out\\resize_nearest_neighbor.png", view( dst ), png_tag() );
+}
+
+BOOST_AUTO_TEST_CASE( test_resize_linear )
+{
+    rgb8_image_t src;
+//    read_image( "..\\in\\in.png", src, png_tag() ); 
+
+    rgb8_image_t dst( 640, 480 );
+
+    resize( view( src )
+          , view( dst )
+          , bilinear()
+          );
+
+    write_view( "..\\out\\resize_linear.png", view( dst ), png_tag() );
+}
+
+BOOST_AUTO_TEST_CASE( test_resize_area )
+{
+    rgb8_image_t src;
+//    read_image( "..\\in\\in.png", src, png_tag() ); 
+
+    rgb8_image_t dst( 640, 480 );
+
+    resize( view( src )
+          , view( dst )
+          , area()
+          );
+
+    write_view( "..\\out\\resize_area.png", view( dst ), png_tag() );
+}
+
+BOOST_AUTO_TEST_CASE( test_resize_bicubic )
+{
+    rgb8_image_t src;
+//    read_image( "..\\in\\in.png", src, png_tag() ); 
+
+    rgb8_image_t dst( 640, 480 );
+
+    resize( view( src )
+          , view( dst )
+          , bicubic()
+          );
+
+    write_view( "..\\out\\resize_bicubic.png", view( dst ), png_tag() );
+}
\ No newline at end of file
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/smooth.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/smooth.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,25 @@
+#include "stdafx.h"
+
+#include <boost\test\unit_test.hpp>
+
+#include <boost\gil\extension\opencv\smooth.hpp>
+
+#include <boost\gil\extension\io_new\png_all.hpp>
+
+using namespace boost::gil;
+using namespace boost::gil::opencv;
+
+BOOST_AUTO_TEST_CASE( test_smooth_gaussian )
+{
+    rgb8_image_t src;
+    read_image( "..\\in\\in.png", src, png_tag() ); 
+
+    rgb8_image_t dst( view( src ).dimensions() );
+
+    smooth( view( src )
+          , view( src )
+          , gaussian()
+          );
+
+    write_view( "..\\out\\smooth_gaussian.png", view( dst ), png_tag() );
+}
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/stdafx.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/stdafx.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,8 @@
+// stdafx.cpp : source file that includes just the standard includes
+// unit_test.pch will be the pre-compiled header
+// stdafx.obj will contain the pre-compiled type information
+
+#include "stdafx.h"
+
+// TODO: reference any additional headers you need in STDAFX.H
+// and not in this file
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/stdafx.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/stdafx.h	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,21 @@
+// stdafx.h : include file for standard system include files,
+// or project specific include files that are used frequently, but
+// are changed infrequently
+//
+
+#pragma once
+
+#ifndef _WIN32_WINNT		// Allow use of features specific to Windows XP or later.                   
+#define _WIN32_WINNT 0x0501	// Change this to the appropriate value to target other versions of Windows.
+#endif						
+
+#include <stdio.h>
+#include <tchar.h>
+
+#include <cmath>
+#include <cstdlib>
+
+#include <boost/shared_ptr.hpp>
+
+#include <boost\gil\gil_all.hpp>
+#include <boost\gil\extension\io_new\png_write.hpp>
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/text.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/text.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,45 @@
+#include "stdafx.h"
+
+#include <boost\test\unit_test.hpp>
+
+#include <boost\gil\extension\opencv\text.hpp>
+
+#include <boost\gil\extension\io_new\png_all.hpp>
+
+using namespace boost::gil;
+using namespace boost::gil::opencv;
+
+BOOST_AUTO_TEST_CASE( test_text )
+{
+    rgb8_image_t src;
+    read_image( "..\\in\\in.png", src, png_tag() ); 
+
+    ipl_font_wrapper font = create_ipl_font( font_hershey_plain()
+                                           , 1
+                                           , 1
+                                           , four_connected_line()
+                                           );
+
+    putText( view( src )
+           , std::string( "Hello World!" )
+           , boost::gil::opencv::point_t( 10,100 )
+           , font
+           , rgb8_pixel_t( 0, 100, 88 )
+           );
+
+
+    boost::gil::opencv::point_t size;
+    int                         baseline;
+    getTextSize( std::string( "Hello World!" )
+               , font
+               , size
+               , baseline
+               );
+
+    BOOST_CHECK_EQUAL( size.x  , 96 );
+    BOOST_CHECK_EQUAL( size.y  , 10 );
+    BOOST_CHECK_EQUAL( baseline,  5 );
+
+    write_view( "..\\out\\text.png", view( src ), png_tag() );
+}
+
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/unit_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/unit_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,8 @@
+// unit_test.cpp : Defines the entry point for the console application.
+//
+
+#include "stdafx.h"
+
+#define BOOST_TEST_MAIN
+#include <boost/test/unit_test.hpp>
+
Index: boost-1.52.0/src/libs/gil/opencv/unit_test/unit_test.vcproj
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/opencv/unit_test/unit_test.vcproj	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,229 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="unit_test"
+	ProjectGUID="{0E577D41-BBAC-426E-B1B5-D11098FAB452}"
+	RootNamespace="unit_test"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="c:\boost;C:\gil\gil_2;C:\Program Files\GnuWin32\include;C:\Program Files\OpenCV\cv\include\;C:\Program Files\OpenCV\cxcore\include;C:\chh\geometry_library_preview_3\"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_SCL_SECURE_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="cv.lib cxcore.lib libpngd.lib zlibd.lib"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="C:\boost\stage\lib;C:\Program Files\OpenCV\lib;C:\gil\image libs\debug"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="c:\boost;C:\gil\gil_2;C:\Program Files\OpenCV\cv\include\;C:\Program Files\OpenCV\cxcore\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_SCL_SECURE_NO_WARNINGS;_CRT_SECURE_NO_WARNINGS"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="cv.lib cxcore.lib libpngd.lib zlibd.lib"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="C:\boost\stage\lib;C:\Program Files\OpenCV\lib;C:\gil\image libs\debug"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\convert_color.cpp"
+			>
+		</File>
+		<File
+			RelativePath=".\convert_scale.cpp"
+			>
+		</File>
+		<File
+			RelativePath=".\drawing_test.cpp"
+			>
+		</File>
+		<File
+			RelativePath=".\edge_detection.cpp"
+			>
+		</File>
+		<File
+			RelativePath=".\geometry_test.cpp"
+			>
+		</File>
+		<File
+			RelativePath=".\ipl_image_test.cpp"
+			>
+		</File>
+		<File
+			RelativePath=".\resize.cpp"
+			>
+		</File>
+		<File
+			RelativePath=".\smooth.cpp"
+			>
+		</File>
+		<File
+			RelativePath=".\stdafx.cpp"
+			>
+		</File>
+		<File
+			RelativePath=".\stdafx.h"
+			>
+		</File>
+		<File
+			RelativePath=".\text.cpp"
+			>
+		</File>
+		<File
+			RelativePath=".\unit_test.cpp"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
Index: boost-1.52.0/src/libs/gil/sdl/example/display_image/display_image.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/sdl/example/display_image/display_image.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,59 @@
+#include <boost/shared_ptr.hpp>
+
+#include <boost/gil/gil_all.hpp>
+
+#include <boost/gil/extension/io/bmp_io.hpp>
+#include <boost/gil/extension/sdl/sdl_wrapper.hpp>
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+using namespace sdl;
+
+struct my_redraw_handler
+{
+   my_redraw_handler( rgb8_view_t v )
+   : _view( v ) {}
+
+   void redraw( const bgra8_view_t& sdl_view )
+   {
+      copy_pixels( color_converted_view<bgra8_pixel_t>( _view )
+                 , sdl_view                                     );
+   }
+
+private:
+
+   rgb8_view_t _view;
+};
+
+int main( int argc, char* argv[] )
+{
+   // load the image
+   rgb8_image_t img;
+   bmp_read_image( "..\\..\\flower.bmp", img );
+
+
+   // define window type
+   typedef sdl_window< sdl::detail::default_keyboard_event_handler
+                     , my_redraw_handler
+                     > window_t;
+
+   typedef shared_ptr< window_t > window_ptr_t;
+
+   // create redraw handler
+   typedef shared_ptr< my_redraw_handler > rh_ptr_t;
+   rh_ptr_t rh_ptr( new my_redraw_handler( view( img ) ));
+
+
+   // create window
+   window_ptr_t win( new window_t( view( img ).width()
+                                 , view( img ).height() 
+                                 , rh_ptr ));
+
+   // create service and let's roll
+   sdl_service ss;
+   ss.add_window( win );
+   ss.run();
+
+	return 0;
+}
Index: boost-1.52.0/src/libs/gil/sdl/example/keyboard_events/keyboard_events.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/sdl/example/keyboard_events/keyboard_events.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,104 @@
+#include <boost/random.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include <boost/gil/gil_all.hpp>
+
+#include <boost/gil/extension/io/bmp_io.hpp>
+#include <boost/gil/extension/sdl/sdl_wrapper.hpp>
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+using namespace sdl;
+
+class my_keyboard_event_handler
+{
+public:
+
+   my_keyboard_event_handler()
+   : _color( 0, 0, 0 )
+   , _range( 0, 255 )
+   , _die( _random_generator, _range )
+   {}
+
+   bool key_up()
+   {
+      get_color( _color, red_t()   ) = _die();
+      get_color( _color, green_t() ) = _die();
+      get_color( _color, blue_t()  ) = _die();
+
+      fill_pixels( _view
+                 , _color );
+
+      // true for redraw
+      return true;
+   }
+
+   void set_img( rgb8_view_t v )
+   {
+      _view = v;
+   }
+
+private:
+
+   rgb8_view_t _view;
+   rgb8_pixel_t _color;
+
+   mt19937        _random_generator;
+   uniform_int<>  _range;
+
+   variate_generator< mt19937&
+                    , uniform_int<>
+                    > _die;
+
+};
+
+struct my_redraw_handler
+{
+   my_redraw_handler( rgb8_view_t v )
+   : _view( v ) {}
+
+   void redraw( const bgra8_view_t& sdl_view )
+   {
+      copy_pixels( color_converted_view<bgra8_pixel_t>( _view )
+                 , sdl_view                                     );
+   }
+
+private:
+
+   rgb8_view_t _view;
+};
+
+int main( int argc, char* argv[] )
+{
+   // create black image
+   rgb8_image_t img( 640, 480 );
+   fill_pixels( view( img ), rgb8_pixel_t( 0, 0, 0 ));
+
+   // define window type
+   typedef sdl_window< my_keyboard_event_handler
+                     , my_redraw_handler
+                     > window_t;
+
+   typedef shared_ptr< window_t > window_ptr_t;
+
+   // create redraw handler
+   typedef shared_ptr< my_redraw_handler > rh_ptr_t;
+   rh_ptr_t rh_ptr( new my_redraw_handler( view( img ) ));
+
+
+   // create window
+   window_ptr_t win( new window_t( view( img ).width()
+                                 , view( img ).height() 
+                                 , rh_ptr ));
+
+   // set the image in the keyboard handler
+   win->my_keyboard_event_handler::set_img( view( img ));
+
+   // create service and let's roll
+   sdl_service ss;
+   ss.add_window( win );
+   ss.run();
+
+	return 0;
+}
Index: boost-1.52.0/src/libs/gil/sdl/example/plasma/plasma.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/sdl/example/plasma/plasma.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,172 @@
+// plasma.cpp : Defines the entry point for the console application.
+//
+
+#include <iostream>
+#include <tchar.h>
+
+#include "boost/gil/gil_all.hpp"
+
+#include "boost/gil/extension/sdl/sdl_wrapper.hpp"
+#include "boost/gil/extension/toolbox/hsv.hpp"
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+using namespace sdl;
+
+typedef point2<ptrdiff_t> point_t;
+
+// taken from http://student.kuleuven.be/~m0216922/CG/plasma.html
+
+inline float plasma_func( float x, float y )
+{
+   return (   128.f + ( 128.f * sin( x / 16.f ))
+            + 128.f + ( 128.f * sin( y / 8.f  ))
+            + 128.f + ( 128.f * sin((x + y) / 16.f ))
+            + 128.f + ( 128.f * sin( sqrt( float( x * x + y * y )) / 8.f ))
+        ) / 4.f;
+}
+
+struct create_palette
+{
+   create_palette()
+   : _step( 1 / 256.f )
+   , _current_value( 0.f )
+   {}
+
+   void operator()( bgra8_pixel_t& p )
+   {
+      color_convert( hsv32f_pixel_t( _current_value, 1.f, 1.f ), p );
+
+      _current_value += _step;
+   }
+
+private:
+
+   float _step;
+   float _current_value;
+};
+
+struct my_redraw_event_handler
+{
+   my_redraw_event_handler( const bgra8_view_t& v )
+   : _view( v )
+   {
+   }
+
+   void redraw( const bgra8_view_t& sdl_view )
+   {
+      copy_pixels( _view
+                 , sdl_view );
+   }
+
+private:
+
+   bgra8_view_t _view;
+};
+
+class my_timer_handler
+{
+public:
+
+   my_timer_handler()
+   : _step( 0 )
+   , _palette( 256, 1 )
+   , _view_palette( view( _palette ))
+   , _buffer()
+   , _view_buffer( view( _buffer ))
+   , _counter( 0 )
+   {
+      for_each_pixel( _view_palette, create_palette() );
+   }
+
+   bool time_elapsed()
+   {
+      for( int y = 0; y < _view.height(); ++y )
+      {
+         bgra8_view_t::x_iterator x_it = _view.row_begin( y );
+
+         for( int x = 0; x < _view.width(); ++x, ++x_it )
+         {
+            bits8 index = at_c<0>( _view_buffer( x, y ) );
+
+            index += _step;
+            if( index >= 256 ) index -= 256;
+
+            *x_it = _view_palette( index, 0 );
+         }
+      }
+
+      _step++;
+
+      // true for redraw
+      return true;
+   }
+
+   void set_img( bgra8_view_t v )
+   {
+      _view = v;
+
+      _buffer.recreate( _view.dimensions() );
+      _view_buffer = view( _buffer );
+
+      for( int y = 0; y < _view_buffer.height(); ++y )
+      {
+         gray8_view_t::x_iterator x_it = _view_buffer.row_begin( y );
+
+         for( int x = 0; x < _view_buffer.width(); ++x, ++x_it )
+         {
+            *x_it = static_cast<bits8>( plasma_func( x, y ));
+         }
+      }
+   }
+
+private:
+
+   bits8 _step;
+
+   bgra8_view_t _view;
+
+   bgra8_image_t _palette;
+   bgra8_view_t  _view_palette;
+
+   gray8_image_t _buffer;
+   gray8_view_t  _view_buffer;
+
+   unsigned int _counter;
+};
+
+int _tmain(int argc, _TCHAR* argv[])
+{
+   point_t dims(640,480);
+
+   bgra8_image_t img( dims );
+   fill_pixels( view( img )
+              , bgra8_pixel_t( 0, 0, 0, 0 ));
+
+
+   sdl_service ss;
+
+   typedef sdl_window< sdl::detail::default_keyboard_event_handler
+                     , my_redraw_event_handler
+                     , my_timer_handler
+                     > window_t;
+
+   typedef shared_ptr< window_t > window_ptr_t;
+
+   typedef shared_ptr< my_redraw_event_handler > rh_ptr_t;
+   rh_ptr_t rh_ptr( new my_redraw_event_handler( view( img ) ));
+
+   window_ptr_t win( new window_t( dims.x
+                                 , dims.y
+                                 , rh_ptr ));
+
+   win->my_timer_handler::set_img( view( img ));
+   win->set_timer( 20 );
+
+
+   ss.add_window( win );
+   ss.run();
+
+	return 0;
+}
Index: boost-1.52.0/src/libs/gil/sdl/example/simplest/simplest.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/sdl/example/simplest/simplest.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,26 @@
+#include <boost/shared_ptr.hpp>
+
+#include <boost/gil/gil_all.hpp>
+
+#include <boost/gil/extension/io/bmp_io.hpp>
+#include <boost/gil/extension/sdl/sdl_wrapper.hpp>
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+using namespace sdl;
+
+int main( int argc, char* argv[] )
+{
+    typedef sdl_window<> window_t;
+    typedef shared_ptr< window_t > window_ptr_t;
+
+    window_ptr_t win( new window_t( 640
+                             , 480 ));
+
+    sdl_service ss;
+    ss.add_window( win );
+    ss.run();
+
+    return 0;
+}
Index: boost-1.52.0/src/libs/gil/sdl/example/timer_event/timer_event.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/sdl/example/timer_event/timer_event.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,109 @@
+#include <boost/random.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include <boost/gil/gil_all.hpp>
+
+#include <boost/gil/extension/io/bmp_io.hpp>
+#include <boost/gil/extension/sdl/sdl_wrapper.hpp>
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+using namespace sdl;
+
+class my_timer_handler
+{
+public:
+
+   my_timer_handler()
+   : _color( 0, 0, 0 )
+   , _range( 0, 255 )
+   , _die( _random_generator, _range )
+   {}
+
+   bool time_elapsed()
+   {
+      get_color( _color, red_t()   ) = _die();
+      get_color( _color, green_t() ) = _die();
+      get_color( _color, blue_t()  ) = _die();
+
+      fill_pixels( _view
+                 , _color );
+
+      // true for redraw
+      return true;
+   }
+
+   void set_img( rgb8_view_t v )
+   {
+      _view = v;
+   }
+
+private:
+
+   rgb8_view_t _view;
+   rgb8_pixel_t _color;
+
+   mt19937        _random_generator;
+   uniform_int<>  _range;
+
+   variate_generator< mt19937&
+                    , uniform_int<>
+                    > _die;
+
+};
+
+struct my_redraw_handler
+{
+   my_redraw_handler( rgb8_view_t v )
+   : _view( v ) {}
+
+   void redraw( const bgra8_view_t& sdl_view )
+   {
+      copy_pixels( color_converted_view<bgra8_pixel_t>( _view )
+                 , sdl_view                                     );
+
+      std::cout << "redraw" << std::endl;
+   }
+
+private:
+
+   rgb8_view_t _view;
+};
+
+int main( int argc, char* argv[] )
+{
+   sdl_service ss;
+
+   // create black image
+   rgb8_image_t img( 640, 480 );
+   fill_pixels( view( img ), rgb8_pixel_t( 0, 0, 0 ));
+
+   // define window type
+   typedef sdl_window< sdl::detail::default_keyboard_event_handler
+                     , my_redraw_handler
+                     , my_timer_handler
+                     > window_t;
+
+   typedef shared_ptr< window_t > window_ptr_t;
+
+   // create redraw handler
+   typedef shared_ptr< my_redraw_handler > rh_ptr_t;
+   rh_ptr_t rh_ptr( new my_redraw_handler( view( img ) ));
+
+
+   // create window
+   window_ptr_t win( new window_t( view( img ).width()
+                                 , view( img ).height() 
+                                 , rh_ptr ));
+
+   // set the image and clock the timer
+   win->my_timer_handler::set_img( view( img ));
+   win->set_timer( 100 );
+
+   // create service and let's roll
+   ss.add_window( win );
+   ss.run();
+
+	return 0;
+}
Index: boost-1.52.0/src/libs/gil/toolbox/test/hsl_hsv_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/toolbox/test/hsl_hsv_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,104 @@
+// Copyright 2012 Christian Henning
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/// \brief Unit test for hsl and hsv color spaces 
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/toolbox/hsl.hpp>
+#include <boost/gil/extension/toolbox/hsv.hpp>
+
+#include <boost/test/unit_test.hpp>
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+BOOST_AUTO_TEST_SUITE( hsl_hsv_test_suite )
+
+BOOST_AUTO_TEST_CASE( hsl_hsv_test )
+{
+   {
+      gray32f_pixel_t g( 1.f );
+
+      float red_1 = channel_convert< bits32f >( 1.f );
+      float red_2 = channel_convert< bits32f >( (bits32f) 1.f );
+
+      int i = 9;
+   }
+
+
+   {
+      rgb8_pixel_t p( 128, 0, 128 );
+
+      hsl32f_pixel_t h;
+
+      color_convert( p, h );
+      color_convert( h, p );
+
+      int i = 9;
+   }
+
+   {
+      size_t width  = 640;
+      size_t height = 480;
+
+      hsl32f_image_t hsl_img( width, height );
+      hsv32f_image_t hsv_img( width, height );
+
+      for( size_t y = 0; y < height; y++ )
+      {
+         hsl32f_view_t::x_iterator hsl_x_it = view( hsl_img ).row_begin( y );
+         hsv32f_view_t::x_iterator hsv_x_it = view( hsv_img ).row_begin( y );
+
+         float v = static_cast<float>( height -  y ) 
+                 / height;
+
+         for( size_t x = 0; x < width; x++ )
+         {
+            float hue = ( x + 1.f ) / width;
+
+            hsl_x_it[x] = hsl32f_pixel_t( hue, 1.0, v );
+            hsv_x_it[x] = hsv32f_pixel_t( hue, 1.0, v );
+         }
+      }
+
+      //bmp_write_view( ".\\hsl_test.bmp"
+      //              , color_converted_view<rgb8_pixel_t>( color_converted_view<rgb32f_pixel_t>( view( hsl_img ))));
+
+      //bmp_write_view( ".\\hsv_test.bmp"
+      //              , color_converted_view<rgb8_pixel_t>( color_converted_view<rgb32f_pixel_t>( view( hsv_img ))));
+   }
+
+
+   {
+      rgb8_image_t rgb_img;
+      //bmp_read_image( ".\\flower.bmp", rgb_img );
+
+      hsl32f_image_t hsl_img( view( rgb_img ).dimensions() );
+
+      copy_pixels( color_converted_view<hsl32f_pixel_t>( view( rgb_img ))
+                 , view( hsl_img ));
+
+      //bmp_write_view( ".\\flower_hsl.bmp"
+      //              , color_converted_view<rgb8_pixel_t>(view( rgb_img )));
+      
+   }
+
+   {
+      rgb8_image_t rgb_img;
+      //bmp_read_image( ".\\flower.bmp", rgb_img );
+
+      hsv32f_image_t hsv_img( view( rgb_img ).dimensions() );
+
+      copy_pixels( color_converted_view<hsv32f_pixel_t>( view( rgb_img ))
+                 , view( hsv_img ));
+
+      //bmp_write_view( ".\\flower_hsv.bmp"
+      //              , color_converted_view<rgb8_pixel_t>(view( rgb_img )));
+      
+   }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/toolbox/test/indexed_image_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/toolbox/test/indexed_image_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,115 @@
+// Copyright 2012 Christian Henning
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/// \brief Unit test for indexed_image type.
+
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/toolbox/indexed_image.hpp>
+
+#include <boost/test/unit_test.hpp>
+
+using namespace std;
+using namespace boost;
+using namespace gil;
+
+
+BOOST_AUTO_TEST_SUITE( index_image_test_suite )
+
+BOOST_AUTO_TEST_CASE( index_image_test )
+{
+    {
+        indexed_image< uint8_t, rgb8_pixel_t > img( 640, 480 );
+        fill_pixels( view( img ), rgb8_pixel_t( 255, 0, 0 ));
+
+        rgb8_pixel_t p = *view( img ).xy_at( 10, 10 );
+    }
+
+    {
+
+        indexed_image< gray8_pixel_t, rgb8_pixel_t > img( 640, 480, 256 );
+
+        generate_pixels( img.get_indices_view()
+                       , [] () -> uint8_t
+                       {
+                            static int i = -1;
+                            i = ( i == 256 ) ? 0 : ++i;
+
+                            return gray8_pixel_t( i );
+                       }
+                       );
+
+
+        generate_pixels( img.get_palette_view()
+                       , [] () ->rgb8_pixel_t
+                       {
+                          static int i = -1;
+                          i = ( i == 256 ) ? 0 : ++i;
+
+                          return rgb8_pixel_t( i, i, i );
+                       }
+                       );
+
+        int i = ( 640 * 10 + 10 ) % 256;
+
+        gray8_pixel_t index = *img.get_indices_view().xy_at( 10   , 1 );
+        rgb8_pixel_t  color = *img.get_palette_view().xy_at( index, 0 );
+
+        rgb8_pixel_t p = *view( img ).xy_at( 10, 1 );
+
+        i = 9;
+    }
+
+    {
+        indexed_image< uint8_t, rgb8_pixel_t > img( 640, 480, 256 );
+
+        generate_pixels( img.get_indices_view()
+                       , [] () -> uint8_t
+                       {
+                            static int i = -1;
+                            i = ( i == 256 ) ? 0 : ++i;
+
+                            return i;
+                       }
+                       );
+
+
+        generate_pixels( img.get_palette_view()
+                       , [] () ->rgb8_pixel_t
+                       {
+                          static int i = -1;
+                          i = ( i == 256 ) ? 0 : ++i;
+
+                          return rgb8_pixel_t( i, i, i );
+                       }
+                       );
+
+        int i = ( 640 * 10 + 10 ) % 256;
+
+        uint8_t      index = *img.get_indices_view().xy_at( 10   , 1 );
+        rgb8_pixel_t color = *img.get_palette_view().xy_at( index, 0 );
+
+        rgb8_pixel_t p = *view( img ).xy_at( 10, 1 );
+
+        i = 9;
+    }
+
+    {
+        typedef indexed_image< uint8_t, rgb8_pixel_t > image_t;
+        image_t img( 640, 480, 256 );
+
+        for( int y=0; y < view( img ).height(); ++y )
+        {
+            image_t::view_t::x_iterator it = view( img ).row_begin( y );
+
+            for( int x = 0; x < view( img ).width(); ++x )
+            {
+                rgb8_pixel_t p = *it;
+                it++;
+            }
+        }
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/toolbox/test/lab_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/toolbox/test/lab_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,182 @@
+// Copyright 2012 Davide Anastasia
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/// \file lab_test.cpp
+/// \brief Unit test for LAB Colorspace
+/// \author Davide Anastasia <davideanastasia@users.sourceforge.net>
+
+#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE LABColorSpaceTest
+
+#include <boost/test/unit_test.hpp>
+
+#define TEST_CHECK_CLOSE(a, b) \
+    BOOST_CHECK_CLOSE(a, b, 0.0005f)
+
+#include <iostream>
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/toolbox/lab.hpp>
+
+using namespace boost;
+
+BOOST_AUTO_TEST_SUITE(Lab_to_XYZ)
+
+BOOST_AUTO_TEST_CASE(Lab_to_XYZ_Test1)
+{
+    gil::lab32f_pixel_t lab_pixel(40.366198, 53.354489, 26.117702);
+    gil::xyz32f_pixel_t xyz_pixel;
+
+    gil::color_convert(lab_pixel, xyz_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(xyz_pixel[0]), 0.197823f);
+    TEST_CHECK_CLOSE(static_cast<float>(xyz_pixel[1]), 0.114731f);
+    TEST_CHECK_CLOSE(static_cast<float>(xyz_pixel[2]), 0.048848f);
+}
+
+BOOST_AUTO_TEST_CASE(Lab_to_XYZ_Test2)
+{
+    gil::lab32f_pixel_t lab_pixel(50, 0, 0);
+    gil::xyz32f_pixel_t xyz_pixel;
+
+    gil::color_convert(lab_pixel, xyz_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(xyz_pixel[0]), 0.175064f);
+    TEST_CHECK_CLOSE(static_cast<float>(xyz_pixel[1]), 0.184187f);
+    TEST_CHECK_CLOSE(static_cast<float>(xyz_pixel[2]), 0.200548f);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
+
+BOOST_AUTO_TEST_SUITE(XYZ_to_Lab)
+
+BOOST_AUTO_TEST_CASE(XYZ_to_Lab_Test1)
+{
+    gil::lab32f_pixel_t lab_pixel;
+    gil::xyz32f_pixel_t xyz_pixel(0.085703f, 0.064716f, 0.147082f);
+
+    gil::color_convert(xyz_pixel, lab_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[0]), 30.572438f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[1]), 23.4674f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[2]), -22.322275f);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
+
+BOOST_AUTO_TEST_SUITE(RGB_to_Lab)
+
+BOOST_AUTO_TEST_CASE(RGB_to_Lab_Test1)
+{
+    gil::rgb32f_pixel_t rgb_pixel(0.75f, 0.5f, 0.25f);
+    gil::lab32f_pixel_t lab_pixel;
+
+    gil::color_convert(rgb_pixel, lab_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[0]), 58.7767f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[1]), 18.5851f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[2]), 43.7975f);
+}
+
+BOOST_AUTO_TEST_CASE(RGB_to_Lab_Test2)
+{
+    gil::rgb32f_pixel_t rgb_pixel(1.f, 0.f, 0.f);
+    gil::lab32f_pixel_t lab_pixel;
+
+    gil::color_convert(rgb_pixel, lab_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[0]), 53.2408f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[1]), 80.0925f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[2]), 67.2032f);
+}
+
+BOOST_AUTO_TEST_CASE(RGB_to_Lab_Test3)
+{
+    gil::rgb32f_pixel_t rgb_pixel(0.f, 1.f, 0.f);
+    gil::lab32f_pixel_t lab_pixel;
+
+    gil::color_convert(rgb_pixel, lab_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[0]), 87.7347f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[1]), -86.1827f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[2]), 83.1793f);
+}
+
+BOOST_AUTO_TEST_CASE(RGB_to_Lab_Test4)
+{
+    gil::rgb32f_pixel_t rgb_pixel(0.f, 0.f, 1.f);
+    gil::lab32f_pixel_t lab_pixel;
+
+    gil::color_convert(rgb_pixel, lab_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[0]), 32.2970f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[1]), 79.1875f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[2]), -107.8602f);
+}
+
+BOOST_AUTO_TEST_CASE(RGB_to_Lab_Test5)
+{
+    gil::rgb32f_pixel_t rgb_pixel(1.f, 1.f, 1.f);
+    gil::lab32f_pixel_t lab_pixel;
+
+    gil::color_convert(rgb_pixel, lab_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[0]), 100.f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[1]), 0.f);
+    TEST_CHECK_CLOSE(static_cast<float>(lab_pixel[2]), 0.f);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
+
+BOOST_AUTO_TEST_SUITE(Lab_to_RGB)
+
+BOOST_AUTO_TEST_CASE(Lab_to_RGB_Test1)
+{
+    gil::lab32f_pixel_t lab_pixel(75.f, 20.f, 40.f);
+    gil::rgb32f_pixel_t rgb_pixel;
+
+    gil::color_convert(lab_pixel, rgb_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[0]), 0.943240f);
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[1]), 0.663990f);
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[2]), 0.437893f);
+}
+
+BOOST_AUTO_TEST_CASE(Lab_to_RGB_Test2)
+{
+    gil::lab32f_pixel_t lab_pixel(100.f, 0.f, 0.f);
+    gil::rgb32f_pixel_t rgb_pixel;
+
+    gil::color_convert(lab_pixel, rgb_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[0]), 1.f);
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[1]), 1.f);
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[2]), 1.f);
+}
+
+BOOST_AUTO_TEST_CASE(Lab_to_RGB_Test3)
+{
+    gil::lab32f_pixel_t lab_pixel(56.8140f, -42.3665, 10.6728f);
+    gil::rgb32f_pixel_t rgb_pixel;
+
+    gil::color_convert(lab_pixel, rgb_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[0]), 0.1f);
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[1]), 0.605568f);
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[2]), 0.456662f);
+}
+
+BOOST_AUTO_TEST_CASE(Lab_to_RGB_Test4)
+{
+    gil::lab32f_pixel_t lab_pixel(50.5874f, 4.0347f, 50.5456f);
+    gil::rgb32f_pixel_t rgb_pixel;
+
+    gil::color_convert(lab_pixel, rgb_pixel);
+
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[0]), 0.582705f);
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[1]), 0.454891f);
+    TEST_CHECK_CLOSE(static_cast<float>(rgb_pixel[2]), 0.1f);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: boost-1.52.0/src/libs/gil/toolbox/test/test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/toolbox/test/test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,2 @@
+#define BOOST_TEST_MAIN
+#include <boost/test/unit_test.hpp>
Index: boost-1.52.0/src/libs/gil/toolbox/test/xyz_test.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ boost-1.52.0/src/libs/gil/toolbox/test/xyz_test.cpp	2012-11-09 15:21:15.000000000 +0100
@@ -0,0 +1,193 @@
+// Copyright 2012 Davide Anastasia
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+/// \file xyz_test.cpp
+/// \brief Unit test for XYZ Colorspace
+/// \author Davide Anastasia <davideanastasia@users.sourceforge.net>
+
+#include <iostream>
+#include <limits>
+#include <boost/cstdint.hpp>
+#include <boost/gil/gil_all.hpp>
+#include <boost/gil/extension/toolbox/xyz.hpp>
+
+#include <boost/test/unit_test.hpp>
+
+using namespace boost;
+using namespace std;
+
+const float SKEW = 0.0001f;
+
+BOOST_AUTO_TEST_SUITE(ColorSpaceConversionXYZ)
+
+BOOST_AUTO_TEST_CASE(rgb32f_xyz32f_1)
+{
+    gil::xyz32f_pixel_t xyz32f;
+    gil::rgb32f_pixel_t p32f(.934351f, 0.785446f, .105858f), p32f_b;
+    gil::color_convert(p32f, xyz32f);
+    gil::color_convert(xyz32f, p32f_b);
+
+    BOOST_TEST_MESSAGE( p32f[0] << " "
+                        << p32f[1] << " "
+                        << p32f[2] << " -> "
+                        << xyz32f[0] << " "
+                        << xyz32f[1] << " "
+                        << xyz32f[2] << " -> "
+                        << p32f_b[0] << " "
+                        << p32f_b[1] << " "
+                        << p32f_b[2] );
+
+    BOOST_CHECK( abs(p32f[0] - p32f_b[0]) < SKEW );
+    BOOST_CHECK( abs(p32f[1] - p32f_b[1]) < SKEW );
+    BOOST_CHECK( abs(p32f[2] - p32f_b[2]) < SKEW );
+    BOOST_CHECK( abs( xyz32f[0] - 0.562669) < SKEW );
+    BOOST_CHECK( abs( xyz32f[1] - 0.597462) < SKEW );
+    BOOST_CHECK( abs( xyz32f[2] - 0.096050) < SKEW );
+}
+
+BOOST_AUTO_TEST_CASE(rgb32f_xyz32f_2)
+{
+    gil::xyz32f_pixel_t xyz32f;
+    gil::rgb32f_pixel_t p32f(.694617f, 0.173810f, 0.218710f), p32f_b;
+    gil::color_convert(p32f, xyz32f);
+    gil::color_convert(xyz32f, p32f_b);
+
+    BOOST_TEST_MESSAGE( p32f[0] << " "
+                        << p32f[1] << " "
+                        << p32f[2] << " -> "
+                        << xyz32f[0] << " "
+                        << xyz32f[1] << " "
+                        << xyz32f[2] << " -> "
+                        << p32f_b[0] << " "
+                        << p32f_b[1] << " "
+                        << p32f_b[2] );
+
+    BOOST_CHECK( abs(p32f[0] - p32f_b[0]) < SKEW );
+    BOOST_CHECK( abs(p32f[1] - p32f_b[1]) < SKEW );
+    BOOST_CHECK( abs(p32f[2] - p32f_b[2]) < SKEW );
+    BOOST_CHECK( abs( xyz32f[0] - 0.197823) < SKEW );
+    BOOST_CHECK( abs( xyz32f[1] - 0.114731) < SKEW );
+    BOOST_CHECK( abs( xyz32f[2] - 0.048848) < SKEW );
+}
+
+BOOST_AUTO_TEST_CASE(xyz32f_rgb32f_1)
+{
+    gil::xyz32f_pixel_t xyz32f(.332634f, .436288f, .109853f), xyz32f_b;
+    gil::rgb32f_pixel_t p32f;
+    gil::color_convert(xyz32f, p32f);
+    gil::color_convert(p32f, xyz32f_b);
+
+    BOOST_TEST_MESSAGE( xyz32f[0] << " "
+                        << xyz32f[1] << " "
+                        << xyz32f[2] << " -> "
+                        << p32f[0] << " "
+                        << p32f[1] << " "
+                        << p32f[2] << " -> "
+                        << xyz32f_b[0] << " "
+                        << xyz32f_b[1] << " "
+                        << xyz32f_b[2] );
+
+    BOOST_CHECK( abs(xyz32f_b[0] - xyz32f[0]) < SKEW );
+    BOOST_CHECK( abs(xyz32f_b[1] - xyz32f[1]) < SKEW );
+    BOOST_CHECK( abs(xyz32f_b[2] - xyz32f[2]) < SKEW );
+    BOOST_CHECK( abs( p32f[0] - 0.628242) < SKEW );
+    BOOST_CHECK( abs( p32f[1] - 0.735771) < SKEW );
+    BOOST_CHECK( abs( p32f[2] - 0.236473) < SKEW );
+}
+
+BOOST_AUTO_TEST_CASE(xyz32f_rgb32f_2)
+{
+    gil::xyz32f_pixel_t xyz32f(.375155f, .352705f, .260025f), xyz32f_b;
+    gil::rgb32f_pixel_t p32f;
+    gil::color_convert(xyz32f, p32f);
+    gil::color_convert(p32f, xyz32f_b);
+
+    BOOST_TEST_MESSAGE( xyz32f[0] << " "
+                        << xyz32f[1] << " "
+                        << xyz32f[2] << " -> "
+                        << p32f[0] << " "
+                        << p32f[1] << " "
+                        << p32f[2] << " -> "
+                        << xyz32f_b[0] << " "
+                        << xyz32f_b[1] << " "
+                        << xyz32f_b[2] );
+
+    BOOST_CHECK( abs(xyz32f_b[0] - xyz32f[0]) < SKEW );
+    BOOST_CHECK( abs(xyz32f_b[1] - xyz32f[1]) < SKEW );
+    BOOST_CHECK( abs(xyz32f_b[2] - xyz32f[2]) < SKEW );
+    BOOST_CHECK( abs( p32f[0] - 0.763580) < SKEW );
+    BOOST_CHECK( abs( p32f[1] - 0.591622) < SKEW );
+    BOOST_CHECK( abs( p32f[2] - 0.510392) < SKEW );
+}
+
+BOOST_AUTO_TEST_CASE(rgb8u_xyz32f_1)
+{
+    gil::xyz32f_pixel_t xyz32f;
+    gil::rgb8_pixel_t p8u(177, 44, 56), p8u_b;
+    gil::color_convert(p8u, xyz32f);
+    gil::color_convert(xyz32f, p8u_b);
+
+    BOOST_TEST_MESSAGE( static_cast<int>(p8u[0]) << " "
+                   << static_cast<int>(p8u[1]) << " "
+                   << static_cast<int>(p8u[2]) << " -> "
+                   << xyz32f[0] << " "
+                   << xyz32f[1] << " "
+                   << xyz32f[2] << " -> "
+                   << static_cast<int>(p8u_b[0]) << " "
+                   << static_cast<int>(p8u_b[1]) << " "
+                   << static_cast<int>(p8u_b[2]) );
+
+    BOOST_CHECK(p8u[0] == p8u_b[0]);
+    BOOST_CHECK(p8u[1] == p8u_b[1]);
+    BOOST_CHECK(p8u[2] == p8u_b[2]);
+}
+
+BOOST_AUTO_TEST_CASE(rgb8u_xyz32f_2)
+{
+    gil::xyz32f_pixel_t xyz32f;
+    gil::rgb8_pixel_t p8u(72, 90, 165), p8u_b;
+    gil::color_convert(p8u, xyz32f);
+    gil::color_convert(xyz32f, p8u_b);
+
+    BOOST_TEST_MESSAGE(
+                      static_cast<int>(p8u[0]) << " "
+                   << static_cast<int>(p8u[1]) << " "
+                   << static_cast<int>(p8u[2]) << " -> "
+                   << xyz32f[0] << " "
+                   << xyz32f[1] << " "
+                   << xyz32f[2] << " -> "
+                   << static_cast<int>(p8u_b[0]) << " "
+                   << static_cast<int>(p8u_b[1]) << " "
+                   << static_cast<int>(p8u_b[2]) );
+
+    BOOST_CHECK(p8u[0] == p8u_b[0]);
+    BOOST_CHECK(p8u[1] == p8u_b[1]);
+    BOOST_CHECK(p8u[2] == p8u_b[2]);
+}
+
+BOOST_AUTO_TEST_CASE(rgb16u_xyz32f_1)
+{
+    gil::xyz32f_pixel_t xyz32f;
+    gil::rgb16_pixel_t p16u(12564, 20657, 200), p16u_b;
+    gil::color_convert(p16u, xyz32f);
+    gil::color_convert(xyz32f, p16u_b);
+
+    BOOST_TEST_MESSAGE(
+                      static_cast<int>(p16u[0]) << " "
+                   << static_cast<int>(p16u[1]) << " "
+                   << static_cast<int>(p16u[2]) << " -> "
+                   << xyz32f[0] << " "
+                   << xyz32f[1] << " "
+                   << xyz32f[2] << " -> "
+                   << static_cast<int>(p16u_b[0]) << " "
+                   << static_cast<int>(p16u_b[1]) << " "
+                   << static_cast<int>(p16u_b[2]) );
+
+    BOOST_CHECK(p16u[0] == p16u_b[0]);
+    BOOST_CHECK(p16u[1] == p16u_b[1]);
+    BOOST_CHECK(p16u[2] == p16u_b[2]);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
