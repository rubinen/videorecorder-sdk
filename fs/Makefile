#$L$
#
# Copyright (C) 2010-2013 Ridgerun (http://www.ridgerun.com).
#
#$L$

.PHONY:	default build preconfig patch buildfs unpatch clean config.site config.site.sim toolchain.cmake toolchain.sim.cmake \
	build_start defs cmdline

ifeq ($(DEVDIR),)
$(error ====== DEVDIR variable is empty, invoke this Makefile from the BSP root, or provide the path to it =====)
endif

include $(DEVDIR)/bsp/mach/Make.conf

# Please, don't modify this without paying attention, order matters:
# apps, toolchain and rrapps goes first as they may install generic
# definitions arch and mach should be in that order to install custom
# files myapps is last
FS_COMPONENTS ?= host-apps apps $(DEVDIR)/toolchain rrapps arch mach proprietary_src myapps

# By default rrsdk class run ldconfig on install, we can speed up the process
# when building the whole fs by running until the end
export DO_NOT_RUN_LDCONFIG_ON_INSTALL=yes

define copy_dir
	cd $(1) && \
	    find -print0 | \
	    tar --exclude=.svn --exclude=\*~ --null -T - -cf - | \
	    tar -C $(2) -xpf -
endef

INTERFACES=$(FSROOT)/etc/network/interfaces

default: build

networkconfig:
	$(V) if grep -q BSP_NET_HAS_NET arch/base/Makefile ; then \
	    $(ECHO) "\n$(WARN_COLOR)WARNING:$(NORMAL_COLOR) Looks like you have some deprecated network funcionality on $(FSROOT)/arch/base. Be aware is being ignored\n" ; \
	fi
ifeq ($(CONFIG_BSP_NET_HAS_NET),y)
	$(V)mkdir -p $(FSROOT)/etc/network/ $(FSROOT)/var/run/ $(QOUT)
	$(V)ln -sf /var/run $(FSROOT)/etc/network/
	$(V)echo -e "# Warning this file is automatically generated, you can overwrite it with a file from the target file system overlay" > $(INTERFACES)
	$(V)echo -e "\n# The loopback network interface" >> $(INTERFACES)
	$(V)echo -e "auto lo\niface lo inet loopback\n" >> $(INTERFACES)

ifeq ($(CONFIG_BSP_NET_HAS_ETH0),y)
	$(V)echo -e "auto eth0" >> $(INTERFACES)
ifeq ($(CONFIG_FS_TARGET_NFSROOT),y)
	$(V)echo "#SDK configured for NFS root, so we don't mess with eth0 ipv4" >> $(INTERFACES)
	$(V)echo "iface eth0 inet manual" >> $(INTERFACES)
else
ifneq ($(CONFIG_BSP_NET_ETH0_USE_DHCP),y)
	$(V)echo "iface eth0 inet static" >> $(INTERFACES)
	$(V)echo "	address $(CONFIG_BSP_NET_ETH0_IPADDR)" >>$(INTERFACES)
	$(V)echo "	netmask $(CONFIG_BSP_NET_ETH0_NETMASK)" >>$(INTERFACES)
else
	$(V)echo "iface eth0 inet dhcp" >> $(INTERFACES)
ifeq ($(CONFIG_UDHCPC),y)
	$(V)echo "	script /etc/udhcp.script" >> $(INTERFACES)
endif
endif #DHCP
endif #NFSROOT
ifeq ($(CONFIG_BSP_IPV6_SUPPORT),y)
ifeq ($(CONFIG_BSP_NET_ETH0_USE_DHCPV6),y)
	$(V)echo "iface eth0 inet6 dhcp" >> $(INTERFACES)
endif # ETH0_DHCPV6
ifeq ($(CONFIG_BSP_NET_ETH0_USE_STATIC6),y)
	$(V)echo "iface eth0 inet6 static" >> $(INTERFACES)
	$(V)echo "	address $(CONFIG_BSP_NET_ETH0_GLOBAL_IPADDR6)/64" >>$(INTERFACES)
	$(V)echo "	gateway $(CONFIG_BSP_NET_ETH0_GATEWAY_IPADDR6)" >>$(INTERFACES)
endif # ETH0_STATIC6
ifeq ($(CONFIG_BSP_NET_ETH0_USE_STATELESS),y)
	$(V)echo "iface eth0 inet6 manual" >> $(INTERFACES)
endif # ETH0_STATELESS
endif # IPV6_SUPPORT
endif # ETH0

ifeq ($(CONFIG_BSP_NET_HAS_USB0),y)
	$(V)echo -e "auto usb0\n" >> $(INTERFACES)
ifeq ($(CONFIG_FS_TARGET_NFSROOT),y)
	$(V)echo "#SDK configured for NFS root, so we don't mess with usb0 ipv4" >> $(INTERFACES)
	$(V)echo "iface usb0 inet manual" >> $(INTERFACES)
else
ifneq ($(CONFIG_BSP_NET_USB0_USE_DHCP),y)
	$(V)echo "iface usb0 inet static" >> $(INTERFACES)
	$(V)echo "	netmask $(CONFIG_BSP_NET_USB0_NETMASK)" >>$(INTERFACES)
else
	$(V)echo "iface usb0 inet dhcp" >> $(INTERFACES)
	$(V)echo "	script /etc/udhcp.script" >> $(INTERFACES)
endif #DHCP
endif #NFSROOT

ifeq ($(CONFIG_BSP_IPV6_SUPPORT),y)
ifeq ($(CONFIG_BSP_NET_USB0_USE_DHCPV6),y)
	$(V)echo "iface usb0 inet6 dhcp" >> $(INTERFACES)
endif # USB0_DHCPV6
ifeq ($(CONFIG_BSP_NET_USB0_USE_STATIC6),y)
	$(V)echo "iface usb0 inet6 static" >> $(INTERFACES)
	$(V)echo "	address $(CONFIG_BSP_NET_ETH0_GLOBAL_IPADDR6)/64" >>$(INTERFACES)
	$(V)echo "	gateway $(CONFIG_BSP_NET_ETH0_GATEWAY_IPADDR6)" >>$(INTERFACES)
endif # USB0_STATIC6
ifeq ($(CONFIG_BSP_NET_USB0_USE_STATELESS),y)
	$(V)echo "iface usb0 inet6 manual" >> $(INTERFACES)
endif # USB0_STATELESS
endif # IPV6_SUPPORT

endif #USB0

endif # HAS_NET

depmod:
	$(V) if [ -d $(FSROOT)/lib/modules/$(KERNELVERSION) ] ; then \
		/sbin/depmod -ae -b $(FSROOT) -F $(DEVDIR)/kernel/$(KERNEL)/System.map \
		-v $(KERNELVERSION) $(QOUT); \
	fi

build: build_start $(FSROOT) $(FSDEVROOT) $(foreach COMP, $(FS_COMPONENTS), $(COMP)_build) networkconfig
	$(V) $(ECHO) "Installing proprietary code"
# Now let's link this stuff,
# Just in case ld.so.conf doesn't exist, we update it
	$(V) touch $(FSROOT)/etc/ld.so.conf
	$(V) mkdir -p $(FSROOT)/var/cache/ldconfig
	$(V) $(LDCONFIG) -r $(FSROOT) $(QOUT)
# Calculate module dependencies
	$(V) if [ -d $(FSROOT)/lib/modules/$(KERNELVERSION) ] ; then \
		/sbin/depmod -ae -b $(FSROOT) -F $(DEVDIR)/kernel/$(KERNEL)/System.map \
		-v $(KERNELVERSION) $(QOUT); \
	fi
	$(V) $(ECHO) "Installing Overlay"
	$(V) $(call copy_dir,overlay,$(FSROOT))
	$(V) $(DEVDIR)/bsp/scripts/stamp_build > $(FSROOT)/etc/version
ifeq ($(CONFIG_FS_STRIPFS),y)
	$(V) $(ECHO) "Stripping symbols from binary files"
	$(V) for i in `find $(FSROOT)` ; \
	    do  \
		if file $$i | grep ELF | grep -i ", $(ARCH)," | grep -v \.ko >/dev/null && \
		   ! [[ $$i =~ "/firmware/" ]] ; then \
			$(STRIP) -s $$i ; \
		fi ; \
	    done
endif
	# Fix permissions for the $(FSROOT) to prevent build problems
	$(V) $(SUDO) chown -R $(USER) $(FSROOT)
ifneq ($(CONFIG_FS_TARGET_REQUIRES_INSTALLER_GENERATION),y)
	$(V) $(ECHO) "Building file system target image(s)"
	$(V) $(MAKE) -C fstargets build
else
	$(V) $(ECHO) "Deferring file system generation to the installer..."
	$(V) $(MAKE) -C fstargets cmdline
	$(V) rm -f $(FSIMAGE) ; touch $(FSIMAGE)
endif
	$(V) echo -n " $(CONFIG_BSP_EXTRA_BOOT_ARGS) ">>$(CMDLINEFILE)
	$(V) $(ECHO) "Build complete"

genimage:
ifneq ($(CONFIG_FS_TARGET_REQUIRES_INSTALLER_GENERATION),y)
	$(V) $(ECHO) "Building file system target image(s)"
	$(V) $(MAKE) -C fstargets genimage
else
	$(V) $(ECHO) "The filesystem is generated with help from the installer, since we need to know some flash parameters. Aborting\n"
endif

cmdline: build_start $(foreach COMP, $(FS_COMPONENTS), $(COMP)_cmdline)
	$(V) $(ECHO) "Building file system target image(s)"
	$(MAKE) -C fstargets $(MAKE_CALL_PARAMS) cmdline || { exit 1 ; } ;
	$(V) echo -n " $(CONFIG_BSP_EXTRA_BOOT_ARGS) ">>$(CMDLINEFILE)

defs:
	$(V) $(ECHO) "Building Apps.defs"
	$(V) $(SHELL) $(DEVDIR)/bsp/scripts/build_apps_defs.sh $(FS_COMPONENTS) > $(DEVDIR)/fs/Apps.defs

host_packages:
# Checking for new host packages requirements
	$(V) rm -f $(DEVDIR)/fs/hostreqs $(QOUT)
	$(SHELL) $(DEVDIR)/bsp/oscheck/pkg -o

build_start: defs host_packages config.site toolchain.cmake toolchain.sim.cmake
	$(V) echo -n "" > $(CMDLINEFILE)

CREATEDEV=$(SUDO) mknod $(FSROOT)/dev
# If the $(FSROOT) directory doesn't exist, we trigger the buildfs target
# to build the basic system
$(FSROOT):
	$(V) $(ECHO) "Base $(FSROOT) directory not found, creating base"
	$(V) mkdir -p $(FSROOT)/{etc,bin,sbin,usr/bin,usr/sbin,usr/lib,var/run,var/db,dev,tmp,proc,sys,lib}
	$(V)mkdir -p $(FSROOT)/dev/{pts,input,snd,fb,i2c}
	# Install minimal /dev devices
	$(CREATEDEV)/console c 5 1
	$(CREATEDEV)/mem -m 0660 c 1 1
	$(CREATEDEV)/kmem -m 0660 c 1 2
	$(CREATEDEV)/null -m 0666 c 1 3
	$(CREATEDEV)/zero -m 0660 c 1 5
	$(CREATEDEV)/random -m 0660 c 1 8
	$(CREATEDEV)/urandom -m 0660 c 1 9
	$(CREATEDEV)/ram0 b 1 0
	$(CREATEDEV)/cmem c 249 0
	$(V) make -C $(DEVDIR) $(MAKE_CALL_PARAMS) buildfs

$(FSDEVROOT):
	$(V) $(ECHO) "Creating development $(FSDEVROOT) directory"
	$(V) mkdir -p $(FSDEVROOT)/usr/{lib,bin,sbin,share,include,man,etc,$(KERNEL)}

config.site: $(DEVDIR)/bsp/mach/bspconfig
	@$(ECHO) "Building SDK specific application build parameters"
	$(V) echo "# This file is autogenerated by `pwd`/Makefile" >config.site.t
	$(V) echo "# Do not manually change this file - your changes will be lost." >>config.site.t
	$(V) echo "# The toolchain definitions are not always required but certain applications" >>config.site.t
	$(V) echo "# don't properly support the autotools --host parameter so these" >>config.site.t
	$(V) echo "# definitions allows those packages to be cross compiled." >>config.site.t
	$(V) echo "test -z \"\$$CC\" && CC=\"$(CC)\"" >>config.site.t
	$(V) echo "test -z \"\$$LD\" && LD=\"$(LD)\"" >>config.site.t
	$(V) echo "test -z \"\$$CPP\" && CPP=\"$(CPP)\"" >>config.site.t
	$(V) echo "test -z \"\$$CXX\" && CXX=\"$(CXX)\"" >>config.site.t
	$(V) echo "test -z \"\$$AS\" && AS=\"$(AS)\"" >>config.site.t
	$(V) echo "test -z \"\$$AR\" && AR=\"$(AR)\"" >>config.site.t
	$(V) echo "test -z \"\$$NM\" && NM=\"$(NM)\"" >>config.site.t
	$(V) echo "test -z \"\$$STRIP\" && STRIP=\"$(STRIP)\"" >>config.site.t
	$(V) echo "test -z \"\$$OBJCOPY\" && OBJCOPY=\"$(OBJCOPY)\"" >>config.site.t
	$(V) echo "test -z \"\$$OBJDUMP\" && OBJDUMP=\"$(OBJDUMP)\"" >>config.site.t
	$(V) echo "test -z \"\$$RANLIB\" && RANLIB=\"$(RANLIB)\"" >>config.site.t
	$(V) echo -e "\ntest -z \"\$$CFLAGS\" && CFLAGS=\"$(APPS_CFLAGS)\"" >>config.site.t
	$(V) echo "test -z \"\$$LDFLAGS\" && LDFLAGS=\"$(APPS_LDFLAGS)\"" >>config.site.t
	$(V) echo "test -z \"\$$CPPFLAGS\" && CPPFLAGS=\"$(APPS_CFLAGS)\"" >>config.site.t
	$(V) echo -e "\ntest \"\$$prefix\" = NONE && prefix=$(FSDEVROOT)/usr" >>config.site.t
	$(V) for file in `ls $(DEVDIR)/fs/config.site.d` ; do \
	      cat $(DEVDIR)/fs/config.site.d/$$file >> config.site.t ; \
	     done
	$(V) echo -e "\ntrue" >> config.site.t
	$(V) if [ ! -f config.site ] || \
		! diff config.site.t config.site >/dev/null ; then \
		cp config.site.t config.site ; \
	fi
	$(V)rm -f config.site.t

ifeq ($(MAKECMDGOALS),config.site.sim)
FSDEVROOT=$(SIMROOT)
APPS_CFLAGS=-I$(FSDEVROOT)/usr/include -I$(FSDEVROOT)/include
APPS_LDFLAGS=-L$(FSDEVROOT)/usr/lib -L$(FSDEVROOT)/lib
endif
config.site.sim:
	$(V) echo "#This file is autogenerated by `pwd`/Makefile, don't change" >config.site.t
	$(V) echo -e "\ntest -z \"\$$CFLAGS\" && CFLAGS=\"$(APPS_CFLAGS)\"" >>config.site.t
	$(V) echo "test -z \"\$$LDFLAGS\" && LDFLAGS=\"$(APPS_LDFLAGS)\"" >>config.site.t
	$(V) echo "test -z \"\$$CPPFLAGS\" && CPPFLAGS=\"$(APPS_CFLAGS)\"" >>config.site.t
	$(V) echo -e "\ntest \"\$$prefix\" = NONE && prefix=$(FSDEVROOT)/usr" >>config.site.t
	$(V)for file in `ls $(DEVDIR)/fs/config.site.d` ; do \
	      cat $(DEVDIR)/fs/config.site.d/$$file >> config.site.t ; \
	    done
	$(V) echo -e "\ntrue" >> config.site.t
	$(V) if [ ! -f config.site ] || \
		! diff config.site.t config.site >/dev/null ; then \
		cp config.site.t config.site.sim ; \
	fi
	$(V)rm -f config.site.t

toolchain.cmake: toolchain.cmake.in
	$(V) cp $< $@
	$(V) sed -i -e "s/@CMAKE_SYSTEM_NAME@/$(shell uname)/" \
	    -e "s?@CC@?\"$(TOOLCHAIN_PREFIX)-gcc\"?" \
	    -e "s?@CXX@?\"$(TOOLCHAIN_PREFIX)-g++\"?" \
	    -e "s?@FSDEV@?$(FSDEVROOT)?g" \
	$@

toolchain.sim.cmake: toolchain.sim.cmake.in
	$(V) cp $< $@
	$(V) sed -i -e "s/@CMAKE_SYSTEM_NAME@/$(shell uname)/" \
	    -e "s?@CC@?gcc?" \
	    -e "s?@CXX@?g++?" \
	    -e "s?@SIMROOT@?$(SIMROOT)?g" \
	$@


preconfig: defs $(foreach COMP, $(FS_COMPONENTS), $(COMP)_preconfig)
	$(V) $(MAKE) -C fstargets $(MAKE_CALL_PARAMS) preconfig

patch: $(foreach COMP, $(FS_COMPONENTS), $(COMP)_patch)

buildfs: defs $(foreach COMP, $(FS_COMPONENTS), $(COMP)_buildfs)

unpatch: $(foreach COMP, $(FS_COMPONENTS), $(COMP)_unpatch)

clean: defs $(foreach COMP, $(FS_COMPONENTS), $(COMP)_clean)
	$(V) rm -Rf config.site Apps.defs hostreqs $(FSROOT) $(FSDEVROOT)

# Component Function template call
define COMP_template
.PHONY: $(1)$(2)
$(1)$(2):
	$(V)if [ -d $(1) ] ; then \
	  $(ECHO) "Entering $(1)..."; \
	  $(MAKE) -C $(1) $(3) $(MAKE_CALL_PARAMS) || { exit 1 ; } ; \
	fi
endef

# Create a rules for FS_COMPONENTS
$(foreach COMP, $(FS_COMPONENTS), $(eval $(call COMP_template,$(COMP),_patch,patch)))
$(foreach COMP, $(FS_COMPONENTS), $(eval $(call COMP_template,$(COMP),_build,build)))
$(foreach COMP, $(FS_COMPONENTS), $(eval $(call COMP_template,$(COMP),_preconfig,preconfig)))
$(foreach COMP, $(FS_COMPONENTS), $(eval $(call COMP_template,$(COMP),_unpatch,unpatch)))
$(foreach COMP, $(FS_COMPONENTS), $(eval $(call COMP_template,$(COMP),_clean,clean)))
$(foreach COMP, $(FS_COMPONENTS), $(eval $(call COMP_template,$(COMP),_buildfs,buildfs)))
$(foreach COMP, $(FS_COMPONENTS), $(eval $(call COMP_template,$(COMP),_cmdline,cmdline)))

force_build_execute:
	$(V)$(MAKE) build

include $(CLASSES)/force_build.defs

