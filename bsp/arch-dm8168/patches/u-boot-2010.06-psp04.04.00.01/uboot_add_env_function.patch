Index: u-boot-2010.06/src/arch/arm/include/asm/global_data.h
===================================================================
--- u-boot-2010.06.orig/src/arch/arm/include/asm/global_data.h	2012-05-12 12:19:49.834603465 -0600
+++ u-boot-2010.06/src/arch/arm/include/asm/global_data.h	2012-05-12 12:19:56.999215880 -0600
@@ -54,6 +54,7 @@
 	unsigned long	reset_status;	/* reset status register at boot */
 #endif
 	void		**jt;		/* jump table */
+        char		env_buf[32];	/* buffer for getenv() before reloc. */
 } gd_t;
 
 /*
@@ -66,6 +67,7 @@
 #define	GD_FLG_POSTSTOP	0x00010		/* POST seqeunce aborted		*/
 #define	GD_FLG_LOGINIT	0x00020		/* Log Buffer has been initialized	*/
 #define GD_FLG_DISABLE_CONSOLE	0x00040		/* Disable console (in & out)	 */
+#define GD_FLG_ENV_READY	0x00080	/* Environment imported into hash table	*/
 
 #define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r8")
 
Index: u-boot-2010.06/src/arch/arm/lib/Makefile
===================================================================
--- u-boot-2010.06.orig/src/arch/arm/lib/Makefile	2012-05-12 12:19:49.815218057 -0600
+++ u-boot-2010.06/src/arch/arm/lib/Makefile	2012-05-12 12:19:56.999215880 -0600
@@ -36,6 +36,9 @@
 
 GLCOBJS	+= div0.o
 
+COBJS-y += qsort.o
+COBJS-y += hashtable.o
+COBJS-y += errno.o
 COBJS-y	+= board.o
 COBJS-y	+= bootm.o
 COBJS-y	+= cache.o
Index: u-boot-2010.06/src/arch/arm/lib/board.c
===================================================================
--- u-boot-2010.06.orig/src/arch/arm/lib/board.c	2012-05-12 12:19:49.823215714 -0600
+++ u-boot-2010.06/src/arch/arm/lib/board.c	2012-05-12 12:19:56.999215880 -0600
@@ -125,7 +125,7 @@
 static int init_baudrate (void)
 {
 	char tmp[64];	/* long enough for environment variables */
-	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
+	int i = getenv_f ("baudrate", tmp, sizeof (tmp));
 	gd->bd->bi_baudrate = gd->baudrate = (i > 0)
 			? (int) simple_strtoul (tmp, NULL, 10)
 			: CONFIG_BAUDRATE;
Index: u-boot-2010.06/src/arch/arm/lib/errno.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2010.06/src/arch/arm/lib/errno.c	2012-05-12 12:19:56.999215880 -0600
@@ -0,0 +1 @@
+int errno = 0;
Index: u-boot-2010.06/src/arch/arm/lib/hashtable.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2010.06/src/arch/arm/lib/hashtable.c	2012-05-12 12:19:56.999215880 -0600
@@ -0,0 +1,739 @@
+/*
+ * This implementation is based on code from uClibc-0.9.30.3 but was
+ * modified and extended for use within U-Boot.
+ *
+ * Copyright (C) 2010 Wolfgang Denk <wd@denx.de>
+ *
+ * Original license header:
+ *
+ * Copyright (C) 1993, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
+ * This file is part of the GNU C Library.
+ * Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1993.
+ *
+ * The GNU C Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * The GNU C Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the GNU C Library; if not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307 USA.
+ */
+
+#include <errno.h>
+#include <malloc.h>
+
+#ifdef USE_HOSTCC		/* HOST build */
+# include <string.h>
+# include <assert.h>
+
+# ifndef debug
+#  ifdef DEBUG
+#   define debug(fmt,args...)	printf(fmt ,##args)
+#  else
+#   define debug(fmt,args...)
+#  endif
+# endif
+#else				/* U-Boot build */
+# include <common.h>
+# include <linux/string.h>
+#endif
+
+#ifndef	CONFIG_ENV_MIN_ENTRIES	/* minimum number of entries */
+#define	CONFIG_ENV_MIN_ENTRIES 64
+#endif
+#ifndef	CONFIG_ENV_MAX_ENTRIES	/* maximum number of entries */
+#define	CONFIG_ENV_MAX_ENTRIES 512
+#endif
+
+#include "search.h"
+
+/*
+ * [Aho,Sethi,Ullman] Compilers: Principles, Techniques and Tools, 1986
+ * [Knuth]	      The Art of Computer Programming, part 3 (6.4)
+ */
+
+/*
+ * The non-reentrant version use a global space for storing the hash table.
+ */
+static struct hsearch_data htab;
+
+/*
+ * The reentrant version has no static variables to maintain the state.
+ * Instead the interface of all functions is extended to take an argument
+ * which describes the current status.
+ */
+typedef struct _ENTRY {
+	unsigned int used;
+	ENTRY entry;
+} _ENTRY;
+
+
+/*
+ * hcreate()
+ */
+
+/*
+ * For the used double hash method the table size has to be a prime. To
+ * correct the user given table size we need a prime test.  This trivial
+ * algorithm is adequate because
+ * a)  the code is (most probably) called a few times per program run and
+ * b)  the number is small because the table must fit in the core
+ * */
+static int isprime(unsigned int number)
+{
+	/* no even number will be passed */
+	unsigned int div = 3;
+
+	while (div * div < number && number % div != 0)
+		div += 2;
+
+	return number % div != 0;
+}
+
+int hcreate(size_t nel)
+{
+	return hcreate_r(nel, &htab);
+}
+
+/*
+ * Before using the hash table we must allocate memory for it.
+ * Test for an existing table are done. We allocate one element
+ * more as the found prime number says. This is done for more effective
+ * indexing as explained in the comment for the hsearch function.
+ * The contents of the table is zeroed, especially the field used
+ * becomes zero.
+ */
+int hcreate_r(size_t nel, struct hsearch_data *htab)
+{
+	/* Test for correct arguments.  */
+	if (htab == NULL) {
+		__set_errno(EINVAL);
+		return 0;
+	}
+
+	/* There is still another table active. Return with error. */
+	if (htab->table != NULL)
+		return 0;
+
+	/* Change nel to the first prime number not smaller as nel. */
+	nel |= 1;		/* make odd */
+	while (!isprime(nel))
+		nel += 2;
+
+	htab->size = nel;
+	htab->filled = 0;
+
+	/* allocate memory and zero out */
+	htab->table = (_ENTRY *) calloc(htab->size + 1, sizeof(_ENTRY));
+	if (htab->table == NULL)
+		return 0;
+
+	/* everything went alright */
+	return 1;
+}
+
+
+/*
+ * hdestroy()
+ */
+void hdestroy(void)
+{
+	hdestroy_r(&htab);
+}
+
+/*
+ * After using the hash table it has to be destroyed. The used memory can
+ * be freed and the local static variable can be marked as not used.
+ */
+void hdestroy_r(struct hsearch_data *htab)
+{
+	int i;
+
+	/* Test for correct arguments.  */
+	if (htab == NULL) {
+		__set_errno(EINVAL);
+		return;
+	}
+
+	/* free used memory */
+	for (i = 1; i <= htab->size; ++i) {
+		if (htab->table[i].used) {
+			ENTRY *ep = &htab->table[i].entry;
+
+			free(ep->key);
+			free(ep->data);
+		}
+	}
+	free(htab->table);
+
+	/* the sign for an existing table is an value != NULL in htable */
+	htab->table = NULL;
+}
+
+/*
+ * hsearch()
+ */
+
+/*
+ * This is the search function. It uses double hashing with open addressing.
+ * The argument item.key has to be a pointer to an zero terminated, most
+ * probably strings of chars. The function for generating a number of the
+ * strings is simple but fast. It can be replaced by a more complex function
+ * like ajw (see [Aho,Sethi,Ullman]) if the needs are shown.
+ *
+ * We use an trick to speed up the lookup. The table is created by hcreate
+ * with one more element available. This enables us to use the index zero
+ * special. This index will never be used because we store the first hash
+ * index in the field used where zero means not used. Every other value
+ * means used. The used field can be used as a first fast comparison for
+ * equality of the stored and the parameter value. This helps to prevent
+ * unnecessary expensive calls of strcmp.
+ *
+ * This implementation differs from the standard library version of
+ * this function in a number of ways:
+ *
+ * - While the standard version does not make any assumptions about
+ *   the type of the stored data objects at all, this implementation
+ *   works with NUL terminated strings only.
+ * - Instead of storing just pointers to the original objects, we
+ *   create local copies so the caller does not need to care about the
+ *   data any more.
+ * - The standard implementation does not provide a way to update an
+ *   existing entry.  This version will create a new entry or update an
+ *   existing one when both "action == ENTER" and "item.data != NULL".
+ * - Instead of returning 1 on success, we return the index into the
+ *   internal hash table, which is also guaranteed to be positive.
+ *   This allows us direct access to the found hash table slot for
+ *   example for functions like hdelete().
+ */
+
+ENTRY *hsearch(ENTRY item, ACTION action)
+{
+	ENTRY *result;
+
+	(void) hsearch_r(item, action, &result, &htab);
+
+	return result;
+}
+
+int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
+	      struct hsearch_data *htab)
+{
+	unsigned int hval;
+	unsigned int count;
+	unsigned int len = strlen(item.key);
+	unsigned int idx;
+
+	/* Compute an value for the given string. Perhaps use a better method. */
+	hval = len;
+	count = len;
+	while (count-- > 0) {
+		hval <<= 4;
+		hval += item.key[count];
+	}
+
+	/*
+	 * First hash function:
+	 * simply take the modul but prevent zero.
+	 */
+	hval %= htab->size;
+	if (hval == 0)
+		++hval;
+
+	/* The first index tried. */
+	idx = hval;
+
+	if (htab->table[idx].used) {
+		/*
+		 * Further action might be required according to the
+		 * action value.
+		 */
+		unsigned hval2;
+
+		if (htab->table[idx].used == hval
+		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
+			/* Overwrite existing value? */
+			if ((action == ENTER) && (item.data != NULL)) {
+				free(htab->table[idx].entry.data);
+				htab->table[idx].entry.data =
+					strdup(item.data);
+				if (!htab->table[idx].entry.data) {
+					__set_errno(ENOMEM);
+					*retval = NULL;
+					return 0;
+				}
+			}
+			/* return found entry */
+			*retval = &htab->table[idx].entry;
+			return idx;
+		}
+
+		/*
+		 * Second hash function:
+		 * as suggested in [Knuth]
+		 */
+		hval2 = 1 + hval % (htab->size - 2);
+
+		do {
+			/*
+			 * Because SIZE is prime this guarantees to
+			 * step through all available indices.
+			 */
+			if (idx <= hval2)
+				idx = htab->size + idx - hval2;
+			else
+				idx -= hval2;
+
+			/*
+			 * If we visited all entries leave the loop
+			 * unsuccessfully.
+			 */
+			if (idx == hval)
+				break;
+
+			/* If entry is found use it. */
+			if ((htab->table[idx].used == hval)
+			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
+				/* Overwrite existing value? */
+				if ((action == ENTER) && (item.data != NULL)) {
+					free(htab->table[idx].entry.data);
+					htab->table[idx].entry.data =
+						strdup(item.data);
+					if (!htab->table[idx].entry.data) {
+						__set_errno(ENOMEM);
+						*retval = NULL;
+						return 0;
+					}
+				}
+				/* return found entry */
+				*retval = &htab->table[idx].entry;
+				return idx;
+			}
+		}
+		while (htab->table[idx].used);
+	}
+
+	/* An empty bucket has been found. */
+	if (action == ENTER) {
+		/*
+		 * If table is full and another entry should be
+		 * entered return with error.
+		 */
+		if (htab->filled == htab->size) {
+			__set_errno(ENOMEM);
+			*retval = NULL;
+			return 0;
+		}
+
+		/*
+		 * Create new entry;
+		 * create copies of item.key and item.data
+		 */
+		htab->table[idx].used = hval;
+		htab->table[idx].entry.key = strdup(item.key);
+		htab->table[idx].entry.data = strdup(item.data);
+		if (!htab->table[idx].entry.key ||
+		    !htab->table[idx].entry.data) {
+			__set_errno(ENOMEM);
+			*retval = NULL;
+			return 0;
+		}
+
+		++htab->filled;
+
+		/* return new entry */
+		*retval = &htab->table[idx].entry;
+		return 1;
+	}
+
+	__set_errno(ESRCH);
+	*retval = NULL;
+	return 0;
+}
+
+
+/*
+ * hdelete()
+ */
+
+/*
+ * The standard implementation of hsearch(3) does not provide any way
+ * to delete any entries from the hash table.  We extend the code to
+ * do that.
+ */
+
+int hdelete(const char *key)
+{
+	return hdelete_r(key, &htab);
+}
+
+int hdelete_r(const char *key, struct hsearch_data *htab)
+{
+	ENTRY e, *ep;
+	int idx;
+
+	debug("hdelete: DELETE key \"%s\"\n", key);
+
+	e.key = (char *)key;
+
+	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
+		__set_errno(ESRCH);
+		return 0;	/* not found */
+	}
+
+	/* free used ENTRY */
+	debug("hdelete: DELETING key \"%s\"\n", key);
+
+	free(ep->key);
+	free(ep->data);
+	htab->table[idx].used = 0;
+
+	--htab->filled;
+
+	return 1;
+}
+
+/*
+ * hexport()
+ */
+
+/*
+ * Export the data stored in the hash table in linearized form.
+ *
+ * Entries are exported as "name=value" strings, separated by an
+ * arbitrary (non-NUL, of course) separator character. This allows to
+ * use this function both when formatting the U-Boot environment for
+ * external storage (using '\0' as separator), but also when using it
+ * for the "printenv" command to print all variables, simply by using
+ * as '\n" as separator. This can also be used for new features like
+ * exporting the environment data as text file, including the option
+ * for later re-import.
+ *
+ * The entries in the result list will be sorted by ascending key
+ * values.
+ *
+ * If the separator character is different from NUL, then any
+ * separator characters and backslash characters in the values will
+ * be escaped by a preceeding backslash in output. This is needed for
+ * example to enable multi-line values, especially when the output
+ * shall later be parsed (for example, for re-import).
+ *
+ * There are several options how the result buffer is handled:
+ *
+ * *resp  size
+ * -----------
+ *  NULL    0	A string of sufficient length will be allocated.
+ *  NULL   >0	A string of the size given will be
+ *		allocated. An error will be returned if the size is
+ *		not sufficient.  Any unused bytes in the string will
+ *		be '\0'-padded.
+ * !NULL    0	The user-supplied buffer will be used. No length
+ *		checking will be performed, i. e. it is assumed that
+ *		the buffer size will always be big enough. DANGEROUS.
+ * !NULL   >0	The user-supplied buffer will be used. An error will
+ *		be returned if the size is not sufficient.  Any unused
+ *		bytes in the string will be '\0'-padded.
+ */
+
+ssize_t hexport(const char sep, char **resp, size_t size)
+{
+	return hexport_r(&htab, sep, resp, size);
+}
+
+static int cmpkey(const void *p1, const void *p2)
+{
+	ENTRY *e1 = *(ENTRY **) p1;
+	ENTRY *e2 = *(ENTRY **) p2;
+
+	return (strcmp(e1->key, e2->key));
+}
+
+ssize_t hexport_r(struct hsearch_data *htab, const char sep,
+		 char **resp, size_t size)
+{
+	ENTRY *list[htab->size];
+	char *res, *p;
+	size_t totlen;
+	int i, n;
+
+	/* Test for correct arguments.  */
+	if ((resp == NULL) || (htab == NULL)) {
+		__set_errno(EINVAL);
+		return (-1);
+	}
+
+	debug("EXPORT  table = %p, htab.size = %d, htab.filled = %d, size = %d\n",
+		htab, htab->size, htab->filled, size);
+	/*
+	 * Pass 1:
+	 * search used entries,
+	 * save addresses and compute total length
+	 */
+	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {
+
+		if (htab->table[i].used) {
+			ENTRY *ep = &htab->table[i].entry;
+
+			list[n++] = ep;
+
+			totlen += strlen(ep->key) + 2;
+
+			if (sep == '\0') {
+				totlen += strlen(ep->data);
+			} else {	/* check if escapes are needed */
+				char *s = ep->data;
+
+				while (*s) {
+					++totlen;
+					/* add room for needed escape chars */
+					if ((*s == sep) || (*s == '\\'))
+						++totlen;
+					++s;
+				}
+			}
+			totlen += 2;	/* for '=' and 'sep' char */
+		}
+	}
+
+#ifdef DEBUG
+	/* Pass 1a: print unsorted list */
+	printf("Unsorted: n=%d\n", n);
+	for (i = 0; i < n; ++i) {
+		printf("\t%3d: %p ==> %-10s => %s\n",
+		       i, list[i], list[i]->key, list[i]->data);
+	}
+#endif
+
+	/* Sort list by keys */
+	qsort(list, n, sizeof(ENTRY *), cmpkey);
+
+	/* Check if the user supplied buffer size is sufficient */
+	if (size) {
+		if (size < totlen + 1) {	/* provided buffer too small */
+			debug("### buffer too small: %d, but need %d\n",
+				size, totlen + 1);
+			__set_errno(ENOMEM);
+			return (-1);
+		}
+	} else {
+		size = totlen + 1;
+	}
+
+	/* Check if the user provided a buffer */
+	if (*resp) {
+		/* yes; clear it */
+		res = *resp;
+		memset(res, '\0', size);
+	} else {
+		/* no, allocate and clear one */
+		*resp = res = calloc(1, size);
+		if (res == NULL) {
+			__set_errno(ENOMEM);
+			return (-1);
+		}
+	}
+	/*
+	 * Pass 2:
+	 * export sorted list of result data
+	 */
+	for (i = 0, p = res; i < n; ++i) {
+		char *s;
+
+		s = list[i]->key;
+		while (*s)
+			*p++ = *s++;
+		*p++ = '=';
+
+		s = list[i]->data;
+
+		while (*s) {
+			if ((*s == sep) || (*s == '\\'))
+				*p++ = '\\';	/* escape */
+			*p++ = *s++;
+		}
+		*p++ = sep;
+	}
+	*p = '\0';		/* terminate result */
+
+	return size;
+}
+
+
+/*
+ * himport()
+ */
+
+/*
+ * Import linearized data into hash table.
+ *
+ * This is the inverse function to hexport(): it takes a linear list
+ * of "name=value" pairs and creates hash table entries from it.
+ *
+ * Entries without "value", i. e. consisting of only "name" or
+ * "name=", will cause this entry to be deleted from the hash table.
+ *
+ * The "flag" argument can be used to control the behaviour: when the
+ * H_NOCLEAR bit is set, then an existing hash table will kept, i. e.
+ * new data will be added to an existing hash table; otherwise, old
+ * data will be discarded and a new hash table will be created.
+ *
+ * The separator character for the "name=value" pairs can be selected,
+ * so we both support importing from externally stored environment
+ * data (separated by NUL characters) and from plain text files
+ * (entries separated by newline characters).
+ *
+ * To allow for nicely formatted text input, leading white space
+ * (sequences of SPACE and TAB chars) is ignored, and entries starting
+ * (after removal of any leading white space) with a '#' character are
+ * considered comments and ignored.
+ *
+ * [NOTE: this means that a variable name cannot start with a '#'
+ * character.]
+ *
+ * When using a non-NUL separator character, backslash is used as
+ * escape character in the value part, allowing for example for
+ * multi-line values.
+ *
+ * In theory, arbitrary separator characters can be used, but only
+ * '\0' and '\n' have really been tested.
+ */
+
+int himport(const char *env, size_t size, const char sep, int flag)
+{
+	return himport_r(&htab, env, size, sep, flag);
+}
+
+int himport_r(struct hsearch_data *htab,
+	      const char *env, size_t size, const char sep, int flag)
+{
+	char *data, *sp, *dp, *name, *value;
+
+	/* Test for correct arguments.  */
+	if (htab == NULL) {
+		__set_errno(EINVAL);
+		return 0;
+	}
+
+	/* we allocate new space to make sure we can write to the array */
+	if ((data = malloc(size)) == NULL) {
+		debug("himport_r: can't malloc %d bytes\n", size);
+		__set_errno(ENOMEM);
+		return 0;
+	}
+	memcpy(data, env, size);
+	dp = data;
+
+	if ((flag & H_NOCLEAR) == 0) {
+		/* Destroy old hash table if one exists */
+		debug("Destroy Hash Table: %p table = %p\n", htab,
+		       htab->table);
+		if (htab->table)
+			hdestroy_r(htab);
+	}
+
+	/*
+	 * Create new hash table (if needed).  The computation of the hash
+	 * table size is based on heuristics: in a sample of some 70+
+	 * existing systems we found an average size of 39+ bytes per entry
+	 * in the environment (for the whole key=value pair). Assuming a
+	 * size of 8 per entry (= safety factor of ~5) should provide enough
+	 * safety margin for any existing environment definitions and still
+	 * allow for more than enough dynamic additions. Note that the
+	 * "size" argument is supposed to give the maximum enviroment size
+	 * (CONFIG_ENV_SIZE).  This heuristics will result in
+	 * unreasonably large numbers (and thus memory footprint) for
+	 * big flash environments (>8,000 entries for 64 KB
+	 * envrionment size), so we clip it to a reasonable value.
+	 * On the other hand we need to add some more entries for free
+	 * space when importing very small buffers. Both boundaries can
+	 * be overwritten in the board config file if needed.
+	 */
+
+	if (!htab->table) {
+		int nent = CONFIG_ENV_MIN_ENTRIES + size / 8;
+
+		if (nent > CONFIG_ENV_MAX_ENTRIES)
+			nent = CONFIG_ENV_MAX_ENTRIES;
+
+		debug("Create Hash Table: N=%d\n", nent);
+
+		if (hcreate_r(nent, htab) == 0) {
+			free(data);
+			return 0;
+		}
+	}
+
+	/* Parse environment; allow for '\0' and 'sep' as separators */
+	do {
+		ENTRY e, *rv;
+
+		/* skip leading white space */
+		while ((*dp == ' ') || (*dp == '\t'))
+			++dp;
+
+		/* skip comment lines */
+		if (*dp == '#') {
+			while (*dp && (*dp != sep))
+				++dp;
+			++dp;
+			continue;
+		}
+
+		/* parse name */
+		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
+			;
+
+		/* deal with "name" and "name=" entries (delete var) */
+		if (*dp == '\0' || *(dp + 1) == '\0' ||
+		    *dp == sep || *(dp + 1) == sep) {
+			if (*dp == '=')
+				*dp++ = '\0';
+			*dp++ = '\0';	/* terminate name */
+
+			debug("DELETE CANDIDATE: \"%s\"\n", name);
+
+			if (hdelete_r(name, htab) == 0)
+				debug("DELETE ERROR ##############################\n");
+
+			continue;
+		}
+		*dp++ = '\0';	/* terminate name */
+
+		/* parse value; deal with escapes */
+		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
+			if ((*dp == '\\') && *(dp + 1))
+				++dp;
+			*sp++ = *dp;
+		}
+		*sp++ = '\0';	/* terminate value */
+		++dp;
+
+		/* enter into hash table */
+		e.key = name;
+		e.data = value;
+
+		hsearch_r(e, ENTER, &rv, htab);
+		if (rv == NULL) {
+			printf("himport_r: can't insert \"%s=%s\" into hash table\n",
+				name, value);
+			return 0;
+		}
+
+		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
+			htab, htab->filled, htab->size,
+			rv, name, value);
+	} while ((dp < data + size) && *dp);	/* size check needed for text */
+						/* without '\0' termination */
+	debug("INSERT: free(data = %p)\n", data);
+	free(data);
+
+	debug("INSERT: done\n");
+	return 1;		/* everything OK */
+}
Index: u-boot-2010.06/src/arch/arm/lib/qsort.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2010.06/src/arch/arm/lib/qsort.c	2012-05-12 12:19:56.999215880 -0600
@@ -0,0 +1,69 @@
+/*
+ * Code adapted from uClibc-0.9.30.3
+ *
+ * It is therefore covered by the GNU LESSER GENERAL PUBLIC LICENSE
+ * Version 2.1, February 1999
+ *
+ * Wolfgang Denk <wd@denx.de>
+ */
+
+/* This code is derived from a public domain shell sort routine by
+ * Ray Gardner and found in Bob Stout's snippets collection.  The
+ * original code is included below in an #if 0/#endif block.
+ *
+ * I modified it to avoid the possibility of overflow in the wgap
+ * calculation, as well as to reduce the generated code size with
+ * bcc and gcc. */
+
+#include <linux/types.h>
+#if 0
+#include <assert.h>
+#else
+#define assert(arg)
+#endif
+
+void qsort(void  *base,
+	   size_t nel,
+	   size_t width,
+	   int (*comp)(const void *, const void *))
+{
+	size_t wgap, i, j, k;
+	char tmp;
+
+	if ((nel > 1) && (width > 0)) {
+		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
+		wgap = 0;
+		do {
+			wgap = 3 * wgap + 1;
+		} while (wgap < (nel-1)/3);
+		/* From the above, we know that either wgap == 1 < nel or */
+		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
+		wgap *= width;			/* So this can not overflow if wnel doesn't. */
+		nel *= width;			/* Convert nel to 'wnel' */
+		do {
+			i = wgap;
+			do {
+				j = i;
+				do {
+					register char *a;
+					register char *b;
+
+					j -= wgap;
+					a = j + ((char *)base);
+					b = a + wgap;
+					if ((*comp)(a, b) <= 0) {
+						break;
+					}
+					k = width;
+					do {
+						tmp = *a;
+						*a++ = *b;
+						*b++ = tmp;
+					} while (--k);
+				} while (j >= wgap);
+				i += width;
+			} while (i < nel);
+			wgap = (wgap - width)/3;
+		} while (wgap);
+	}
+}
Index: u-boot-2010.06/src/common/command.c
===================================================================
--- u-boot-2010.06.orig/src/common/command.c	2012-05-12 12:19:49.847216230 -0600
+++ u-boot-2010.06/src/common/command.c	2012-05-12 12:19:56.999215880 -0600
@@ -160,6 +160,7 @@
 
 int var_complete(int argc, char *argv[], char last_char, int maxv, char *cmdv[])
 {
+#if 0 /* need to reimplement */
 	static char tmp_buf[512];
 	int space;
 
@@ -170,7 +171,7 @@
 
 	if (!space && argc == 2)
 		return env_complete(argv[1], maxv, cmdv, sizeof(tmp_buf), tmp_buf);
-
+#endif
 	return 0;
 }
 
@@ -188,9 +189,6 @@
 
 void install_auto_complete(void)
 {
-#if defined(CONFIG_CMD_EDITENV)
-	install_auto_complete_handler("editenv", var_complete);
-#endif
 	install_auto_complete_handler("printenv", var_complete);
 	install_auto_complete_handler("setenv", var_complete);
 #if defined(CONFIG_CMD_RUN)
Index: u-boot-2010.06/src/common/console.c
===================================================================
--- u-boot-2010.06.orig/src/common/console.c	2012-05-12 12:19:49.858890888 -0600
+++ u-boot-2010.06/src/common/console.c	2012-05-12 12:19:56.999215880 -0600
@@ -367,7 +367,7 @@
 	}
 }
 
-void printf(const char *fmt, ...)
+int printf(const char *fmt, ...)
 {
 	va_list args;
 	uint i;
@@ -383,6 +383,7 @@
 
 	/* Print the string */
 	puts(printbuffer);
+	return i;
 }
 
 void vprintf(const char *fmt, va_list args)
Index: u-boot-2010.06/src/common/env_common.c
===================================================================
--- u-boot-2010.06.orig/src/common/env_common.c	2012-05-12 12:19:49.866765346 -0600
+++ u-boot-2010.06/src/common/env_common.c	2012-05-12 12:19:56.999215880 -0600
@@ -1,10 +1,10 @@
 /*
- * (C) Copyright 2000-2002
+ * (C) Copyright 2000-2010
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
  * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
  * Andreas Heppel <aheppel@sysgo.de>
-
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -28,22 +28,12 @@
 #include <command.h>
 #include <environment.h>
 #include <linux/stddef.h>
+#include <search.h>
+#include <errno.h>
 #include <malloc.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#ifdef CONFIG_AMIGAONEG3SE
-	extern void enable_nvram(void);
-	extern void disable_nvram(void);
-#endif
-
-#undef DEBUG_ENV
-#ifdef DEBUG_ENV
-#define DEBUGF(fmt,args...) printf(fmt ,##args)
-#else
-#define DEBUGF(fmt,args...)
-#endif
-
 extern env_t *env_ptr;
 
 extern void env_relocate_spec (void);
@@ -139,49 +129,23 @@
 	"\0"
 };
 
-void env_crc_update (void)
-{
-	env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
-}
-
 static uchar env_get_char_init (int index)
 {
 	uchar c;
 
 	/* if crc was bad, use the default environment */
 	if (gd->env_valid)
-	{
 		c = env_get_char_spec(index);
-	} else {
+	else
 		c = default_environment[index];
-	}
 
 	return (c);
 }
 
-#ifdef CONFIG_AMIGAONEG3SE
 uchar env_get_char_memory (int index)
 {
-	uchar retval;
-	enable_nvram();
-	if (gd->env_valid) {
-		retval = ( *((uchar *)(gd->env_addr + index)) );
-	} else {
-		retval = ( default_environment[index] );
-	}
-	disable_nvram();
-	return retval;
+	return *env_get_addr(index);
 }
-#else
-uchar env_get_char_memory (int index)
-{
-	if (gd->env_valid) {
-		return ( *((uchar *)(gd->env_addr + index)) );
-	} else {
-		return ( default_environment[index] );
-	}
-}
-#endif
 
 uchar env_get_char (int index)
 {
@@ -198,78 +162,89 @@
 
 uchar *env_get_addr (int index)
 {
-	if (gd->env_valid) {
-		return ( ((uchar *)(gd->env_addr + index)) );
-	} else {
-		return (&default_environment[index]);
-	}
+	if (gd->env_valid)
+		return (uchar *)(gd->env_addr + index);
+	else
+		return &default_environment[index];
 }
 
-void set_default_env(void)
+void set_default_env(const char *s)
 {
 	if (sizeof(default_environment) > ENV_SIZE) {
-		puts ("*** Error - default environment is too large\n\n");
+		puts("*** Error - default environment is too large\n\n");
 		return;
 	}
 
-	memset(env_ptr, 0, sizeof(env_t));
-	memcpy(env_ptr->data, default_environment,
-	       sizeof(default_environment));
-#ifdef CONFIG_SYS_REDUNDAND_ENVIRONMENT
-	env_ptr->flags = 0xFF;
-#endif
-	env_crc_update ();
-	gd->env_valid = 1;
+	if (s) {
+		if (*s == '!') {
+			printf("*** Warning - %s, "
+				"using default environment\n\n",
+				s+1);
+		} else {
+			puts(s);
+		}
+	} else {
+		puts("Using default environment\n\n");
+	}
+
+	if (himport((char *)default_environment,
+		    sizeof(default_environment), '\0', 0) == 0) {
+		error("Environment import failed: errno = %d\n", errno);
+	}
+	gd->flags |= GD_FLG_ENV_READY;
 }
 
-void env_relocate (void)
+/*
+ * Check if CRC is valid and (if yes) import the environment.
+ * Note that "buf" may or may not be aligned.
+ */
+int env_import(const char *buf, int check)
 {
-#ifndef CONFIG_RELOC_FIXUP_WORKS
-	DEBUGF ("%s[%d] offset = 0x%lx\n", __FUNCTION__,__LINE__,
-		gd->reloc_off);
-#endif
+	env_t *ep = (env_t *)buf;
 
-#ifdef CONFIG_AMIGAONEG3SE
-	enable_nvram();
-#endif
+	if (check) {
+		uint32_t crc;
 
-#ifdef ENV_IS_EMBEDDED
-	/*
-	 * The environment buffer is embedded with the text segment,
-	 * just relocate the environment pointer
-	 */
-#ifndef CONFIG_RELOC_FIXUP_WORKS
-	env_ptr = (env_t *)((ulong)env_ptr + gd->reloc_off);
-#endif
-	DEBUGF ("%s[%d] embedded ENV at %p\n", __FUNCTION__,__LINE__,env_ptr);
-#else
-	/*
-	 * We must allocate a buffer for the environment
-	 */
-	env_ptr = (env_t *)malloc (CONFIG_ENV_SIZE);
-	DEBUGF ("%s[%d] malloced ENV at %p\n", __FUNCTION__,__LINE__,env_ptr);
-#endif
+		memcpy(&crc, &ep->crc, sizeof(crc));
+
+		if (crc32(0, ep->data, ENV_SIZE) != crc) {
+			set_default_env("!bad CRC");
+			return 0;
+		}
+	}
 
+	if (himport((char *)ep->data, ENV_SIZE, '\0', 0)) {
+		gd->flags |= GD_FLG_ENV_READY;
+		return 1;
+	}
+
+	error("Cannot import environment: errno = %d\n", errno);
+
+	set_default_env("!import failed");
+
+	return 0;
+}
+
+void env_relocate (void)
+{
+#if defined(CONFIG_NEEDS_MANUAL_RELOC)
+	extern void env_reloc(void);
+
+	env_reloc();
+#endif
 	if (gd->env_valid == 0) {
-#if defined(CONFIG_GTH)	|| defined(CONFIG_ENV_IS_NOWHERE)	/* Environment not changable */
-		puts ("Using default environment\n\n");
+#if defined(CONFIG_ENV_IS_NOWHERE)	/* Environment not changable */
+		set_default_env(NULL);
 #else
-		puts ("*** Warning - bad CRC, using default environment\n\n");
 		show_boot_progress (-60);
+		set_default_env("!bad CRC");
 #endif
-		set_default_env();
-	}
-	else {
+	} else {
 		env_relocate_spec ();
 	}
-	gd->env_addr = (ulong)&(env_ptr->data);
-
-#ifdef CONFIG_AMIGAONEG3SE
-	disable_nvram();
-#endif
 }
 
-#ifdef CONFIG_AUTO_COMPLETE
+#if 0 /* need to reimplement - def CONFIG_AUTO_COMPLETE */
 int env_complete(char *var, int maxv, char *cmdv[], int bufsz, char *buf)
 {
 	int i, nxt, len, vallen, found;
Index: u-boot-2010.06/src/common/env_nand.c
===================================================================
--- u-boot-2010.06.orig/src/common/env_nand.c	2012-05-12 12:19:49.842519269 -0600
+++ u-boot-2010.06/src/common/env_nand.c	2012-05-12 12:19:56.999215880 -0600
@@ -1,16 +1,16 @@
 /*
+ * (C) Copyright 2000-2010
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
  * (C) Copyright 2008
  * Stuart Wood, Lab X Technologies <stuart.wood@labxtechnologies.com>
  *
  * (C) Copyright 2004
  * Jian Zhang, Texas Instruments, jzhang@ti.com.
-
- * (C) Copyright 2000-2006
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
  * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
  * Andreas Heppel <aheppel@sysgo.de>
-
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -30,7 +30,7 @@
  * MA 02111-1307 USA
  */
 
-/* #define DEBUG */
+#define DEBUG
 
 #include <common.h>
 #include <command.h>
@@ -38,6 +38,8 @@
 #include <linux/stddef.h>
 #include <malloc.h>
 #include <nand.h>
+#include <search.h>
+#include <errno.h>
 
 #if defined(CONFIG_CMD_SAVEENV) && defined(CONFIG_CMD_NAND)
 #define CMD_SAVEENV
@@ -49,10 +51,6 @@
 #error CONFIG_ENV_SIZE_REDUND should be the same as CONFIG_ENV_SIZE
 #endif
 
-#ifdef CONFIG_INFERNO
-#error CONFIG_INFERNO not supported yet
-#endif
-
 #ifndef CONFIG_ENV_RANGE
 #define CONFIG_ENV_RANGE	CONFIG_ENV_SIZE
 #endif
@@ -60,7 +58,7 @@
 /* references to names in env_common.c */
 extern uchar default_environment[];
 
-char * env_name_spec = "NAND";
+char *env_name_spec = "NAND";
 
 
 #if defined(ENV_IS_EMBEDDED)
@@ -72,12 +70,6 @@
 env_t *env_ptr = 0;
 #endif /* ENV_IS_EMBEDDED */
 
-
-/* local functions */
-#if !defined(ENV_IS_EMBEDDED)
-static void use_default(void);
-#endif
-
 DECLARE_GLOBAL_DATA_PTR;
 
 uchar env_get_char_spec (int index)
@@ -85,17 +77,17 @@
 	return ( *((uchar *)(gd->env_addr + index)) );
 }
 
-
-/* this is called before nand_init()
- * so we can't read Nand to validate env data.
- * Mark it OK for now. env_relocate() in env_common.c
- * will call our relocate function which does the real
- * validation.
+/*
+ * This is called before nand_init() so we can't read NAND to
+ * validate env data.
+ *
+ * Mark it OK for now. env_relocate() in env_common.c will call our
+ * relocate function which does the real validation.
  *
  * When using a NAND boot image (like sequoia_nand), the environment
- * can be embedded or attached to the U-Boot image in NAND flash. This way
- * the SPL loads not only the U-Boot image from NAND but also the
- * environment.
+ * can be embedded or attached to the U-Boot image in NAND flash.
+ * This way the SPL loads not only the U-Boot image from NAND but
+ * also the environment.
  */
 int env_init(void)
 {
@@ -192,11 +184,12 @@
 #ifdef CONFIG_ENV_OFFSET_REDUND
 int saveenv(void)
 {
-	int ret = 0;
+	env_t	env_new;
+	ssize_t	len;
+	char	*res;
+	int	ret = 0;
 	nand_erase_options_t nand_erase_options;
 
-	env_ptr->flags++;
-
 	nand_erase_options.length = CONFIG_ENV_RANGE;
 	nand_erase_options.quiet = 0;
 	nand_erase_options.jffs2 = 0;
@@ -204,36 +197,53 @@
 
 	if (CONFIG_ENV_RANGE < CONFIG_ENV_SIZE)
 		return 1;
+
+	res = (char *)&env_new.data;
+	len = hexport('\0', &res, ENV_SIZE);
+	if (len < 0) {
+		error("Cannot export environment: errno = %d\n", errno);
+		return 1;
+	}
+	env_new.crc   = crc32(0, env_new.data, ENV_SIZE);
+	env_new.flags = ACTIVE_FLAG;
+
 	if(gd->env_valid == 1) {
-		puts ("Erasing redundant Nand...\n");
+		puts("Erasing redundant NAND...\n");
 		nand_erase_options.offset = CONFIG_ENV_OFFSET_REDUND;
 		if (nand_erase_opts(&nand_info[0], &nand_erase_options))
 			return 1;
 
-		puts ("Writing to redundant Nand... ");
-		ret = writeenv(CONFIG_ENV_OFFSET_REDUND, (u_char *) env_ptr);
+		puts("Writing to redundant NAND... ");
+		ret = writeenv(CONFIG_ENV_OFFSET_REDUND,
+			(u_char *)&env_new);
 	} else {
-		puts ("Erasing Nand...\n");
+		puts("Erasing NAND...\n");
 		nand_erase_options.offset = CONFIG_ENV_OFFSET;
 		if (nand_erase_opts(&nand_info[0], &nand_erase_options))
 			return 1;
 
-		puts ("Writing to Nand... ");
-		ret = writeenv(CONFIG_ENV_OFFSET, (u_char *) env_ptr);
+		puts("Writing to NAND... ");
+		ret = writeenv(CONFIG_ENV_OFFSET,
+			(u_char *)&env_new);
 	}
 	if (ret) {
 		puts("FAILED!\n");
 		return 1;
 	}
 
-	puts ("done\n");
+	puts("done\n");
+
 	gd->env_valid = (gd->env_valid == 2 ? 1 : 2);
+
 	return ret;
 }
 #else /* ! CONFIG_ENV_OFFSET_REDUND */
 int saveenv(void)
 {
 	int ret = 0;
+	env_t	env_new;
+	ssize_t	len;
+	char	*res;
 	nand_erase_options_t nand_erase_options;
 
 	nand_erase_options.length = CONFIG_ENV_RANGE;
@@ -244,23 +254,32 @@
 
 	if (CONFIG_ENV_RANGE < CONFIG_ENV_SIZE)
 		return 1;
-	puts ("Erasing Nand...\n");
+
+	res = (char *)&env_new.data;
+	len = hexport('\0', &res, ENV_SIZE);
+	if (len < 0) {
+		error("Cannot export environment: errno = %d\n", errno);
+		return 1;
+	}
+	env_new.crc   = crc32(0, env_new.data, ENV_SIZE);
+
+	puts("Erasing Nand...\n");
 	if (nand_erase_opts(&nand_info[0], &nand_erase_options))
 		return 1;
 
-	puts ("Writing to Nand... ");
-	if (writeenv(CONFIG_ENV_OFFSET, (u_char *) env_ptr)) {
+	puts("Writing to Nand... ");
+	if (writeenv(CONFIG_ENV_OFFSET, (u_char *)&env_new)) {
 		puts("FAILED!\n");
 		return 1;
 	}
 
-	puts ("done\n");
+	puts("done\n");
 	return ret;
 }
 #endif /* CONFIG_ENV_OFFSET_REDUND */
 #endif /* CMD_SAVEENV */
 
-int readenv (size_t offset, u_char * buf)
+int readenv(size_t offset, u_char * buf)
 {
 	size_t end = offset + CONFIG_ENV_RANGE;
 	size_t amount_loaded = 0;
@@ -268,10 +287,6 @@
 
 	u_char *char_ptr;
 
-	/* fail if no nand detected */
-	if (nand_info[0].type == 0)
-		return 1;
-
 	blocksize = nand_info[0].erasesize;
 	if (!blocksize)
 		return 1;
@@ -282,7 +297,7 @@
 			offset += blocksize;
 		} else {
 			char_ptr = &buf[amount_loaded];
-			if (nand_read(&nand_info[0], offset, &len, char_ptr))
+			if (nand_read_skip_bad(&nand_info[0], offset, &len, char_ptr))
 				return 1;
 			offset += blocksize;
 			amount_loaded += len;
@@ -294,48 +309,83 @@
 	return 0;
 }
 
+#ifdef CONFIG_ENV_OFFSET_OOB
+int get_nand_env_oob(nand_info_t *nand, unsigned long *result)
+{
+	struct mtd_oob_ops ops;
+	uint32_t oob_buf[ENV_OFFSET_SIZE/sizeof(uint32_t)];
+	int ret;
+
+	ops.datbuf = NULL;
+	ops.mode = MTD_OOB_AUTO;
+	ops.ooboffs = 0;
+	ops.ooblen = ENV_OFFSET_SIZE;
+	ops.oobbuf = (void *) oob_buf;
+
+	ret = nand->read_oob(nand, ENV_OFFSET_SIZE, &ops);
+	if (ret) {
+		printf("error reading OOB block 0\n");
+		return ret;
+	}
+
+	if (oob_buf[0] == ENV_OOB_MARKER) {
+		*result = oob_buf[1] * nand->erasesize;
+	} else if (oob_buf[0] == ENV_OOB_MARKER_OLD) {
+		*result = oob_buf[1];
+	} else {
+		printf("No dynamic environment marker in OOB block 0\n");
+		return -ENOENT;
+	}
+
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_ENV_OFFSET_REDUND
-void env_relocate_spec (void)
+void env_relocate_spec(void)
 {
 #if !defined(ENV_IS_EMBEDDED)
 	int crc1_ok = 0, crc2_ok = 0;
-	env_t *tmp_env1, *tmp_env2;
+	env_t *ep, *tmp_env1, *tmp_env2;
 
-	tmp_env1 = (env_t *) malloc(CONFIG_ENV_SIZE);
-	tmp_env2 = (env_t *) malloc(CONFIG_ENV_SIZE);
+	tmp_env1 = (env_t *)malloc(CONFIG_ENV_SIZE);
+	tmp_env2 = (env_t *)malloc(CONFIG_ENV_SIZE);
 
 	if ((tmp_env1 == NULL) || (tmp_env2 == NULL)) {
 		puts("Can't allocate buffers for environment\n");
-		free (tmp_env1);
-		free (tmp_env2);
-		return use_default();
+		free(tmp_env1);
+		free(tmp_env2);
+		set_default_env("!malloc() failed");
+		return;
 	}
 
 	if (readenv(CONFIG_ENV_OFFSET, (u_char *) tmp_env1))
-		puts("No Valid Environment Area Found\n");
+		puts("No Valid Environment Area found\n");
+
 	if (readenv(CONFIG_ENV_OFFSET_REDUND, (u_char *) tmp_env2))
-		puts("No Valid Reundant Environment Area Found\n");
+		puts("No Valid Redundant Environment Area found\n");
 
 	crc1_ok = (crc32(0, tmp_env1->data, ENV_SIZE) == tmp_env1->crc);
 	crc2_ok = (crc32(0, tmp_env2->data, ENV_SIZE) == tmp_env2->crc);
 
-	if(!crc1_ok && !crc2_ok) {
+	if (!crc1_ok && !crc2_ok) {
 		free(tmp_env1);
 		free(tmp_env2);
-		return use_default();
-	} else if(crc1_ok && !crc2_ok)
+		set_default_env("!bad CRC");
+		return;
+	} else if (crc1_ok && !crc2_ok) {
 		gd->env_valid = 1;
-	else if(!crc1_ok && crc2_ok)
+	} else if (!crc1_ok && crc2_ok) {
 		gd->env_valid = 2;
-	else {
+	} else {
 		/* both ok - check serial */
-		if(tmp_env1->flags == 255 && tmp_env2->flags == 0)
+		if (tmp_env1->flags == 255 && tmp_env2->flags == 0)
 			gd->env_valid = 2;
-		else if(tmp_env2->flags == 255 && tmp_env1->flags == 0)
+		else if (tmp_env2->flags == 255 && tmp_env1->flags == 0)
 			gd->env_valid = 1;
-		else if(tmp_env1->flags > tmp_env2->flags)
+		else if (tmp_env1->flags > tmp_env2->flags)
 			gd->env_valid = 1;
-		else if(tmp_env2->flags > tmp_env1->flags)
+		else if (tmp_env2->flags > tmp_env1->flags)
 			gd->env_valid = 2;
 		else /* flags are equal - almost impossible */
 			gd->env_valid = 1;
@@ -343,40 +393,52 @@
 	}
 
 	free(env_ptr);
-	if(gd->env_valid == 1) {
-		env_ptr = tmp_env1;
-		free(tmp_env2);
-	} else {
-		env_ptr = tmp_env2;
-		free(tmp_env1);
-	}
+
+	if (gd->env_valid == 1)
+		ep = tmp_env1;
+	else
+		ep = tmp_env2;
+
+	env_import((char *)ep, 0);
+
+	free(tmp_env1);
+	free(tmp_env2);
 
 #endif /* ! ENV_IS_EMBEDDED */
 }
 #else /* ! CONFIG_ENV_OFFSET_REDUND */
 /*
- * The legacy NAND code saved the environment in the first NAND device i.e.,
- * nand_dev_desc + 0. This is also the behaviour using the new NAND code.
+ * The legacy NAND code saved the environment in the first NAND
+ * device i.e., nand_dev_desc + 0. This is also the behaviour using
+ * the new NAND code.
  */
 void env_relocate_spec (void)
 {
 #if !defined(ENV_IS_EMBEDDED)
 	int ret;
+	char buf[CONFIG_ENV_SIZE];
 
-	ret = readenv(CONFIG_ENV_OFFSET, (u_char *) env_ptr);
-	if (ret)
-		return use_default();
+#if defined(CONFIG_ENV_OFFSET_OOB)
+	ret = get_nand_env_oob(&nand_info[0], &nand_env_oob_offset);
+	/*
+	 * If unable to read environment offset from NAND OOB then fall through
+	 * to the normal environment reading code below
+	 */
+	if (!ret) {
+		printf("Found Environment offset in OOB..\n");
+	} else {
+		set_default_env("!no env offset in OOB");
+		return;
+	}
+#endif
 
-	if (crc32(0, env_ptr->data, ENV_SIZE) != env_ptr->crc)
-		return use_default();
+	ret = readenv(CONFIG_ENV_OFFSET, (u_char *)buf);
+	if (ret) {
+		set_default_env("!readenv() failed");
+		return;
+	}
+
+	env_import(buf, 1);
 #endif /* ! ENV_IS_EMBEDDED */
 }
 #endif /* CONFIG_ENV_OFFSET_REDUND */
-
-#if !defined(ENV_IS_EMBEDDED)
-static void use_default()
-{
-	puts ("*** Warning - bad CRC or NAND, using default environment\n\n");
-	set_default_env();
-}
-#endif
Index: u-boot-2010.06/src/common/env_sf.c
===================================================================
--- u-boot-2010.06.orig/src/common/env_sf.c	2012-05-12 12:19:49.838474345 -0600
+++ u-boot-2010.06/src/common/env_sf.c	2012-05-12 12:19:56.999215880 -0600
@@ -142,7 +142,7 @@
 err_crc:
 	puts("*** Warning - bad CRC, using default environment\n\n");
 
-	set_default_env();
+	set_default_env("!bad CRC");
 }
 
 int env_init(void)
Index: u-boot-2010.06/src/include/common.h
===================================================================
--- u-boot-2010.06.orig/src/include/common.h	2012-05-12 12:19:49.870727019 -0600
+++ u-boot-2010.06/src/include/common.h	2012-05-12 12:19:56.999215880 -0600
@@ -470,6 +470,7 @@
 /* $(CPU)/serial.c */
 int	serial_init   (void);
 void	serial_exit   (void);
+void	serial_addr   (unsigned int);
 void	serial_setbrg (void);
 void	serial_putc   (const char);
 void	serial_putc_raw(const char);
@@ -672,7 +673,7 @@
 /* stdout */
 void	putc(const char c);
 void	puts(const char *s);
-void	printf(const char *fmt, ...)
+int	printf(const char *fmt, ...)
 		__attribute__ ((format (__printf__, 1, 2)));
 void	vprintf(const char *fmt, va_list args);
 
Index: u-boot-2010.06/src/include/environment.h
===================================================================
--- u-boot-2010.06.orig/src/include/environment.h	2012-05-12 12:19:49.890601315 -0600
+++ u-boot-2010.06/src/include/environment.h	2012-05-12 12:19:57.003215547 -0600
@@ -148,6 +148,6 @@
 void env_crc_update (void);
 
 /* [re]set to the default environment */
-void set_default_env(void);
+void set_default_env(const char *s);
 
 #endif	/* _ENVIRONMENT_H_ */
Index: u-boot-2010.06/src/include/errno.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2010.06/src/include/errno.h	2012-05-12 12:19:57.003215547 -0600
@@ -0,0 +1,9 @@
+#ifndef _ERRNO_H
+
+#include <asm-generic/errno.h>
+
+extern int errno;
+
+#define __set_errno(val) do { errno = val; } while (0)
+
+#endif /* _ERRNO_H */
Index: u-boot-2010.06/src/include/exports.h
===================================================================
--- u-boot-2010.06.orig/src/include/exports.h	2012-05-12 12:19:49.882603099 -0600
+++ u-boot-2010.06/src/include/exports.h	2012-05-12 12:19:57.003215547 -0600
@@ -11,7 +11,7 @@
 int  tstc(void);
 void putc(const char);
 void puts(const char*);
-void printf(const char* fmt, ...);
+int printf(const char* fmt, ...);
 void install_hdlr(int, interrupt_handler_t*, void*);
 void free_hdlr(int);
 void *malloc(size_t);
Index: u-boot-2010.06/src/include/search.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot-2010.06/src/include/search.h	2012-05-12 12:19:57.003215547 -0600
@@ -0,0 +1,106 @@
+/*
+ * Declarations for System V style searching functions.
+ * Copyright (C) 1995-1999, 2000 Free Software Foundation, Inc.
+ * This file is part of the GNU C Library.
+ *
+ * The GNU C Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * The GNU C Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with the GNU C Library; if not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307 USA.
+ */
+
+/*
+ * Based on code from uClibc-0.9.30.3
+ * Extensions for use within U-Boot
+ * Copyright (C) 2010 Wolfgang Denk <wd@denx.de>
+ */
+
+#ifndef _SEARCH_H
+#define	_SEARCH_H 1
+
+#include <stddef.h>
+
+#define __set_errno(val) do { errno = val; } while (0)
+
+/*
+ * Prototype structure for a linked-list data structure.
+ * This is the type used by the `insque' and `remque' functions.
+ */
+
+/* For use with hsearch(3).  */
+typedef int (*__compar_fn_t) (__const void *, __const void *);
+typedef __compar_fn_t comparison_fn_t;
+
+/* Action which shall be performed in the call the hsearch.  */
+typedef enum {
+	FIND,
+	ENTER
+} ACTION;
+
+typedef struct entry {
+	char *key;
+	char *data;
+} ENTRY;
+
+/* Opaque type for internal use.  */
+struct _ENTRY;
+
+/*
+ * Family of hash table handling functions.  The functions also
+ * have reentrant counterparts ending with _r.  The non-reentrant
+ * functions all work on a signle internal hashing table.
+ */
+
+/* Data type for reentrant functions.  */
+struct hsearch_data {
+	struct _ENTRY *table;
+	unsigned int size;
+	unsigned int filled;
+};
+
+/* Create a new hashing table which will at most contain NEL elements.  */
+extern int hcreate(size_t __nel);
+extern int hcreate_r(size_t __nel, struct hsearch_data *__htab);
+
+/* Destroy current internal hashing table.  */
+extern void hdestroy(void);
+extern void hdestroy_r(struct hsearch_data *__htab);
+
+/*
+ * Search for entry matching ITEM.key in internal hash table.  If
+ * ACTION is `FIND' return found entry or signal error by returning
+ * NULL.  If ACTION is `ENTER' replace existing data (if any) with
+ * ITEM.data.
+ * */
+extern ENTRY *hsearch(ENTRY __item, ACTION __action);
+extern int hsearch_r(ENTRY __item, ACTION __action, ENTRY ** __retval,
+		     struct hsearch_data *__htab);
+
+/* Search and delete entry matching ITEM.key in internal hash table. */
+extern int hdelete(const char *__key);
+extern int hdelete_r(const char *__key, struct hsearch_data *__htab);
+
+extern ssize_t hexport(const char __sep, char **__resp, size_t __size);
+extern ssize_t hexport_r(struct hsearch_data *__htab,
+		     const char __sep, char **__resp, size_t __size);
+
+extern int himport(const char *__env, size_t __size, const char __sep,
+		   int __flag);
+extern int himport_r(struct hsearch_data *__htab,
+		     const char *__env, size_t __size, const char __sep,
+		     int __flag);
+
+/* Flags for himport() / himport_r() */
+#define	H_NOCLEAR	1	/* do not clear hash table before importing */
+
+#endif /* search.h */
Index: u-boot-2010.06/src/common/cmd_nvedit.c
===================================================================
--- u-boot-2010.06.orig/src/common/cmd_nvedit.c	2012-05-12 12:19:49.854558777 -0600
+++ u-boot-2010.06/src/common/cmd_nvedit.c	2012-05-12 12:19:57.003215547 -0600
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2000-2002
+ * (C) Copyright 2000-2010
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
  * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
@@ -24,28 +24,26 @@
  * MA 02111-1307 USA
  */
 
-/**************************************************************************
- *
+/*
  * Support for persistent environment data
  *
- * The "environment" is stored as a list of '\0' terminated
- * "name=value" strings. The end of the list is marked by a double
- * '\0'. New entries are always added at the end. Deleting an entry
- * shifts the remaining entries to the front. Replacing an entry is a
- * combination of deleting the old value and adding the new one.
+ * The "environment" is stored on external storage as a list of '\0'
+ * terminated "name=value" strings. The end of the list is marked by
+ * a double '\0'. The environment is preceeded by a 32 bit CRC over
+ * the data part and, in case of redundant environment, a byte of
+ * flags.
  *
- * The environment is preceeded by a 32 bit CRC over the data part.
- *
- **************************************************************************
+ * This linearized representation will also be used before
+ * relocation, i. e. as long as we don't have a full C runtime
+ * environment. After that, we use a hash table.
  */
 
 #include <common.h>
 #include <command.h>
 #include <environment.h>
-#include <asm/arch/emac_defs.h>
-#if defined(CONFIG_CMD_EDITENV)
+#include <search.h>
+#include <errno.h>
 #include <malloc.h>
-#endif
 #include <watchdog.h>
 #include <serial.h>
 #include <linux/stddef.h>
@@ -73,8 +71,10 @@
 #define XMK_STR(x)	#x
 #define MK_STR(x)	XMK_STR(x)
 
-/************************************************************************
-************************************************************************/
+/*
+ * Maximum expected input data size for import command
+ */
+#define	MAX_ENV_SIZE	(1 << 18)	/* 1 MiB */
 
 /*
  * Table with supported baudrates (defined in config_xyz.h)
@@ -83,7 +83,7 @@
 #define	N_BAUDRATES (sizeof(baudrate_table) / sizeof(baudrate_table[0]))
 
 /*
- * This variable is incremented on each do_setenv (), so it can
+ * This variable is incremented on each do_env_set(), so it can
  * be used via get_env_id() as an indication, if the environment
  * has changed or not. So it is possible to reread an environment
  * variable only if the environment was changed ... done so for
@@ -95,61 +95,51 @@
 {
 	return env_id;
 }
-/************************************************************************
+
+/*
  * Command interface: print one or all environment variables
+ *
+ * Returns 0 in case of error, or length of printed string
  */
+static int env_print(char *name)
+{
+	char *res = NULL;
+	size_t len;
 
-/*
- * state 0: finish printing this string and return (matched!)
- * state 1: no matching to be done; print everything
- * state 2: continue searching for matched name
- */
-static int printenv(char *name, int state)
-{
-	int i, j;
-	char c, buf[17];
-
-	i = 0;
-	buf[16] = '\0';
-
-	while (state && env_get_char(i) != '\0') {
-		if (state == 2 && envmatch((uchar *)name, i) >= 0)
-			state = 0;
-
-		j = 0;
-		do {
-			buf[j++] = c = env_get_char(i++);
-			if (j == sizeof(buf) - 1) {
-				if (state <= 1)
-					puts(buf);
-				j = 0;
-			}
-		} while (c != '\0');
+	if (name) {		/* print a single name */
+		ENTRY e, *ep;
 
-		if (state <= 1) {
-			if (j)
-				puts(buf);
-			putc('\n');
-		}
+		e.key = name;
+		e.data = NULL;
+		ep = hsearch (e, FIND);
+		if (ep == NULL)
+			return 0;
+		len = printf ("%s=%s\n", ep->key, ep->data);
+		return len;
+	}
+
+	/* print whole list */
+	len = hexport('\n', &res, 0);
 
-		if (ctrlc())
-			return -1;
+	if (len > 0) {
+		puts(res);
+		free(res);
+		return len;
 	}
 
-	if (state == 0)
-		i = 0;
-	return i;
+	/* should never happen */
+	return 0;
 }
 
-int do_printenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+int do_env_print (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	int i;
 	int rcode = 0;
 
 	if (argc == 1) {
 		/* print all env vars */
-		rcode = printenv(NULL, 1);
-		if (rcode < 0)
+		rcode = env_print(NULL);
+		if (!rcode)
 			return 1;
 		printf("\nEnvironment size: %d/%ld bytes\n",
 			rcode, (ulong)ENV_SIZE);
@@ -158,9 +148,9 @@
 
 	/* print selected env vars */
 	for (i = 1; i < argc; ++i) {
-		char *name = argv[i];
-		if (printenv(name, 2)) {
-			printf("## Error: \"%s\" not defined\n", name);
+		int rc = env_print(argv[i]);
+		if (!rc) {
+			printf("## Error: \"%s\" not defined\n", argv[i]);
 			++rcode;
 		}
 	}
@@ -168,25 +158,18 @@
 	return rcode;
 }
 
-/************************************************************************
+/*
  * Set a new environment variable,
  * or replace or delete an existing one.
- *
- * This function will ONLY work with a in-RAM copy of the environment
  */
 
-int _do_setenv (int flag, int argc, char *argv[])
+int _do_env_set (int flag, int argc, char * const argv[])
 {
-	int   i, len, oldval;
+	bd_t  *bd = gd->bd;
+	int   i, len;
 	int   console = -1;
-	uchar *env, *nxt = NULL;
-	char *name;
-	bd_t *bd = gd->bd;
-
-	uchar *env_data = env_get_addr(0);
-
-	if (!env_data)	/* need copy in RAM */
-		return 1;
+	char  *name, *value, *s;
+	ENTRY e, *ep;
 
 	name = argv[1];
 
@@ -199,13 +182,9 @@
 	/*
 	 * search if variable with this name already exists
 	 */
-	oldval = -1;
-	for (env=env_data; *env; env=nxt+1) {
-		for (nxt=env; *nxt; ++nxt)
-			;
-		if ((oldval = envmatch((uchar *)name, env-env_data)) >= 0)
-			break;
-	}
+	e.key = name;
+	e.data = NULL;
+	ep = hsearch (e, FIND);
 
 	/* Check for console redirection */
 	if (strcmp(name,"stdin") == 0) {
@@ -239,37 +218,25 @@
 	}
 
 	/*
-	 * Delete any existing definition
+	 * Some variables like "ethaddr" and "serial#" can be set only
+	 * once and cannot be deleted; also, "ver" is readonly.
 	 */
-	if (oldval >= 0) {
+	if (ep) {		/* variable exists */
 #ifndef CONFIG_ENV_OVERWRITE
-
-		/*
-		 * Ethernet Address and serial# can be set only once,
-		 * ver is readonly.
-		 */
-		if (
-#ifdef CONFIG_HAS_UID
-		/* Allow serial# forced overwrite with 0xdeaf4add flag */
-		    ((strcmp (name, "serial#") == 0) && (flag != 0xdeaf4add)) ||
-#else
-		    (strcmp (name, "serial#") == 0) ||
-#endif
+		if ((strcmp (name, "serial#") == 0) ||
 		    ((strcmp (name, "ethaddr") == 0)
 #if defined(CONFIG_OVERWRITE_ETHADDR_ONCE) && defined(CONFIG_ETHADDR)
-		     && (strcmp ((char *)env_get_addr(oldval),MK_STR(CONFIG_ETHADDR)) != 0)
+		     && (strcmp (ep->data,MK_STR(CONFIG_ETHADDR)) != 0)
 #endif	/* CONFIG_OVERWRITE_ETHADDR_ONCE && CONFIG_ETHADDR */
 		    ) ) {
 			printf ("Can't overwrite \"%s\"\n", name);
 			return 1;
 		}
 #endif
-
-
 		/*
 		 * Switch to new baudrate if new baudrate is supported
 		 */
-		if (strcmp(argv[1],"baudrate") == 0) {
+		if (strcmp(name,"baudrate") == 0) {
 			int baudrate = simple_strtoul(argv[2], NULL, 10);
 			int i;
 			for (i=0; i<N_BAUDRATES; ++i) {
@@ -296,75 +263,50 @@
 				      break;
 			}
 		}
-
-		if (*++nxt == '\0') {
-			if (env > env_data) {
-				env--;
-			} else {
-				*env = '\0';
-			}
-		} else {
-			for (;;) {
-				*env = *nxt++;
-				if ((*env == '\0') && (*nxt == '\0'))
-					break;
-				++env;
-			}
-		}
-		*++env = '\0';
 	}
 
 	/* Delete only ? */
 	if ((argc < 3) || argv[2] == NULL) {
-		env_crc_update ();
-		return 0;
+		int rc = hdelete(name);
+		return !rc;
 	}
 
 	/*
-	 * Append new definition at the end
+	 * Insert / replace new value
 	 */
-	for (env=env_data; *env || *(env+1); ++env)
-		;
-	if (env > env_data)
-		++env;
-	/*
-	 * Overflow when:
-	 * "name" + "=" + "val" +"\0\0"  > ENV_SIZE - (env-env_data)
-	 */
-	len = strlen(name) + 2;
-	/* add '=' for first arg, ' ' for all others */
-	for (i=2; i<argc; ++i) {
+	for (i=2,len=0; i<argc; ++i) {
 		len += strlen(argv[i]) + 1;
 	}
-	if (len > (&env_data[ENV_SIZE]-env)) {
-		printf ("## Error: environment overflow, \"%s\" deleted\n", name);
+	if ((value = malloc(len)) == NULL) {
+		printf("## Can't malloc %d bytes\n", len);
 		return 1;
 	}
-	while ((*env = *name++) != '\0')
-		env++;
-	for (i=2; i<argc; ++i) {
-		char *val = argv[i];
+	for (i=2,s=value; i<argc; ++i) {
+		char *v = argv[i];
 
-		*env = (i==2) ? '=' : ' ';
-		while ((*++env = *val++) != '\0')
+		while ((*s++ = *v++) != '\0')
 			;
+		*(s-1) = ' ';
 	}
+	if (s != value)
+		*--s = '\0';
 
-	/* end is marked with double '\0' */
-	*++env = '\0';
-
-	/* Update CRC */
-	env_crc_update ();
+	e.key  = name;
+	e.data = value;
+	ep = hsearch(e, ENTER);
+	free(value);
+	if (!ep) {
+		printf("## Error inserting \"%s\" variable, errno=%d\n",
+			name, errno);
+		return 1;
+	}
 
 	/*
 	 * Some variables should be updated when the corresponding
-	 * entry in the enviornment is changed
+	 * entry in the environment is changed
 	 */
 
-	if (strcmp(argv[1],"ethaddr") == 0)
-		return 0;
-
-	if (strcmp(argv[1],"ipaddr") == 0) {
+	if (strcmp(name,"ipaddr") == 0) {
 		char *s = argv[2];	/* always use only one arg */
 		char *e;
 		unsigned long addr;
@@ -377,70 +319,46 @@
 		}
 		bd->bi_ip_addr = htonl(addr);
 		return 0;
-	}
-	if (strcmp(argv[1],"loadaddr") == 0) {
+	} else if (strcmp(argv[1],"loadaddr") == 0) {
 		load_addr = simple_strtoul(argv[2], NULL, 16);
 		return 0;
 	}
 #if defined(CONFIG_CMD_NET)
-	if (strcmp(argv[1],"bootfile") == 0) {
+	else if (strcmp(argv[1],"bootfile") == 0) {
 		copy_filename (BootFile, argv[2], sizeof(BootFile));
 		return 0;
 	}
 #endif
-
-#ifdef CONFIG_AMIGAONEG3SE
-	if (strcmp(argv[1], "vga_fg_color") == 0 ||
-	    strcmp(argv[1], "vga_bg_color") == 0 ) {
-		extern void video_set_color(unsigned char attr);
-		extern unsigned char video_get_attr(void);
-
-		video_set_color(video_get_attr());
-		return 0;
-	}
-#endif	/* CONFIG_AMIGAONEG3SE */
-
 	return 0;
 }
 
 int setenv (char *varname, char *varvalue)
 {
-	char *argv[4] = { "setenv", varname, varvalue, NULL };
+	char * const argv[4] = { "setenv", varname, varvalue, NULL };
 	if ((varvalue == NULL) || (varvalue[0] == '\0'))
-		return _do_setenv (0, 2, argv);
+		return _do_env_set(0, 2, argv);
 	else
-		return _do_setenv (0, 3, argv);
+		return _do_env_set(0, 3, argv);
 }
 
-#ifdef CONFIG_HAS_UID
-void forceenv (char *varname, char *varvalue)
+int do_env_set (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
-	char *argv[4] = { "forceenv", varname, varvalue, NULL };
-	_do_setenv (0xdeaf4add, 3, argv);
-}
-#endif
+	if (argc < 2)
+		return cmd_usage(cmdtp);
 
-int do_setenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
-{
-	if (argc < 2) {
-		cmd_usage(cmdtp);
-		return 1;
-	}
-
-	return _do_setenv (flag, argc, argv);
+	return _do_env_set(flag, argc, argv);
 }
 
-/************************************************************************
+/*
  * Prompt for environment variable
  */
-
 #if defined(CONFIG_CMD_ASKENV)
-int do_askenv ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+int do_env_ask ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	extern char console_buffer[CONFIG_SYS_CBSIZE];
 	char message[CONFIG_SYS_CBSIZE];
 	int size = CONFIG_SYS_CBSIZE - 1;
-	int len;
+	int i, len, pos;
 	char *local_args[4];
 
 	local_args[0] = argv[0];
@@ -448,40 +366,30 @@
 	local_args[2] = NULL;
 	local_args[3] = NULL;
 
-	if (argc < 2) {
-		cmd_usage(cmdtp);
-		return 1;
-	}
 	/* Check the syntax */
 	switch (argc) {
 	case 1:
-		cmd_usage(cmdtp);
-		return 1;
+		return cmd_usage(cmdtp);
 
-	case 2:		/* askenv envname */
-		sprintf (message, "Please enter '%s':", argv[1]);
+	case 2:		/* env_ask envname */
+		sprintf(message, "Please enter '%s':", argv[1]);
 		break;
 
-	case 3:		/* askenv envname size */
-		sprintf (message, "Please enter '%s':", argv[1]);
-		size = simple_strtoul (argv[2], NULL, 10);
+	case 3:		/* env_ask envname size */
+		sprintf(message, "Please enter '%s':", argv[1]);
+		size = simple_strtoul(argv[2], NULL, 10);
 		break;
 
-	default:	/* askenv envname message1 ... messagen size */
-	    {
-		int i;
-		int pos = 0;
-
-		for (i = 2; i < argc - 1; i++) {
+	default:	/* env_ask envname message1 ... messagen size */
+		for (i=2,pos=0; i < argc - 1; i++) {
 			if (pos) {
 				message[pos++] = ' ';
 			}
-			strcpy (message+pos, argv[i]);
+			strcpy(message+pos, argv[i]);
 			pos += strlen(argv[i]);
 		}
 		message[pos] = '\0';
-		size = simple_strtoul (argv[argc - 1], NULL, 10);
-	    }
+		size = simple_strtoul(argv[argc - 1], NULL, 10);
 		break;
 	}
 
@@ -492,7 +400,7 @@
 		return 1;
 
 	/* prompt for input */
-	len = readline (message);
+	len = readline(message);
 
 	if (size < len)
 		console_buffer[size] = '\0';
@@ -504,24 +412,22 @@
 	}
 
 	/* Continue calling setenv code */
-	return _do_setenv (flag, len, local_args);
+	return _do_env_set(flag, len, local_args);
 }
 #endif
 
-/************************************************************************
+/*
  * Interactively edit an environment variable
  */
 #if defined(CONFIG_CMD_EDITENV)
-int do_editenv(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	char buffer[CONFIG_SYS_CBSIZE];
 	char *init_val;
 	int len;
 
-	if (argc < 2) {
-		cmd_usage(cmdtp);
-		return 1;
-	}
+	if (argc < 2)
+		return cmd_usage(cmdtp);
 
 	/* Set read buffer to initial value or empty sting */
 	init_val = getenv(argv[1]);
@@ -536,35 +442,37 @@
 }
 #endif /* CONFIG_CMD_EDITENV */
 
-/************************************************************************
- * Look up variable from environment,
- * return address of storage for that variable,
- * or NULL if not found
- */
 
-char *getenv (char *name)
+/*
+int getenv_r (char *name, char *buf, unsigned len)
 {
-	int i, nxt;
-
-	WATCHDOG_RESET();
+    int i, nxt;
 
 	for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
-		int val;
-
+		int val, n;
 		for (nxt=i; env_get_char(nxt) != '\0'; ++nxt) {
-			if (nxt >= CONFIG_ENV_SIZE) {
-				return (NULL);
-			}
+	    	    if (nxt >= CONFIG_ENV_SIZE) {
+			return (-1);
+		    }
 		}
-		if ((val=envmatch((uchar *)name, i)) < 0)
-			continue;
-		return ((char *)env_get_addr(val));
+    		if ((val=envmatch((uchar *)name, i)) < 0)
+		continue;
+	    // found; copy out
+	    n = 0;
+	    while ((len > n++) && (*buf++ = env_get_char(val++)) != '\0');
+	    if (len == n)
+		*buf = '\0';
+	    return (n);
 	}
-
-	return (NULL);
+	return (-1);
 }
 
-int getenv_r (char *name, char *buf, unsigned len)
+*/
+
+/*
+ * Look up variable from environment for restricted C runtime env.
+ */
+int getenv_f (char *name, char *buf, unsigned len)
 {
 	int i, nxt;
 
@@ -578,20 +486,54 @@
 		}
 		if ((val=envmatch((uchar *)name, i)) < 0)
 			continue;
+
 		/* found; copy out */
-		n = 0;
-		while ((len > n++) && (*buf++ = env_get_char(val++)) != '\0')
-			;
-		if (len == n)
-			*buf = '\0';
-		return (n);
+		for (n=0; n<len; ++n, ++buf) {
+			if ((*buf = env_get_char(val++)) == '\0')
+				return n;
+		}
+
+		if (n)
+			*--buf = '\0';
+
+		printf("env_buf too small [%d]\n", len);
+
+		return n;
 	}
 	return (-1);
 }
 
+/*
+ * Look up variable from environment,
+ * return address of storage for that variable,
+ * or NULL if not found
+ */
+char *getenv (char *name)
+{
+	if (gd->flags & GD_FLG_ENV_READY) {	/* after import into hashtable */
+		ENTRY e, *ep;
+
+		WATCHDOG_RESET();
+
+		e.key  = name;
+		e.data = NULL;
+		ep = hsearch (e, FIND);
+
+		return (ep ? ep->data : NULL);
+	}
+
+	/* restricted capabilities before import */
+
+	if (getenv_f(name, (char *)(gd->env_buf), sizeof(gd->env_buf)) > 0)
+		return (char *)(gd->env_buf);
+
+	return NULL;
+}
+
+
 #if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)
 
-int do_saveenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+int do_env_save (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	extern char * env_name_spec;
 
@@ -601,7 +543,7 @@
 }
 
 U_BOOT_CMD(
-	saveenv, 1, 0,	do_saveenv,
+	saveenv, 1, 0,	do_env_save,
 	"save environment variables to persistent storage",
 	""
 );
@@ -609,7 +551,7 @@
 #endif
 
 
-/************************************************************************
+/*
  * Match a name / name=value pair
  *
  * s1 is either a simple 'name', or a 'name=value' pair.
@@ -628,12 +570,349 @@
 	return(-1);
 }
 
+static int do_env_default(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	if ((argc != 2) || (strcmp(argv[1], "-f") != 0)) {
+		return cmd_usage(cmdtp);
+	}
+	set_default_env("## Resetting to default environment\n");
+	return 0;
+}
+
+static int do_env_delete(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	printf("Not implemented yet\n");
+	return 0;
+}
+
+/*
+ * env export [-t | -b | -c] addr [size]
+ *	-t:	export as text format; if size is given, data will be
+ *		padded with '\0' bytes; if not, one terminating '\0'
+ *		will be added (which is included in the "filesize"
+ *		setting so you can for exmple copy this to flash and
+ *		keep the termination).
+ *	-b:	export as binary format (name=value pairs separated by
+ *		'\0', list end marked by double "\0\0")
+ *	-c:	export as checksum protected environment format as
+ *		used for example by "saveenv" command
+ *	addr:	memory address where environment gets stored
+ *	size:	size of output buffer
+ *
+ * With "-c" and size is NOT given, then the export command will
+ * format the data as currently used for the persistent storage,
+ * i. e. it will use CONFIG_ENV_SECT_SIZE as output block size and
+ * prepend a valid CRC32 checksum and, in case of resundant
+ * environment, a "current" redundancy flag. If size is given, this
+ * value will be used instead of CONFIG_ENV_SECT_SIZE; again, CRC32
+ * checksum and redundancy flag will be inserted.
+ *
+ * With "-b" and "-t", always only the real data (including a
+ * terminating '\0' byte) will be written; here the optional size
+ * argument will be used to make sure not to overflow the user
+ * provided buffer; the command will abort if the size is not
+ * sufficient. Any remainign space will be '\0' padded.
+ *
+ * On successful return, the variable "filesize" will be set.
+ * Note that filesize includes the trailing/terminating '\0' byte(s).
+ *
+ * Usage szenario:  create a text snapshot/backup of the current settings:
+ *
+ *	=> env export -t 100000
+ *	=> era ${backup_addr} +${filesize}
+ *	=> cp.b 100000 ${backup_addr} ${filesize}
+ *
+ * Re-import this snapshot, deleting all other settings:
+ *
+ *	=> env import -d -t ${backup_addr}
+ */
+static int do_env_export(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char	buf[32];
+	char	*addr, *cmd, *res;
+	size_t	size;
+	ssize_t	len;
+	env_t	*envp;
+	char	sep = '\n';
+	int	chk = 0;
+	int	fmt = 0;
+
+	cmd = *argv;
+
+	while (--argc > 0 && **++argv == '-') {
+		char *arg = *argv;
+		while (*++arg) {
+			switch (*arg) {
+			case 'b':		/* raw binary format */
+				if (fmt++)
+					goto sep_err;
+				sep = '\0';
+				break;
+			case 'c':		/* external checksum format */
+				if (fmt++)
+					goto sep_err;
+				sep = '\0';
+				chk = 1;
+				break;
+			case 't':		/* text format */
+				if (fmt++)
+					goto sep_err;
+				sep = '\n';
+				break;
+			default:
+				return cmd_usage(cmdtp);
+			}
+		}
+	}
+
+	if (argc < 1) {
+		return cmd_usage(cmdtp);
+	}
+
+	addr = (char *)simple_strtoul(argv[0], NULL, 16);
+
+	if (argc == 2) {
+		size = simple_strtoul(argv[1], NULL, 16);
+		memset(addr, '\0', size);
+	} else {
+		size = 0;
+	}
+
+	if (sep) {		/* export as text file */
+		len = hexport(sep, &addr, size);
+		if (len < 0) {
+			printf("Cannot export environment: errno = %d\n",
+				errno);
+			return 1;
+		}
+		sprintf(buf, "%zX", len);
+		setenv("filesize", buf);
+
+		return 0;
+	}
+
+	envp = (env_t *)addr;
+
+	if (chk)		/* export as checksum protected block */
+		res = (char *)envp->data;
+	else			/* export as raw binary data */
+		res = addr;
+
+	len = hexport('\0', &res, ENV_SIZE);
+	if (len < 0) {
+		printf("Cannot export environment: errno = %d\n",
+			errno);
+		return 1;
+	}
+
+	if (chk) {
+		envp->crc   = crc32(0, envp->data, ENV_SIZE);
+#ifdef CONFIG_ENV_ADDR_REDUND
+		envp->flags = ACTIVE_FLAG;
+#endif
+	}
+	sprintf(buf, "%zX", len + offsetof(env_t,data));
+	setenv("filesize", buf);
+
+	return 0;
+
+sep_err:
+	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
+		cmd);
+	return 1;
+}
+
+/*
+ * env import [-d] [-t | -b | -c] addr [size]
+ *	-d:	delete existing environment before importing;
+ *		otherwise overwrite / append to existion definitions
+ *	-t:	assume text format; either "size" must be given or the
+ *		text data must be '\0' terminated
+ *	-b:	assume binary format ('\0' separated, "\0\0" terminated)
+ *	-c:	assume checksum protected environment format
+ *	addr:	memory address to read from
+ *	size:	length of input data; if missing, proper '\0'
+ *		termination is mandatory
+ */
+static int do_env_import(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	char	*cmd, *addr;
+	char	sep = '\n';
+	int	chk = 0;
+	int	fmt = 0;
+	int	del = 0;
+	size_t	size;
+
+	cmd = *argv;
+
+	while (--argc > 0 && **++argv == '-') {
+		char *arg = *argv;
+		while (*++arg) {
+			switch (*arg) {
+			case 'b':		/* raw binary format */
+				if (fmt++)
+					goto sep_err;
+				sep = '\0';
+				break;
+			case 'c':		/* external checksum format */
+				if (fmt++)
+					goto sep_err;
+				sep = '\0';
+				chk = 1;
+				break;
+			case 't':		/* text format */
+				if (fmt++)
+					goto sep_err;
+				sep = '\n';
+				break;
+			case 'd':
+				del = 1;
+				break;
+			default:
+				return cmd_usage(cmdtp);
+			}
+		}
+	}
+
+	if (argc < 1) {
+		return cmd_usage(cmdtp);
+	}
+
+	if (!fmt)
+		printf("## Warning: defaulting to text format\n");
+
+	addr = (char *)simple_strtoul(argv[0], NULL, 16);
+
+	if (argc == 2) {
+		size = simple_strtoul(argv[1], NULL, 16);
+	} else {
+		char *s = addr;
+
+		size = 0;
+
+		while (size < MAX_ENV_SIZE) {
+			if ((*s == sep) && (*(s+1) == '\0'))
+				break;
+			++s;
+			++size;
+		}
+		if (size == MAX_ENV_SIZE) {
+			printf("## Warning: Input data exceeds %d bytes"
+				" - truncated\n", MAX_ENV_SIZE);
+		}
+		++size;
+		printf("## Info: input data size = %zd = 0x%zX\n", size, size);
+	}
+
+	if (chk) {
+		uint32_t crc;
+		env_t *ep = (env_t *)addr;
+
+		size -= offsetof(env_t, data);
+		memcpy(&crc, &ep->crc, sizeof(crc));
+
+		if (crc32(0, ep->data, size) != crc) {
+			puts("## Error: bad CRC, import failed\n");
+			return 1;
+		}
+		addr = (char *)ep->data;
+	}
+
+	if (himport(addr, size, sep, del ? 0 : H_NOCLEAR) == 0) {
+		printf("Environment import failed: errno = %d\n", errno);
+		return 1;
+	}
+	gd->flags |= GD_FLG_ENV_READY;
+
+	return 0;
+
+sep_err:
+	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
+		cmd);
+	return 1;
+}
+
+#if defined(CONFIG_CMD_RUN)
+extern int do_run (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+#endif
 
-/**************************************************/
+/*
+ * New command line interface: "env" command with subcommands
+ */
+static cmd_tbl_t cmd_env_sub[] = {
+#if defined(CONFIG_CMD_ASKENV)
+	U_BOOT_CMD_MKENT(ask, CONFIG_SYS_MAXARGS, 1, do_env_ask, "", ""),
+#endif
+	U_BOOT_CMD_MKENT(default, 1, 0, do_env_default, "", ""),
+	U_BOOT_CMD_MKENT(delete, 2, 0, do_env_delete, "", ""),
+#if defined(CONFIG_CMD_EDITENV)
+	U_BOOT_CMD_MKENT(edit, 2, 0, do_env_edit, "", ""),
+#endif
+	U_BOOT_CMD_MKENT(export, 4, 0, do_env_export, "", ""),
+	U_BOOT_CMD_MKENT(import, 5, 0, do_env_import, "", ""),
+	U_BOOT_CMD_MKENT(print, CONFIG_SYS_MAXARGS, 1, do_env_print, "", ""),
+#if defined(CONFIG_CMD_RUN)
+	U_BOOT_CMD_MKENT(run, CONFIG_SYS_MAXARGS, 1, do_run, "", ""),
+#endif
+#if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)
+	U_BOOT_CMD_MKENT(save, 1, 0, do_env_save, "", ""),
+#endif
+	U_BOOT_CMD_MKENT(set, CONFIG_SYS_MAXARGS, 0, do_env_set, "", ""),
+};
+
+#if defined(CONFIG_NEEDS_MANUAL_RELOC)
+void env_reloc(void)
+{
+	fixup_cmdtable(cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
+}
+#endif
+
+static int do_env (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	cmd_tbl_t *cp;
+
+	if (argc < 2)
+		return cmd_usage(cmdtp);
+
+	/* drop initial "env" arg */
+	argc--;
+	argv++;
+
+	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
+
+	if (cp)
+		return cp->cmd(cmdtp, flag, argc, argv);
+
+	return cmd_usage(cmdtp);
+}
+
+U_BOOT_CMD(
+	env, CONFIG_SYS_MAXARGS, 1, do_env,
+	"environment handling commands",
+#if defined(CONFIG_CMD_ASKENV)
+	"ask name [message] [size] - ask for environment variable\nenv "
+#endif
+	"default -f - reset default environment\n"
+#if defined(CONFIG_CMD_EDITENV)
+	"env edit name - edit environment variable\n"
+#endif
+	"env export [-t | -b | -c] addr [size] - export environmnt\n"
+	"env import [-d] [-t | -b | -c] addr [size] - import environmnt\n"
+	"env print [name ...] - print environment\n"
+#if defined(CONFIG_CMD_RUN)
+	"env run var [...] - run commands in an environment variable\n"
+#endif
+	"env save - save environment\n"
+	"env set [-f] name [arg ...]\n"
+);
+
+/*
+ * Old command line interface, kept for compatibility
+ */
 
 #if defined(CONFIG_CMD_EDITENV)
 U_BOOT_CMD(
-	editenv, 2, 0,	do_editenv,
+	editenv, 2, 0,	do_env_edit,
 	"edit environment variable",
 	"name\n"
 	"    - edit environment variable 'name'"
@@ -641,7 +920,7 @@
 #endif
 
 U_BOOT_CMD(
-	printenv, CONFIG_SYS_MAXARGS, 1,	do_printenv,
+	printenv, CONFIG_SYS_MAXARGS, 1,	do_env_print,
 	"print environment variables",
 	"\n    - print values of all environment variables\n"
 	"printenv name ...\n"
@@ -649,7 +928,7 @@
 );
 
 U_BOOT_CMD(
-	setenv, CONFIG_SYS_MAXARGS, 0,	do_setenv,
+	setenv, CONFIG_SYS_MAXARGS, 0,	do_env_set,
 	"set environment variables",
 	"name value ...\n"
 	"    - set environment variable 'name' to 'value ...'\n"
@@ -660,7 +939,7 @@
 #if defined(CONFIG_CMD_ASKENV)
 
 U_BOOT_CMD(
-	askenv,	CONFIG_SYS_MAXARGS,	1,	do_askenv,
+	askenv,	CONFIG_SYS_MAXARGS,	1,	do_env_ask,
 	"get environment variables from stdin",
 	"name [message] [size]\n"
 	"    - get environment variable 'name' from stdin (max 'size' chars)\n"
@@ -675,7 +954,6 @@
 #endif
 
 #if defined(CONFIG_CMD_RUN)
-int do_run (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
 U_BOOT_CMD(
 	run,	CONFIG_SYS_MAXARGS,	1,	do_run,
 	"run commands in an environment variable",
