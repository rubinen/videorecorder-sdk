# metainfo
# Copyright RidgeRun 2008, 2012
#
# This script provides a wrapper that in turns provides the 
# required lines for host packages dependencies, target package
# dependencies and provided build, linking and library directories.
#
# Usage
# metainfo -p <path to directory> [OPTIONS]
# Where OPTIONS could be:
#  -o: Returns the host required packages. 
#  -a: Returns the contents of the Apps.defs, generated or
#      taken from the actual Apps.defs file.
#  -d: Returns the dependencies just like the dependencies files. 
#      Or the contents of the actual "dependencies" file.
#  -c: Checks if it is selected in $DEVDIR/bsp/mach/bspconfig    
#  -p: Path to the application to where we want to extract the 
#      information.
#
# Many of them are mutual exclusive, for example, the -a output 
# must omit the -o and -d outputs, so the final product could be
# valid.
#
# Priority Considerations:
# - Backward compatibility is a must!
# - If this script founds any of the following files, they will
#   be used instead of the metainfo file (appname/metainfo).
#   + Apps.defs
#   + dependencies

# List of variables being used and zero lenght initialized
APPSDEFS=""
DEPENDS=""
HOSTPKG=""
PKG=""
DEVP=""
NEWPKG=""
OLDDEPENDS=""
OLDAPPSDEFS=""
METAINFO=""
CONFIG_NAME=""
CONFIG_SELECT=""


# Apps.defs 
# - Will be generated using the following variables from the metainfo
#   file:
#   + NAME (ie: NICETOOL)
#   + DEFS_* (DEFS_INCLUDE, DEFS_LIB, DEFS_SBIN, DEFS_BIN, etc). 
# - The output format would be like:
#   $CONFIG_NAME=/path/to/app (NICETOOL=$DEVDIR/fs/apps/nicetool-1.0)
#   $CONFIG_NAME_INCLUDE=$CONFIG_NAME_contents/Output/include
#       NICETOOL_INCLUDE=$NICETOOL/Output/include
function appsdefs_out {
 PKG="$1"
 if test -n "$OLDAPPSDEFS" 
  then 
   cat $PKG/Apps.defs
   echo "" # Extra new line padding, for improved comfort
 elif test -n "$METAINFO" && grep NAME $PKG/metainfo >/dev/null
  then
  CONFIG_NAME=`grep NAME $PKG/metainfo | sed -e "s/NAME.//" -e "s/\"//g"`
  DEVP=`echo $DEVDIR | sed -e "s/\//\./g"` 
  NEWPKG=`echo $PKG | sed -e "s/$DEVP//"`
  echo "$CONFIG_NAME=\$(DEVDIR)$NEWPKG"
  grep ^DEFS_ $PKG/metainfo | sed -e "s/DEFS/$CONFIG_NAME/" -e "s/\"//g"
 fi
}


# dependencies
# - Generated by outputting every component in its own line.
function dependencies_out {
 PKG="$1"
 if test -n "$OLDDEPENDS"
  then cat $PKG/dependencies
 elif test -n "$METAINFO"
  then 
   DEPPARTS=`grep ^TARGET_REQUIRED= $PKG/metainfo | sed -e "s/TARGET_REQUIRED=//" -e "s/\"//g"`
   for i in $DEPPARTS
    do
    echo $i
   done
 fi
}


# hostpkg
# - Generated by outputting every component in its own line.
# - Will output only those components that doesn't appear in 
#   $DEVDIR/fs/hostreqs
function hostpkg_out {
 PKG="$1"
 if test -n "$METAINFO"
  then 
 HOSTPARTS=`grep ^HOST_REQUIRED= $PKG/metainfo | sed -e "s/HOST_REQUIRED=//" -e "s/\"//g"`
 for i in $HOSTPARTS
  do
   if ! grep -x $i $DEVDIR/fs/hostreqs > /dev/null 
    then echo $i
   fi
  done
 fi
}


# Will check if an application is selected in the configuration
# file
# - Sets CONFIG_SELECT to the correspondent boolean string
# - If this script is invoked with -c, it will exit with 0 if the config is
# selected, with 1 otherwise, it is used in dependencies.makefile this way
function config_check {
 if test -n "$FORCE_CHECK" ; then
    CONFIG_SELECT="true";
    return;
 fi
 
 PKG="$1"

 if test -n "$METAINFO" && grep -i ^CONFIG= $PKG/metainfo >/dev/null
  then 
  CONFIG=`grep -i ^CONFIG= $PKG/metainfo | sed -e "s/CONFIG=//" -e "s/\"//g"`
 elif test -f $PKG/Config
  then
  CONFIG=`grep ^config $PKG/Config | head -n1  | sed -e "s/.*\ //"`
 fi

 if test -n "$CONFIG" && grep $CONFIG $DEVDIR/bsp/mach/bspconfig | grep -i y$ > /dev/null
  then 
   CONFIG_SELECT="true"
  else 
   CONFIG_SELECT="false"
 fi

 # Some folders may have a metainfo file without a Config file.
 # For these cases, the dependencies are assumed required independent
 # of bspconfig values.
 if test -n "$METAINFO" && ! test -f $PKG/Config
  then
   CONFIG_SELECT="true"
 fi
}

# path_check 
# - Check that the directory exists
# - If there are Apps.defs or dependencies files and
#   set preceding order of which files to use. 
# - If there is a metainfo file
function path_check {
 PKG="$1"
 if ! test -d $PKG
  then
  if test -n "$CONFIG"
  then 
   exit 1
  else
   # The path is not a directory - exit
   exit
  fi
 else 
  NEWPKG=`(cd $PKG; pwd)`
  PKG=$NEWPKG
 fi 

 if test -f $PKG/dependencies
  then OLDDEPENDS="true"
 fi
 if test -f $PKG/Apps.defs
  then OLDAPPSDEFS="true"
 fi
 if test -f $PKG/metainfo
  then METAINFO="true"
 fi
}


# Script flow starts below ( aka main() )

# Command line options parsing
# -a: Apps.defs
# -d: dependencies
# -o: host package 
# -f: do not check if is enabled or not
# -c: return if the package is selected in the configuration
# -p: package location

while getopts  ":adocfp:" options; do
 case $options in
  a ) APPSDEFS="true";;
  d ) DEPENDS="true";;
  o ) HOSTPKG="true";;
  c ) CONFIG="true";;
  f ) FORCE_CHECK="true";;
  p ) PKG=$OPTARG;;
  \? ) echo $usage
   exit 1;;
  * ) echo $usage
   exit 1;;
 esac
done


if test -z "$APPSDEFS" || test -z "$DEPENDS"
 then false
 else echo "# Only one option from [-a -d] allowed"
fi


if test -z "$PKG"
 then echo "# No package directory specified!"
 else 
  path_check "$PKG"
fi


if test -n "$CONFIG"
 then config_check $PKG 
 if test $CONFIG_SELECT = "true"
  then exit 0 
 else
  exit 1
 fi
fi


if test -n "$HOSTPKG"
 then 
 config_check $PKG
 if test "$CONFIG_SELECT" = "true" 
 then
  touch $DEVDIR/fs/hostreqs
  hostpkg_out $PKG
 fi
fi


if test -n "$APPSDEFS"
 then appsdefs_out $PKG
fi


if test -n "$DEPENDS"
 then dependencies_out $PKG
fi

